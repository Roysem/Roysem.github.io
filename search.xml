<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面向对象之基础</title>
    <url>/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="面向对象之基础"><a href="#面向对象之基础" class="headerlink" title="面向对象之基础"></a>面向对象之基础</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>this , static关键字</li>
<li>final 关键字</li>
<li>package,import关键字</li>
<li>代码块介绍</li>
</ol>
<h2 id="1-this，static关键字"><a href="#1-this，static关键字" class="headerlink" title="1.this，static关键字"></a>1.this，static关键字</h2><h3 id="1-1this关键字"><a href="#1-1this关键字" class="headerlink" title="1.1this关键字"></a>1.1this关键字</h3><h4 id="1-1-1this关键字介绍"><a href="#1-1-1this关键字介绍" class="headerlink" title="1.1.1this关键字介绍"></a>1.1.1this关键字介绍</h4><p><strong>this关键字说明</strong>：this是java提供的关键字，表示当前实例化的对象本身</p>
<p><strong>作用：可以用来区分成员变量和局部变量</strong></p>
<p>当我们出现了成员变量和局部变量名称相同的情况，可以采用 this 关键字区分，被this关键字修饰的是 成员变量。</p>
<p><strong>使用：</strong></p>
<ul>
<li><p><strong>this.属性名：</strong>来访问类中的成员变量，用来区分成员变量和局部变量</p>
</li>
<li><p>**this.方法名(参数值…):**用来访问本类的成员方法，通常直接省略；</p>
</li>
<li><p>**this(参数值…):**访问本类的构造方法。</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1、this.属性名在同一个类的方法中，用来区分成员变量和局部变量用的比较常见，且不可以省略；</span><br><span class="line"></span><br><span class="line">2、this.方法名(参数值...)这种用法的this可以省略，实际上通常都会省略；</span><br><span class="line"></span><br><span class="line">3、this(参数值...)调用构造方法时，必须在构造方法内的第一条执行；多个构造方法内不要相互使用来调用。</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2例子"><a href="#1-1-2例子" class="headerlink" title="1.1.2例子"></a>1.1.2例子</h4><p><strong>1.this.属性名</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 成员变量</span></span><br><span class="line">	String username; </span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是一个无参构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.username = username;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是一个有参构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成员方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">		System.out.println(username+<span class="string">&quot;在学习&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> <strong>this.方法名(参数值…)</strong></li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;方法1执行&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.method2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;方法2执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThisDemo t= <span class="keyword">new</span> ThisDemo();</span><br><span class="line">		t.method1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>this(参数值…)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;方法1执行&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.method2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;方法2执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThisDemo t= <span class="keyword">new</span> ThisDemo();</span><br><span class="line">		t.method1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-1-3-内存图"><a href="#1-1-3-内存图" class="headerlink" title="1.1.3 内存图"></a>1.1.3 内存图</h4><p>   <img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%9F%BA%E7%A1%80/image-20210721145621716.jpg"></p>
<h3 id="1-2-static关键字"><a href="#1-2-static关键字" class="headerlink" title="1.2 static关键字"></a>1.2 static关键字</h3><h4 id="1-2-1-static关键字介绍"><a href="#1-2-1-static关键字介绍" class="headerlink" title="1.2.1 static关键字介绍"></a>1.2.1 static关键字介绍</h4><p><strong>static关键字说明：</strong>static关键字是java提供的，方便在没有创建对象的情况下进行调用(方法/变量)。static可以用来修饰类的成员方法、类的成员变量，另外也可以编写static代码块来优化程序性能。</p>
<p><strong>使用：</strong></p>
<ul>
<li><p><strong>static成员变量：</strong>static变量也称为静态变量</p>
<ul>
<li><p><strong>静态变量被所有对象共享，在内存中只有一个副本，在类初次加载的时候才会初始化；</strong></p>
</li>
<li><p>非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响；</p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure>

<!--static成员变量初始化顺序按照定义的顺序来进行初始话--></li>
</ul>
</li>
<li><p><strong>static方法：</strong></p>
<ul>
<li>由于静态方法<strong>不依赖于任何对象就可以直接访问</strong>，因此对于静态方法来说，是<strong>没有this的</strong></li>
<li><strong>静态方法中不能访问类的非静态成员</strong>，因为非静态成员变量和非静态方法都必须依赖于具体的对象才能被调用；</li>
<li>static方法<strong>通常作用一个工具类中统一对外提供的方法使用</strong>，比如之前学习的Arrays数组工具类中的方法都是static的。</li>
</ul>
</li>
</ul>
<h4 id="1-2-2-static-关键字使用"><a href="#1-2-2-static-关键字使用" class="headerlink" title="1.2.2 static 关键字使用"></a>1.2.2 static 关键字使用</h4><p>1.<strong>static成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义一个静态变量</span></span><br><span class="line">	<span class="keyword">static</span> String schoolName=<span class="string">&quot;武汉花园&quot;</span>;</span><br><span class="line">	String username;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemoTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、使用对象访问静态变量</span></span><br><span class="line">		Teacher t= <span class="keyword">new</span> Teacher();</span><br><span class="line">		System.out.println(t.schoolName);</span><br><span class="line">		t.schoolName=<span class="string">&quot;武汉厚浦教育科技有限公司&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2、可以直接使用类访问静态变量</span></span><br><span class="line">		System.out.println(Teacher.schoolName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>static方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义一个静态变量</span></span><br><span class="line">	<span class="keyword">static</span> String schoolName=<span class="string">&quot;武汉厚浦&quot;</span>;</span><br><span class="line">	String username;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">// 定义一个静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;你该休息休息了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemoTest2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、使用对象访问静态方法</span></span><br><span class="line">		Teacher t= <span class="keyword">new</span> Teacher();</span><br><span class="line">		t.sleep();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2、可以直接使用类访问静态方法</span></span><br><span class="line">		Teacher.sleep();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-final-关键字"><a href="#2-final-关键字" class="headerlink" title="2.final 关键字"></a>2.final 关键字</h2><h3 id="2-1-final关键字介绍"><a href="#2-1-final关键字介绍" class="headerlink" title="2.1 final关键字介绍"></a>2.1 final关键字介绍</h3><p>java提供有一个final关键字，中文意思是最终、终极的意思，在Java中代表不可变更的意思。final关键字可以用来修饰类、成员变量、成员方法。</p>
<ul>
<li><strong>java修饰类：</strong>表示最终类，也就是此类不能被继承</li>
<li><strong>final修饰变量：</strong>表示常量，也就是一个变量的值始终如一，无法变更</li>
<li><strong>final修饰方法</strong>：表示最终方法，也就是此方法不能被重写。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>被final修饰的<strong>成员变量</strong>，必须<strong>进行初始化赋值</strong>，且<strong>值不能变更</strong>，否则编译出错；</li>
<li>被final修饰的成员变量，通常会结合final和static关键字一起使用，表示一个全局的静态常量，常量名用大写；</li>
<li>被final修饰的<strong>局部变量</strong>，<strong>不能使用static修饰</strong>，<strong>同时可以不用先初始化赋值，</strong>使用时进行一次赋值即可，后续也不能变更；</li>
<li>inal修饰基本数据类型，表示该基本数据类型的值一旦在<strong>初始化后便不能发生变化</strong>；</li>
<li>final修饰引用数据类型，则在对其初始化之后便<strong>不能再改变引用地址</strong>了，但该<strong>引用所指向的对象的内容是可以发生变化的</strong>。</li>
</ul>
<h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p><strong>final修饰类的情况</strong></p>
<p><img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%9F%BA%E7%A1%80/image-20210722170556811.jpg"></p>
<p>我们java当中的字符串类String就是被final修饰，字符串没有子类，所有的方法都不可以被重写</p>
<p><strong>final修饰方法的情况</strong></p>
<p><img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%9F%BA%E7%A1%80/image-20210722171007929.jpg"></p>
<p>如果后期：想要实现当前类里面某个方法不要被重写，可以将该方法设置final修饰</p>
<p><strong>final修饰变量的情况</strong></p>
<p>修饰的是基本数据类型，<strong>表示的值不能变</strong></p>
<p><img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%9F%BA%E7%A1%80/image-20210722171605154.jpg"></p>
<p>修饰的是引用数据类型，<strong>表示的是地址值不能变</strong></p>
<p><img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%9F%BA%E7%A1%80/image-20210722171910479.jpg"></p>
<h2 id="3-import-package关键字"><a href="#3-import-package关键字" class="headerlink" title="3.import,package关键字"></a>3.import,package关键字</h2><h3 id="3-1package关键字"><a href="#3-1package关键字" class="headerlink" title="3.1package关键字"></a>3.1package关键字</h3><p><strong>作用：</strong>package包其实就是目录，通常情况下，我们会对文件进行分文别类来管理，在Java 中称为分包管理，包名称通常采用小写。</p>
<p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package 包名;</span></span><br><span class="line"><span class="keyword">package</span> com.hopu.test;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><p>为了解决同类的命名冲突问题，在类名前加命名空间(包机制)，进行分包管理；</p>
</li>
<li><p>在Java中使用package语句定义包，<strong>多级包名之间用逗号“.”分隔</strong>(单包，复包)；</p>
</li>
<li><p><strong>package语句只能出现在Java源文件的第一行；</strong></p>
</li>
<li><p>package定义的格式，通常采用公司域名倒叙方式，例如com.myhopu.oa。</p>
</li>
</ul>
<h3 id="3-2-import-关键字"><a href="#3-2-import-关键字" class="headerlink" title="3.2 import 关键字"></a>3.2 import 关键字</h3><p><strong>作用：</strong>import的作用就是<strong>导入不同包下的类</strong>（包名+类名）。也就是说，我们在某个类方法中，使用到了其他特殊包下的类，那么就需要先引入包包下的类，然后才可以使用，否则会编译错误。</p>
<p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import 包名.类名;</span></span><br><span class="line"><span class="keyword">import</span> com.hopu.domain.Stuent;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><p>一个类中使用其他包下的类时（<strong>特殊包java.lang除外</strong>），就需要使用import关键字引入对应的类（包名+类名形式）；</p>
</li>
<li><p>同包下的类使用时无需使用import引入，直接使用即可；</p>
</li>
<li><p>在使用java.lang包下的所有类时，无需使用import引入。java.lang包是Java的基础核心包，Java在编译期间会自动引入该包；</p>
</li>
<li><p><strong>import导包语句必须放在package语句与class类之间；</strong></p>
</li>
<li><p>如果某个类下重复导入其他同一个包下的多个类，可以使用通配符“*”引入该包下的所有类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4.代码块"></a>4.代码块</h2><h3 id="4-1常见分类："><a href="#4-1常见分类：" class="headerlink" title="4.1常见分类："></a>4.1常见分类：</h3><ul>
<li><p><strong>局部代码块</strong></p>
<p>基本概念：局部位置，用于限定变量的生命周期，提高内存利用率</p>
</li>
<li><p><strong>静态代码块</strong></p>
<p>基本概念：类方法外，采用static修饰，用于对类进行初始化操作</p>
<p><strong>特点：</strong></p>
<ul>
<li>static代码块随着类的加载而加载，并且<strong>只初始化执行一次；</strong></li>
<li>静态初始化块中<strong>不能直接访问非static成员</strong>；</li>
<li>静态初始化块可以置于类中的任何地方，类中可以有多个静态初始化块，多个静态代码块会按照书写顺序加载。</li>
</ul>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123; 初始化语句 &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>构造代码块</strong></p>
<p>基本概念：类中方法外(成员位置)，用”{}”括起来的java程序代码，调用构造方法前，都会执行构造方法前都会执行</p>
<p><strong>特点：</strong>每次创建对象，调用构造方法前都会执行</p>
</li>
<li><p>同步代码块，在多线程使用</p>
</li>
</ul>
<h3 id="4-2示例："><a href="#4-2示例：" class="headerlink" title="4.2示例："></a>4.2示例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeBlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态代码块：类中方法外，加static修饰，用于给类进行初始化</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//构造代码块：类中方法外，用&#123;&#125;括起，每次调用构造方法前执行，用于给对象进行初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeBlockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CodeBlock t2 = <span class="keyword">new</span> CodeBlock();</span><br><span class="line">        CodeBlock t3 = <span class="keyword">new</span> CodeBlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%9F%BA%E7%A1%80/image-20200618094608601.jpg"></p>
<p><strong>总结：</strong></p>
<p>执行顺序是<strong>：静态代码块-&gt;构造代码块-&gt;构造方法</strong>。特点：静态代码块只执行一次，构造代码块在每次调用构造方法之前都会执行！</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之总结</title>
    <url>/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="面向对象之总结"><a href="#面向对象之总结" class="headerlink" title="面向对象之总结"></a>面向对象之总结</h1><h2 id="1-什么是对象，什么是类，类与对象的关系"><a href="#1-什么是对象，什么是类，类与对象的关系" class="headerlink" title="1. 什么是对象，什么是类，类与对象的关系"></a>1. 什么是对象，什么是类，类与对象的关系</h2><p>   类是一类事物抽象的集合</p>
<p>   对象是一类事物具体的体现</p>
<p>   类与对象的关系：类是对象的模板，对象时类的实体</p>
<h2 id="2-成员变量与局部变量的区别"><a href="#2-成员变量与局部变量的区别" class="headerlink" title="2. 成员变量与局部变量的区别"></a>2. 成员变量与局部变量的区别</h2><ul>
<li>在类的位置不同<ul>
<li><p>成员变量：类中，方法外</p>
</li>
<li><p>局部变量：方法中    - 作用范围不同</p>
</li>
<li><p>成员变量：类中</p>
</li>
<li><p>局部变量：方法中    - 默认初始值不同</p>
</li>
<li><p>成员变量: 有默认值</p>
</li>
<li><p>局部变量：没有初始值。必须先定义，赋值后使用    - 生命周期不同</p>
</li>
<li><p>成员变量：伴随着对象的创建而存在，随着对象的消失而消失</p>
</li>
<li><p>局部变量：随着方法的调用而存在，随着方法的消失而消失</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-什么是方法，方法的作业是什么，有啥注意事项？"><a href="#3-什么是方法，方法的作业是什么，有啥注意事项？" class="headerlink" title="3 .  什么是方法，方法的作业是什么，有啥注意事项？"></a>3 .  什么是方法，方法的作业是什么，有啥注意事项？</h2><p>   <strong>方法：</strong>就是将具有独立功能的代码块组织成一个整体，使具有特有功能的代码</p>
<p>   <strong>作用：</strong>提高代码的复用性，解决代码的冗余性，同时还封装了一个类应有的行为</p>
<p><strong>注意事项：</strong></p>
<ul>
<li><p>方法不能嵌套定义</p>
</li>
<li><p>返回值类型，必须和return语句返回值的类型相同<strong>或者比返回值类型范围小</strong></p>
</li>
<li><p>不能再return后面写代码，在其后写的代码不能实现</p>
</li>
<li><p>void 表示无返回值，可以省略return</p>
</li>
</ul>
<h2 id="4-方法参数传递注意事项"><a href="#4-方法参数传递注意事项" class="headerlink" title="4. 方法参数传递注意事项"></a>4. 方法参数传递注意事项</h2><p>形参：定义方法时，参数列表中的变量，成为形式参数</p>
<p>实参：调用方法时，传入给方法的数值，我们称为实际参数</p>
<ul>
<li>基本数据类型作为形参时，那么形式参数的变化不会影响到实际参数</li>
<li>引用数据类型作为型参时，那么形式参数的变化会影响到实际实际参数，因为形式参数的值为应用数据类型实体化的地址，修改其中的值，实质上是修改地址内存里面的值</li>
</ul>
<h2 id="5-方法重载"><a href="#5-方法重载" class="headerlink" title="5.方法重载"></a>5.方法重载</h2><p>方法重载：指在同一个类中，允许存在一个或多个以上的同名方法<strong>，只要它们的参数列表不同即可，与修饰符和返回值类型不同</strong></p>
<h2 id="6-可变参数"><a href="#6-可变参数" class="headerlink" title="6. 可变参数"></a>6. 可变参数</h2><p>目的：用于解决实际情况中类型相同，个数不确定</p>
<p>注意事项：</p>
<ul>
<li>定义可变参数方法时，允许加入其它类型的固定参数列表，且<strong>可变参数必须放在最后</strong></li>
<li>在方法中定义可变参数后，我们可以像操作数组一样操作该参数</li>
</ul>
<h2 id="7-构造方法"><a href="#7-构造方法" class="headerlink" title="7. 构造方法"></a>7. 构造方法</h2><p><strong>定义：</strong>就是类构造对象时调用的方法，主要用于实例化对象。</p>
<p><strong>作用：</strong></p>
<ul>
<li>构造出来一个类的实例</li>
<li>对构造出来个一个一个类的实例(对象)初始化</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>构造方法的名字必须与定义他的类名完全相同，没有返回类型，甚至连void都没有</li>
<li><strong>类中必有构造方法</strong>，若不写，系统会自动提供一个无参构造方法；而一旦提供有参构造方法，就不再提供默认的无参构造方法</li>
<li>构造方法存在重载</li>
</ul>
<h2 id="8-封装"><a href="#8-封装" class="headerlink" title="8 封装"></a>8 封装</h2><p>封装是一种将抽象性函式接口的细节部分包装，隐藏起来的一种方法</p>
<p><strong>原则:</strong></p>
<p>将内部细节隐藏起来，若雪要访问某个成员，提供公共方法对齐访问或者是只允许内部访问</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>良好的封装能够隐藏耦合</p>
</li>
<li><p>类内部可以自由修改</p>
</li>
<li><p>可以对类成员进行更细节精准的控制</p>
</li>
<li><p>隐藏信息，实现细节</p>
</li>
</ul>
<p><strong>封装基本使用：</strong></p>
<ul>
<li><p>使用private关键字来修饰类的成员以及类</p>
</li>
<li><p>对需要访问的成员变量，提供对应一对public的get和set方法</p>
</li>
<li><p>private修饰的成员方法，只允许本类中的其他方法调用</p>
</li>
<li><p>private修饰的类，只能作为内部类使用</p>
</li>
</ul>
<h2 id="9-访问权限修饰符的访问权限"><a href="#9-访问权限修饰符的访问权限" class="headerlink" title="9. 访问权限修饰符的访问权限"></a>9. 访问权限修饰符的访问权限</h2><p><img src="/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%80%BB%E7%BB%93/image-20200618140830256.jpg"></p>
<h2 id="10-继承"><a href="#10-继承" class="headerlink" title="10. 继承"></a>10. 继承</h2><p>含义：继承就是子类继承父类的特征和行为</p>
<p>继承的特点：</p>
<ul>
<li><p>成员变量</p>
<ul>
<li>如果子类父类中出现不重名的成员变量，这时的访问是没有影响的</li>
<li>如果子类中出现重名的成员变量，这时访问是有影响的</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li>子类父类中出现不重名的成员方法，这时调用是没有影响的</li>
<li>子类父类中出现重名的成员方法，这时的访问是一种特殊情况<ul>
<li>如果子类出现与父类重名的方法，但是方法参数不同，这种情况属于方法重载</li>
<li>如果子类出现与父类重名方法，同时方法参数也相同，这种情况叫做方法重写</li>
</ul>
</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法</li>
<li>子类中的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认只有一个super(),表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用</li>
</ul>
</li>
</ul>
<h2 id="11-方法重写"><a href="#11-方法重写" class="headerlink" title="11. 方法重写"></a>11. 方法重写</h2><p>方法重名：子类中出现与父类一模一样的方法时(<strong>方法名和参数列表都相同，重写的返回值类型相同或者是父类方法的子类</strong>)，会出现覆盖效果，也称为重写或者复写</p>
<p>特点：</p>
<ul>
<li>子类方法覆盖父类方法，必须保证权限大于等于父类权限</li>
<li>子类方法覆盖父类方法，方法名和参数列表都要一模一样</li>
<li>子类方法覆盖父类方法，<strong>返回值类型可以与父类保存一致，或者返回父类返回值的子类</strong></li>
<li>私有方法不能被继承，而是无法访问，所以不能重写。</li>
</ul>
<h2 id="12-final关键字"><a href="#12-final关键字" class="headerlink" title="12 final关键字"></a>12 final关键字</h2><ul>
<li><p>final修饰类，表示最终类，也就是此类不能被继承</p>
</li>
<li><p>final修饰变量：表示常量，也就是一个变量的值始终如一，无法变更</p>
</li>
<li><p>final修饰方法：表示最终方法，也就是此方法不能被重写</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>被 final修饰的成员变量，必须先进行初始化赋值，且值不能变更，否则编译出错</li>
<li>被final修饰的成员变量，通常会结合final和static关键字一起使用，表示一个全局的静态常量，常量名用大写</li>
<li><strong>被final修饰的局部变量，不能被static修饰</strong>，同时可以不用先初始化赋值，使用时先进行一次赋值即可，后续也不能变更</li>
<li>final修饰的基本数据类型，初始化便不能发生变化</li>
<li>final修饰引用数据类型，则在对其初始化以后便不能再改变引用地址了，但改引用地址中的内容可以发生改变</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之类与对象</title>
    <url>/2021/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象之类与对象"><a href="#面向对象之类与对象" class="headerlink" title="面向对象之类与对象"></a>面向对象之类与对象</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>理解面向对象</li>
<li>掌握类与对象的定义和使用</li>
<li>掌握成员变量和局部变量的区别</li>
</ol>
<h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1.面向对象"></a>1.面向对象</h2><h3 id="1-1面向对象思想介绍"><a href="#1-1面向对象思想介绍" class="headerlink" title="1.1面向对象思想介绍"></a>1.1面向对象思想介绍</h3><p>java语言是一种面向对象程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用java语言去设计，开发计算机程序</p>
<p>这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是讲现实世界中的事物的属性特征，行为特征抽象出来，描述成计算机事件的设计思想</p>
<h3 id="1-2面向对象和面向过程的区别"><a href="#1-2面向对象和面向过程的区别" class="headerlink" title="1.2面向对象和面向过程的区别"></a>1.2面向对象和面向过程的区别</h3><h4 id="1-2-1-什么是面向过程"><a href="#1-2-1-什么是面向过程" class="headerlink" title="1.2.1 什么是面向过程"></a>1.2.1 什么是面向过程</h4><p>在我们去实现某项功能的时候，我们会不自觉的按部就班的罗列出我们要去做的事情，在一步一步的实现出来，这种按照我们罗列的步骤去实现某项功能的过程其实就是面向过程。</p>
<p>总结起来就是：<strong>自顶向下，逐步向下</strong>：</p>
<p>实现步骤：</p>
<ol>
<li><p>将要实现的功能描述为一个开始到结束按部就班的连续的步骤</p>
</li>
<li><p>将这一系列步骤中比较复杂的事情在继续继续细分为若干个子步骤 。以此内推，直到得到想用的结果</p>
</li>
<li><p>程序的主体是函数，一个函数就是一个封装好的功能，可以实现一定的功能，各个步骤有各个函数来完成。从而实现代码的重用和模块化编程</p>
</li>
</ol>
<h4 id="1-2-2什么是面向对象"><a href="#1-2-2什么是面向对象" class="headerlink" title="1.2.2什么是面向对象"></a>1.2.2什么是面向对象</h4><p>所谓面向对象，就是在编程的时候尽可能的去模拟现实世界，按照现实世界的逻辑去处理一个问题，分析现实世界中的逻辑去处理一个问题，分析问题中的逻辑去处理一个问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何去调用这些实体的属性和方法去解决问题。</p>
<p>现实世界中，任何一个操作或者是业务逻辑的实现都需要一个实体来完成，也就是说，实体就是动作的支配者，没有实体，就肯定没有动作发生</p>
<p>当使用面向对象的思想去解决问题时，可分为以下几步</p>
<ol>
<li><p>分析哪些动作是由哪些实体发出的</p>
</li>
<li><p>定义这些实体，为其增加相应的属性和功能</p>
</li>
<li><p>让实体去执行相应的功能或动作</p>
</li>
</ol>
<h4 id="1-2-3举例说明"><a href="#1-2-3举例说明" class="headerlink" title="1.2.3举例说明"></a>1.2.3举例说明</h4><p>洗衣服</p>
<ul>
<li><p>面向过程：把衣服脱下来–&gt;找一个盆 –&gt; 放点洗衣粉 –&gt;加点水 –&gt;浸泡10分钟 –&gt;揉一揉 –&gt;洗衣服 –&gt; 拧干 –&gt;晾起来</p>
</li>
<li><p>面向对象： 把衣服脱下来 –&gt; 打开全自动洗衣机 –&gt;扔衣服 –&gt;按钮–&gt; 晾起来</p>
</li>
</ul>
<p>区别：</p>
<ul>
<li><p>面向过程：强调步骤</p>
</li>
<li><p>面向过程：强调对象，这里的对象就是洗衣机</p>
</li>
</ul>
<h4 id="1-3-4总结"><a href="#1-3-4总结" class="headerlink" title="1.3.4总结"></a>1.3.4总结</h4><ol>
<li><p>面向过程：当要实现一个功能时，需要亲力亲为，处理每个细节</p>
</li>
<li><p>面向过程：当要实现一个功能时，不关心具体的实现步骤，只关心结果，找一个具有该功能的类，帮我呢吧做事</p>
</li>
<li><p>面向对象的思想</p>
<ol>
<li>面向对象是基于面向过程的编程思想</li>
<li>面向过程：强调的是每一个功能的步骤</li>
<li>面向对象：强调的是对象，然后由对象去调用功能</li>
</ol>
</li>
<li><p>面向对象和面向过程都能实现模块化编程，但是面向对象的模块化更深，数据更封闭，也更安全</p>
</li>
<li><p>特点：</p>
<p>面向对象思维是一种更符合我们思考习惯的思想，他可以将复杂的事情简单化，并将我们从执行者变成指挥者。面向对象的语言，包含了三大基本特征：封装，继承，多态</p>
</li>
</ol>
<h3 id="1-3类和对象的引入"><a href="#1-3类和对象的引入" class="headerlink" title="1.3类和对象的引入"></a>1.3类和对象的引入</h3><h4 id="1-3-1什么是类"><a href="#1-3-1什么是类" class="headerlink" title="1.3.1什么是类"></a>1.3.1什么是类</h4><ul>
<li><strong>类：</strong> 是一组具有类似属性和行为的集合。可以看成是一类事物得模板，使用事物得属性特征和行为特征来描述该类事物</li>
<li><strong>属性：</strong> 就是该事物得状态信息</li>
<li><strong>行为：</strong> 就是该事物能够做什么 </li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">举例: 人类</span><br><span class="line">属性：名字，年龄，性别，身高等等。</span><br><span class="line">行为：吃饭，睡觉，工作等等。</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2什么是对象"><a href="#1-3-2什么是对象" class="headerlink" title="1.3.2什么是对象"></a>1.3.2什么是对象</h4><ul>
<li>对象：是一类事物得具体体现。对象是类的一个实例。必然具备该事物的属性和行为。</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">属性：张三丰,<span class="number">120</span>，男，<span class="number">175</span></span><br><span class="line">行为：吃饭，睡觉，练武。</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3类与对象的关系"><a href="#1-3-3类与对象的关系" class="headerlink" title="1.3.3类与对象的关系"></a>1.3.3类与对象的关系</h4><ul>
<li>类是对一类事物得描述，是抽象的</li>
<li>对象是一类事物得实例，是具体的</li>
<li>类是对象的模板，对象是类的实体</li>
</ul>
<p>下图中<strong>男孩（boy）</strong>、<strong>女孩（girl）</strong>为<strong>类（class）</strong>，而具体的每个人为该类的<strong>对象（object）：</strong></p>
<p><img src="/2021/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20200611144138237.jpg"></p>
<h2 id="2-类与对象"><a href="#2-类与对象" class="headerlink" title="2.类与对象"></a>2.类与对象</h2><p>在java语言中，参与现实世界的类与对象并以面向面向对象的思维进行了语言设计，把一些事物按照类的划分，在以对象的形式进行管理</p>
<h3 id="2-1类的定义"><a href="#2-1类的定义" class="headerlink" title="2.1类的定义"></a>2.1类的定义</h3><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">访问权限修饰符 class 类名&#123;</span><br><span class="line">    //成员变量  属性特征</span><br><span class="line">    //成员方法  行为特征</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><strong>定义类：</strong>就是对业务或者现实中某一实实在在的分类物以java语言中的类进行定义并分类管理，参考现实类有属性和行为两个关键特征，所以java中的类也包括属性和行为</li>
<li><strong>访问权限修饰符：</strong>就是java中控制当前类是否可见，被谁可见的关键字，包括有public，protected,default,private。通常类的权限修饰符都为public</li>
<li><strong>class：</strong> 定义java类的关键字</li>
<li><strong>类名：</strong> 就是我们要创建具体的什么类，给取个见名知意的名字</li>
<li><strong>成员变量：</strong> 和以前定义变量几乎是一样的(可以类比现实对象的属性)。<strong>位置发生了改变。在类中，方法外</strong></li>
<li><strong>成员方法：</strong>可以描述该类的所有对象可以有什么行为，以及怎么行动</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 成员变量</span></span><br><span class="line">  	String username;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="comment">//学习的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;好好学习，天天向上&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跑步的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String username,<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">       System.out.println(username+<span class="string">&quot; 今天跑了&quot;</span>+distance+<span class="string">&quot;m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2对象的创建"><a href="#2-2对象的创建" class="headerlink" title="2.2对象的创建"></a>2.2对象的创建</h3><p>java类有了，但还只是一个抽象的概念的东西，如果要使用，必须创造一个个具体的对象。</p>
<p>语法</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">类名 对象名 =new 类名()</span><br></pre></td></tr></table></figure>

<p>使用对象访问类中的成员：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">对象名.成员变量</span><br><span class="line">对象名.成员方法</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象格式：类名 对象名 = new 类名();</span></span><br><span class="line">    Student s = <span class="keyword">new</span> Student();</span><br><span class="line">    System.out.println(s); <span class="comment">//com.hopu.classobject.Student@15db9742</span></span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>成员变量有默认的初始值</strong></p>
<p>对象创建后，<strong>成员变量有默认的初始值</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td>整数（byte，short，int，long）</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>浮点数（float，double）</td>
<td>0.0</td>
</tr>
<tr>
<td></td>
<td>字符（char）</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td></td>
<td>布尔（boolean）</td>
<td>false</td>
</tr>
<tr>
<td>引用类型</td>
<td>数组，类，接口</td>
<td>null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// 创建对象格式：类名 对象名 = new 类名();</span></span><br><span class="line">	    Student s = <span class="keyword">new</span> Student();</span><br><span class="line">	    System.out.println(s); <span class="comment">//com.hopu.classobject.Student@15db9742</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 直接输出成员变量值</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;姓名：&quot;</span>+s.username); <span class="comment">//null</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;年龄：&quot;</span>+s.age); <span class="comment">//0</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//给成员变量赋值</span></span><br><span class="line">	    s.username = <span class="string">&quot;佐佐木希&quot;</span>;</span><br><span class="line">	    s.age = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 再次输出成员变量的值</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;姓名：&quot;</span>+s.username); <span class="comment">//佐佐木希</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;年龄：&quot;</span>+s.age); <span class="comment">//32</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 调用成员方法</span></span><br><span class="line">	    s.study(); <span class="comment">// &quot;好好学习，天天向上&quot;</span></span><br><span class="line">	    s.run(<span class="string">&quot;tom&quot;</span>,<span class="number">123</span>); <span class="comment">// 跑步</span></span><br><span class="line">	  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3对象内存分析"><a href="#2-3对象内存分析" class="headerlink" title="2.3对象内存分析"></a>2.3对象内存分析</h3><h4 id="2-3-1一个对象内存图："><a href="#2-3-1一个对象内存图：" class="headerlink" title="2.3.1一个对象内存图："></a>2.3.1一个对象内存图：</h4><p><img src="/2021/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210720101908076.jpg"></p>
<p>说明：</p>
<ul>
<li><p>初始化，方法区里面有phone.class方法中的call 方法 ，main()方法在方法区中</p>
</li>
<li><p>执行main方法，将main方法压入栈中</p>
</li>
<li><p>new phone()  ,对象实体化，new phone() 进入堆中，栈中的Phone one存储 对象实体化的地址，同时new Phone中的成员变量有初始值，初始方法的值是方法在堆中的地址</p>
</li>
<li><p>给属性赋值后，输出</p>
</li>
<li><p>在依次出栈</p>
</li>
</ul>
<h4 id="2-3-2两个对象内存图"><a href="#2-3-2两个对象内存图" class="headerlink" title="2.3.2两个对象内存图"></a>2.3.2两个对象内存图</h4><p><img src="/2021/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210720104040717.jpg"></p>
<p><strong>说明：</strong></p>
<p>Phone one 存储的是Phone对象实体化在堆中的地址</p>
<p>Phone 对象再次被实体化时，会在堆里面再次创建一个对象，two的值为这个对象的地址</p>
<h4 id="2-3-3-两个对象指向相同的内存"><a href="#2-3-3-两个对象指向相同的内存" class="headerlink" title="2.3.3  两个对象指向相同的内存"></a>2.3.3  两个对象指向相同的内存</h4><p><img src="/2021/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210720112301880.jpg"></p>
<p>说明：Phone two =one;    把one值(new Phone()的地址)赋值给two中，两个对象同时指向同一个堆内存的地址，所以改变two对象中的属性值会影响one对象的属性值。</p>
<h3 id="2-4成员变量与局部变量"><a href="#2-4成员变量与局部变量" class="headerlink" title="2.4成员变量与局部变量"></a>2.4成员变量与局部变量</h3><p>java中变量根据定义位置的不同，我们给变量起了不同的名字</p>
<p><img src="/2021/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20200611154936663.jpg"></p>
<p><strong>说明</strong></p>
<ul>
<li><p>在类的位置不同 <!--重点--></p>
<ul>
<li>成员变量：类中，方法外</li>
<li>局部变量：方法中或者方法声明上(形式参数)</li>
</ul>
</li>
<li><p>作用范围不一样  <!--重点--></p>
<ul>
<li><p>成员变量：类中</p>
</li>
<li><p>局部变量：方法中</p>
</li>
</ul>
</li>
<li><p>初始化值不同 <!--重点--></p>
<ul>
<li>成员变量：有默认值</li>
<li>局部变量：没有默认值。必须先定义，赋值，最后使用</li>
</ul>
</li>
<li><p>在内存中的位置不同</p>
<ul>
<li>成员变量：堆内存</li>
<li>局部变量：栈内存</li>
</ul>
</li>
<li><p>生命周期不同</p>
<ul>
<li>成员变量 随着对象的创建而存在，随着对象的消失而消失</li>
<li>随着方法的调用而存在，随着方法的调用完毕而消失</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>常用类1</title>
    <url>/2021/07/27/%E5%B8%B8%E7%94%A8%E7%B1%BB1/</url>
    <content><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、掌握Object类的相关用法</span><br><span class="line">2、掌握==跟equals的区别</span><br><span class="line">3、掌握Math类的常用方法</span><br><span class="line">3、掌握Random类的基本方法 </span><br><span class="line">4、掌握日期类和字符串类的转换方式</span><br><span class="line">5、掌握日期和日历类的转换方式</span><br></pre></td></tr></table></figure>



<h1 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1  Object类"></a>1  Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>​    <code>java.lang.Object</code>在Java中是万类之祖，即所有类的父类。Java中的继承是单继承的，如果一个类没有定义任何父类则这个类默认继承<code>java.lang.Object</code>，故其中定义的方法可以被任意引用类型使用，前提是拥有足够的权限。</p>
<p>​    根据JDK的API文档，我们可以发现Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p>
<ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
<li><code>public boolean equals(Object obj)</code> ：指示其他某个对象是否与此对象“相等”。</li>
<li><code>protected native Object clone()</code> ： 创建并返回此对象的一个副本。</li>
<li><code>protected void finalize()</code>： 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</li>
</ul>
<h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><p>​    当我们在直接输出打印一个引用类型的对象时发现输出结果为”类型+@+内存地址值”。这个结果其实就是调用了这个对象的toString方法的结果。我们可以通过Object的toString源码得到验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    由于toString方法返回的结果是内存地址，而在实际开发中，我们更多的是需要显示对象的属性特征，故我们一般都会重写这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项来快速生成这个方法的重写。</p>
<h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><pre><code>     `equals`方法指示其他某个对象是否与此对象“相等”。这个“相等”用上引号是以为它并不是数学意义上的相等，而是业务逻辑中的逻辑意义上的&quot;相等&quot;，其判断的结果应该由我们业务逻辑来确定。
</code></pre>
<p>​        但Ojbect类并不知道其子类需要定义什么业务逻辑，故在Object中的默认实现逻辑就是判断是否是同一个对象，等效于<code>==</code>，一般我们会根据业务逻辑来重写。</p>
<p>​        由于我们经常需要重写这个方法，我们可以通过<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>equals()</code>选项来快速生成这个方法的重写。</p>
<p>​        假设我们定义人的姓名相同的2个Person对象就相等，否则就不相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        如果要比较的2个对象是同一个对象，则直接返回true</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//        如果要比较的2个对象的类型不一致，则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        将要比较的对象转成当前类型，并比较姓名是否相同</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> name.equals(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>hashcode</code>方法通常需要跟<code>equals</code>方法一起重写，作用跟用法我们今后学习。</p>
<h2 id="1-4-clone方法"><a href="#1-4-clone方法" class="headerlink" title="1.4 clone方法"></a>1.4 clone方法</h2><p>​        此方法创建并返回当前对象的一个副本。clone的对象跟母体拥有相同的属性值，是另一种创建对象的方式。Object中的此方法是<code>protected</code>，故我们需要在子类中重写，将访问权限提升至<code>public</code>。</p>
<p>​        所有想使用clone方法的类都需要实现标识接口<code>java.lang.Cloneable</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要实现Cloneable接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter and getter</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问权限提升为public，逻辑使用父类的逻辑即可。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-finalize方法"><a href="#1-5-finalize方法" class="headerlink" title="1.5 finalize方法"></a>1.5 finalize方法</h2><p>​        <code>finalize</code>方法是一个回调方法，不是我们主动调用，是由虚拟机在回收对象时会自动调用这个方法逻辑。如果我们需要在回收前做一些比如释放资源等操作，则可以重写此方法。</p>
<p>​        我们一般不需要重写此方法，只需了解其调用的时机，会出现在面试题中。</p>
<h1 id="2-Math类"><a href="#2-Math类" class="headerlink" title="2 Math类"></a>2 Math类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>​    <code>Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 <code>math</code>中的所有方法都为<code>static</code>类型的，故我们只需通过<code>Math</code>类来使用这些方法，而不需要先创建对象。</p>
<p>​    此类大部分方法都属于数学领域的，我们一般只需用到其中比较常用的方法：</p>
<ul>
<li><p><code>static double PI</code> ： 比任何其他值都更接近 <em>pi</em>（即圆的周长与直径之比）的 <code>double</code> 值。</p>
</li>
<li><p><code>static double abs(double a)</code>：返回 <code>double</code> 值的绝对值。</p>
</li>
<li><p><code>static float abs(float a)</code>：返回 <code>double</code> 值的绝对值。</p>
</li>
<li><p><code>static int abs(int a)</code>：返回 <code>double</code> 值的绝对值。</p>
</li>
<li><p><code>static long abs(long a)</code>：返回 <code>double</code> 值的绝对值。</p>
</li>
<li><p><code>static double ceil(double a)</code>： 返回最小的（最接近负无穷大）<code>double</code> 值，该值大于等于参数，并等于某个整数。</p>
</li>
<li><p><code>static double floor(double a)</code>： 返回最大的（最接近正无穷大）<code>double</code> 值，该值小于等于参数，并等于某个整数。</p>
</li>
<li><p><code>static long round(double a)</code>： 返回最接近参数的 <code>long</code>。</p>
</li>
<li><p><code>static int round(float a)</code>： 返回最接近参数的 <code>int</code>。</p>
</li>
<li><p><code>static long pow(double a, double b)</code>： 返回第一个参数的第二个参数次幂的值。</p>
</li>
<li><p><code>static double random()</code>： 返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。</p>
</li>
</ul>
<h2 id="2-2-API"><a href="#2-2-API" class="headerlink" title="2.2 API"></a>2.2 API</h2><p>​    <code>Math</code> 类中的方法都比较简单，我们一起看下其使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Math.PI);<span class="comment">//3.141592653589793</span></span><br><span class="line">     System.out.println(Math.abs(-<span class="number">3.5</span>));<span class="comment">//3.5</span></span><br><span class="line">     System.out.println(Math.ceil(-<span class="number">3.5</span>));<span class="comment">//-3.0</span></span><br><span class="line">     System.out.println(Math.floor(<span class="number">3.5</span>));<span class="comment">//3.0</span></span><br><span class="line">     System.out.println(Math.round(<span class="number">3.5</span>));<span class="comment">//4</span></span><br><span class="line">     System.out.println(Math.round(-<span class="number">3.5</span>));<span class="comment">//-3</span></span><br><span class="line">     System.out.println(Math.pow(<span class="number">3</span>,<span class="number">4</span>));<span class="comment">//81.0</span></span><br><span class="line">     System.out.println(Math.random());<span class="comment">// [0.0-1.0)之间的随机值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-Random类"><a href="#3-Random类" class="headerlink" title="3 Random类"></a>3 Random类</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>​        当我们在完成类似小游戏之类的程序时经常需要用到随机数的知识，我们可以使用Random类来实现。Random类的实例用于生成伪随机数流。由于实例是通过算法算出来的，并不是真正意义上的随机，故称为伪随机。而算法依赖一个随机种子。</p>
<p>​        如果有2个随机种子相同的Random实例，其每次随机出来的数字都相同。</p>
<p>构造器：</p>
<ul>
<li><code>public Random()</code>：创建一个新的随机数生成器。</li>
<li><code>public Random(long seed)</code>：使用单个 long 种子创建一个新的随机数生成器。</li>
</ul>
<p>成员方法：</p>
<ul>
<li><code>public double nextDouble()</code>： 返回下一个伪随机数，它是取自此随机数生成器序列的、在 <code>0.0</code> 和 <code>1.0</code> 之间均匀分布的  <code>double</code> 值。</li>
<li><code>public float nextFloat()</code>： 返回下一个伪随机数，它是取自此随机数生成器序列的、在 <code>0.0</code> 和 <code>1.0</code> 之间均匀分布的  <code>float</code> 值。</li>
<li><code>public int nextInt()</code>： 返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 <code>int</code> 值。</li>
<li><code>public int nextInt(int n)</code>： 返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 <code>int</code> 值。</li>
<li><code>public long nextLong()</code>： 返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 <code>long</code> 值。</li>
</ul>
<h2 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h2><p>​    <code>Random</code> 类中的方法都比较简单，我们一起看下其使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        创建一个随机对象</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random() ;</span><br><span class="line"><span class="comment">//        生成一个随机的int整数</span></span><br><span class="line">        System.out.println(random.nextInt());</span><br><span class="line"><span class="comment">//        随机生成一个[0,10)范围内的随机数</span></span><br><span class="line">        System.out.println(random.nextInt(<span class="number">10</span>));</span><br><span class="line"><span class="comment">//        随机生成一个float类型的值</span></span><br><span class="line">        System.out.println(random.nextFloat());</span><br><span class="line"><span class="comment">//        随机生成一个double类型的值</span></span><br><span class="line">        System.out.println(random.nextDouble());</span><br><span class="line"><span class="comment">//        随机生成一个long类型的值</span></span><br><span class="line">        System.out.println(random.nextLong());</span><br><span class="line"><span class="comment">//        随机生成一个boolean类型的值</span></span><br><span class="line">        System.out.println(random.nextBoolean());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-日期时间类"><a href="#4-日期时间类" class="headerlink" title="4 日期时间类"></a>4 日期时间类</h1><h2 id="4-1-Date类"><a href="#4-1-Date类" class="headerlink" title="4.1 Date类"></a>4.1 Date类</h2><h3 id="4-1-1-概述"><a href="#4-1-1-概述" class="headerlink" title="4.1.1 概述"></a>4.1.1 概述</h3><p>​    项目中经常需要使用到日期跟时间的表示，JDK为我们提供了Date类来满足项目中的需要。虽然Date类中的很多方法都已经过时，但由于使用简单方便，我们仍然经常使用。</p>
<p>​    <code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p>
<p>常用构造器：</p>
<ul>
<li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。`</li>
<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li>
</ul>
<p>常用方法：</p>
<ul>
<li><p> <code>public void setTime(long time)</code>：设置此 Date 对象，以表示 1970 年 1 月 1 日 00:00:00 GMT 以后 time 毫秒的时间点。</p>
</li>
<li><p> <code>public long getTime()</code>：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 </p>
</li>
</ul>
<h3 id="4-1-2-API"><a href="#4-1-2-API" class="headerlink" title="4.1.2 API"></a>4.1.2 API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//      创建当前时间对应的Date对象</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//      使用Date中重写的toString的格式显示日期</span></span><br><span class="line">        System.out.println(date); <span class="comment">// Mon Dec 28 14:29:39 CST 2020</span></span><br><span class="line"><span class="comment">//      自从标准基准时间之间的毫秒数</span></span><br><span class="line">        System.out.println(date.getTime());<span class="comment">//  1609137137133</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">//		创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">0</span>);</span><br><span class="line">        System.out.println(date2); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>tips: 由于我们处于东8区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
<h2 id="4-2-SimpleDateFormat类"><a href="#4-2-SimpleDateFormat类" class="headerlink" title="4.2 SimpleDateFormat类"></a>4.2 SimpleDateFormat类</h2><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><p>​    <code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。这里DateFormat是抽象类，故实际中我们使用它的子类<code>java.text.SimpleDateFormat</code>。</p>
<p>​    实际开发中我们经常使用的时间是字符串形式，故需要经常将时间在字符串跟Date类型之间转换，把字符串形式的时间转成Date类型称为<strong>解析</strong>，把Date类型转为字符串类型成为<strong>格式化</strong>。</p>
<p><strong>常用构造器：</strong></p>
<ul>
<li><p>​    <code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</p>
<p>​    参数pattern是一个字符串，代表日期时间的自定义格式。</p>
</li>
</ul>
<p><strong>格式规则:</strong></p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<p>tips ：更详细的格式规则，可以参考SimpleDateFormat类的API文档。</p>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>
<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li>
</ul>
<h3 id="4-2-2-API"><a href="#4-2-2-API" class="headerlink" title="4.2.2 API"></a>4.2.2 API</h3><ul>
<li>将Date对象转换成自定义的格式输出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line"><span class="comment">//	定义当前时间点对应的Date对象    </span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();    </span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>) ;</span><br><span class="line">  <span class="comment">//将日期Date格式化输出</span></span><br><span class="line">    String dateString = format.format(date);</span><br><span class="line">    System.out.println(dateString);<span class="comment">//2020-12-28 14:57:18</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>将字符串格式的日期转成Date类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;     </span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>) ;</span><br><span class="line">    <span class="comment">//字符串类型的日期</span></span><br><span class="line">    String d = <span class="string">&quot;20-12-28 14:55:05&quot;</span>;</span><br><span class="line">    <span class="comment">// 字符串类型的日期转成Date对象</span></span><br><span class="line">    Date date = format.parse(d);</span><br><span class="line">    System.out.println(date);<span class="comment">//Sat Dec 28 14:55:05 CST 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-Calendar类"><a href="#4-3-Calendar类" class="headerlink" title="4.3 Calendar类"></a>4.3 Calendar类</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><p> 上面讲解的Date类的大多数方法已经过时，JDK为我们推荐使用的Calendar类，此类表示日历。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>
<h3 id="4-3-2-Calendar的获取"><a href="#4-3-2-Calendar的获取" class="headerlink" title="4.3.2  Calendar的获取"></a>4.3.2  Calendar的获取</h3><p>​    由于Calendar类是一个抽象类，不能直接通过new来获取对象。我们需要通过其静态方法<code>getInstance</code>来获取其对象类。</p>
<ul>
<li><p><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-3-3-API"><a href="#4-3-3-API" class="headerlink" title="4.3.3 API"></a>4.3.3 API</h3><ul>
<li><p><code>public int get(int field)</code>：返回给定日历字段的值。</p>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        创建当前时间对应的日历类</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line"><span class="comment">//        获取日历类中的年份</span></span><br><span class="line">        System.out.println(cal.get(Calendar.YEAR));<span class="comment">//2020</span></span><br><span class="line"><span class="comment">//        获取日历类中的月份</span></span><br><span class="line">        System.out.println(cal.get(Calendar.MONTH));<span class="comment">//11</span></span><br><span class="line"><span class="comment">//        获取日历类中的几号</span></span><br><span class="line">        System.out.println(cal.get(Calendar.DAY_OF_MONTH));<span class="comment">//28</span></span><br><span class="line"><span class="comment">//        获取日历类中的小时，12小时制</span></span><br><span class="line">        System.out.println(cal.get(Calendar.HOUR));<span class="comment">//3</span></span><br><span class="line"><span class="comment">//        获取日历类中的小时，24小时制</span></span><br><span class="line">        System.out.println(cal.get(Calendar.HOUR_OF_DAY));<span class="comment">// 15</span></span><br><span class="line"> <span class="comment">//         获取日历类中的分</span></span><br><span class="line">        System.out.println(cal.get(Calendar.MINUTE));<span class="comment">//31</span></span><br><span class="line"> <span class="comment">//         获取日历类中的秒</span></span><br><span class="line">        System.out.println(cal.get(Calendar.SECOND));<span class="comment">// 36</span></span><br><span class="line"><span class="comment">//         获取日历类中的星期</span></span><br><span class="line">        System.out.println(cal.get(Calendar.DAY_OF_WEEK));<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        创建当前时间对应的日历类</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        cal.set(Calendar.YEAR,<span class="number">2012</span>);</span><br><span class="line">        cal.set(Calendar.MONTH,<span class="number">11</span>);</span><br><span class="line">        cal.set(Calendar.DAY_OF_MONTH,<span class="number">12</span>);</span><br><span class="line">        System.out.println(cal.get(Calendar.YEAR)+<span class="string">&quot;年 &quot;</span>+(cal.get(Calendar.MONTH)+<span class="number">1</span>)+<span class="string">&quot;月 &quot;</span>+cal.get(Calendar.DAY_OF_MONTH)+<span class="string">&quot;日&quot;</span>);</span><br><span class="line">       <span class="comment">// 2012年 12月 12日</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>tips: 月份从0开始，故显示时需要+1。星期是从周日开始。</p>
<ul>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        System.out.println(cal.get(Calendar.YEAR) + <span class="string">&quot;年&quot;</span> + (cal.get(Calendar.MONTH) + <span class="number">1</span>) + <span class="string">&quot;月&quot;</span> + cal.get(Calendar.DAY_OF_MONTH) + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line"><span class="comment">//      2020年12月28日</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用add方法，将日增加1</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 使用add方法，将年份减去9</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">9</span>);</span><br><span class="line">        System.out.println(cal.get(Calendar.YEAR) + <span class="string">&quot;年&quot;</span> + (cal.get(Calendar.MONTH) + <span class="number">1</span>) + <span class="string">&quot;月&quot;</span> + cal.get(Calendar.DAY_OF_MONTH) + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line"><span class="comment">//      2011年12月29日</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>public final Date getTime()</code>: 返回一个表示此 Calendar 时间值（从历元至现在的毫秒偏移量）的<br>Date 对象。 </li>
<li><code>public final void setTime(Date date)</code>: 使用给定的 Date 设置此 Calendar 的时间。 </li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将日历类对象转成Date对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Calendar cal = Calendar.getInstance();</span><br><span class="line">    Date date = cal.getTime();</span><br><span class="line">    System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Date对象转成日历类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        cal.setTime(date);</span><br><span class="line">        System.out.println(cal);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









































































]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>常用类</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之三大特性</title>
    <url>/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="java面向对象之三大特性"><a href="#java面向对象之三大特性" class="headerlink" title="java面向对象之三大特性"></a>java面向对象之三大特性</h1><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ol>
<li>理解java封装的意义</li>
<li>掌握封装的使用</li>
<li>掌握访问权限修饰符</li>
<li>掌握java继承的使用及注意事项</li>
</ol>
<h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h2><h3 id="1-1封装概述"><a href="#1-1封装概述" class="headerlink" title="1.1封装概述"></a>1.1封装概述</h3><p><strong>介绍：</strong></p>
<p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p>
<p><strong>是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法</strong>。</p>
<p><strong>原则：</strong></p>
<p>将<strong>内部细节隐藏</strong>起来，若需要访问某个成员，提供公共方法对其访问或者是只允许内部访问</p>
<p><strong>优点：</strong></p>
<ul>
<li>良好的封装能够减少耦合</li>
<li>类内部的结构可以自由修改</li>
<li>可以对类成员进行更精准的控制</li>
<li>隐藏信息，实现细节</li>
</ul>
<p><strong>封装基本使用：</strong></p>
<ul>
<li>使用private关键字来修饰类的成员(成员变量和成员方法)以及类</li>
<li>对需要访问的成员变量，提供对应的一对public的get和set方法</li>
<li>private修饰的成员方法，只允许本类中的其他方法调用</li>
<li> private修饰的类，只能作为内部类使用</li>
</ul>
<p><strong>说明：</strong></p>
<p>private是一个权限修饰符，代表最小权限（其他权限修饰符包括public、protected、default、private），只能在同一个类下访问。</p>
<h3 id="1-2封装成员变量"><a href="#1-2封装成员变量" class="headerlink" title="1.2封装成员变量"></a>1.2封装成员变量</h3><p>在没有权限修饰符修饰的成员变量，默认情况下可以被外界随意访问，一旦使用private私有权限修饰符修饰，成员变量就不会被外界随意访问，同时可以提供对应的<code>getXxx</code>方法 、<code>setXxx</code> 方法来控制内部逻辑代码。</p>
<p><strong>使用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> 数据类型 变量名;</span><br><span class="line"><span class="comment">// 同时提供成员变量的getXxx、setXxx方法</span></span><br></pre></td></tr></table></figure>

<p><strong>过程</strong></p>
<ol>
<li><p>使用 <code>private</code> 修饰成员变量，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>提供 <code>getXxx</code>方法 / <code>setXxx</code> 方法，可以来控制访问成员变量的方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用private封装成员变量</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 提供对应的getXxx`方法 / `setXxx` 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>getXxx</code>方法 / <code>setXxx</code> 方法只是将原本直接暴露的成员变量转用其他方法访问而已，而真正的控制的话可以在<code>getXxx</code>方法 / <code>setXxx</code> 方法中编写对应的逻辑代码。比如控制对年龄赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(age&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;学生年龄有误，不能为0&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 使用</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateVariableDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student stu= <span class="keyword">new</span> Student();	</span><br><span class="line"><span class="comment">//		stu.name=&quot;tom&quot;;  // 编译报错，已经无法直接访问private私有变量</span></span><br><span class="line">		<span class="comment">// 给私有变量赋值</span></span><br><span class="line">		stu.setName(<span class="string">&quot;杨幂&quot;</span>);</span><br><span class="line">		<span class="comment">// 获取对象私有变量的值</span></span><br><span class="line">		String name=stu.getName();</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-封装方法"><a href="#1-3-封装方法" class="headerlink" title="1.3 封装方法"></a>1.3 封装方法</h3><p>在没有权限修饰符修饰的成员方法，默认情况下可以被外界随意访问，一旦<strong>使用private私有权限修饰符修饰</strong>，<strong>成员方法就不能被外界</strong>。针对这种private修饰的成员方法，我们叫做私有方法，<strong>仅对本类中的其他方法使用</strong>。</p>
<p><strong>使用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> 静态修饰符 返回值类型 方法名(参数列表)&#123; 方法体 &#125;;</span><br></pre></td></tr></table></figure>

<p>过程：</p>
<ol>
<li><p>使用 <code>private</code> 修饰成员方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateMethodDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">		<span class="comment">// 调用本类的私有方法</span></span><br><span class="line">		<span class="keyword">int</span> sum= getSum(arr);</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 定义一个私有方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">			sum+=array[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其他类方法中无法使用</p>
<p><img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/image-20200618112516799.jpg"></p>
</li>
</ol>
<p><strong>作用：</strong></p>
<p>一个类中的方法如果代码量比较大、涉及较多的业务逻辑处理，就可以封装部分代码到本类的一个private私有方法中，这样体现了封装的特点和好处，能够极大程度的优化代码，并且条理清晰。</p>
<h3 id="1-4封装类"><a href="#1-4封装类" class="headerlink" title="1.4封装类"></a>1.4封装类</h3><p>private私有修饰符修饰的类只能作为内部类使用，也就是说在一个公开类的内部又声明了一个私有的类。</p>
<p><strong>使用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> clss 外部类名&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> 内部类名</span>&#123; 内部类成员 &#125;</span><br><span class="line">	外部类成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Java内部类根据定义的位置和修饰符，又分为成员内部类、静态内部类、方法内部类、匿名内部类，所以我们这里只是展示一种目前比较容易理解的方式，来说明一下封装类的效果（后续会对内部类详解）。</p>
<p><strong>示例：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateClassDemo</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义一个私有的内部类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">		<span class="comment">// 私有的内部类方法</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;私有内部类测试方法&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 外部类入口main方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建外部内对象，通过外部内对象来访问内部类对象</span></span><br><span class="line">		PrivateClassDemo p= <span class="keyword">new</span> PrivateClassDemo();</span><br><span class="line">		User u=p.<span class="function">new <span class="title">User</span><span class="params">()</span></span>;</span><br><span class="line">		u.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5为什么不能用private封装外部类"><a href="#1-5为什么不能用private封装外部类" class="headerlink" title="1.5为什么不能用private封装外部类"></a><strong>1.5为什么不能用private封装外部类</strong></h3><p>Java封装特性的本质作用是减少代码耦合度，隐藏内部实现细节，控制内部代码的可见性。private修饰成员变量，可以考虑使用get/set方法对外提供访问入口；private修饰成员方法，可以让内部其他方法访问；private修饰内部类，可以让外部类访问。但是，如果private修饰了外部类，那就没法进行访问了，那这个封装的外部类就没有存在的意义了，因此Java不允许适用private修饰外部类，只允许使用public、default这两种级别的权限修饰符进行控制。</p>
<h3 id="1-6标准JavaBean"><a href="#1-6标准JavaBean" class="headerlink" title="1.6标准JavaBean"></a>1.6标准JavaBean</h3><p><code>JavaBean</code> 是 Java语言编写类的一种标准规范。符合<code>JavaBean</code> 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的<code>set</code> 和<code>get</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">  <span class="comment">// 成员变量</span></span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="comment">// 无参构造方法【必须】</span></span><br><span class="line">  <span class="comment">// 有参构造方法【建议】</span></span><br><span class="line">  <span class="comment">// 成员方法	</span></span><br><span class="line">  <span class="comment">// getXxx()</span></span><br><span class="line">  <span class="comment">// setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例如：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">  <span class="function">publicvoid <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">publicvoid <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">publicint <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造使用</span></span><br><span class="line">    Student s= <span class="keyword">new</span> Student();</span><br><span class="line">    s.setName(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">    s.setAge(<span class="number">28</span>);</span><br><span class="line">    System.out.println(s.getName()+<span class="string">&quot;---&quot;</span>+s.getAge());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带参构造使用</span></span><br><span class="line">    Student s2= <span class="keyword">new</span> Student(<span class="string">&quot;赵丽颖&quot;</span>,<span class="number">28</span>);</span><br><span class="line">    System.out.println(s2.getName()+<span class="string">&quot;---&quot;</span>+s2.getAge());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-访问权限修饰符"><a href="#2-访问权限修饰符" class="headerlink" title="2.访问权限修饰符"></a>2.访问权限修饰符</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限：</p>
<ul>
<li>public：公共的。</li>
<li>protected：受保护的。</li>
<li>default：默认的（默认什么都不用写）。</li>
<li>private：私有的。</li>
</ul>
<h3 id="2-2不同权限的访问范围"><a href="#2-2不同权限的访问范围" class="headerlink" title="2.2不同权限的访问范围"></a>2.2不同权限的访问范围</h3><p><img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/image-20200618140830256.jpg"></p>
<p>可见，public具有最大权限。private则是最小权限。</p>
<p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p>
<ul>
<li>成员变量使用 private ，隐藏细节。</li>
<li>构造方法使用 public ，方便创建对象。</li>
<li>成员方法使用 public ，方便调用方法；私有方法使用private，仅对内提供访问。</li>
</ul>
<h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h2><h3 id="3-1-继承概述"><a href="#3-1-继承概述" class="headerlink" title="3.1 继承概述"></a>3.1 继承概述</h3><h4 id="3-1-1-继承介绍"><a href="#3-1-1-继承介绍" class="headerlink" title="3.1.1 继承介绍"></a>3.1.1 继承介绍</h4><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p><strong>生活中的继承：</strong></p>
<p><img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/image-20200618142639583.jpg"></p>
<p><strong>说明：</strong>在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。</p>
<h4 id="3-1-2-继承语法"><a href="#3-1-2-继承语法" class="headerlink" title="3.1.2 继承语法"></a>3.1.2 继承语法</h4><p><strong>继承语法格式：</strong></p>
<p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">	。。。</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">	。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; 	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;动物在奔跑&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 打印一下名字</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Rabbit r= <span class="keyword">new</span> Rabbit();</span><br><span class="line">		<span class="comment">// 通过父类方法为属性赋值</span></span><br><span class="line">		r.setName(<span class="string">&quot;小白兔&quot;</span>);</span><br><span class="line">		<span class="comment">// 调用从父类继承的方法</span></span><br><span class="line">		r.run();</span><br><span class="line">		<span class="comment">// 调用本类方法</span></span><br><span class="line">		r.printName(r.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-作用"><a href="#3-1-3-作用" class="headerlink" title="3.1.3 作用"></a>3.1.3 作用</h4><ul>
<li><p>提高<strong>代码的复用性</strong>。 </p>
</li>
<li><p>类与类之间产生了关系，是<strong>多态的前提</strong>。</p>
</li>
</ul>
<h3 id="3-2-继承的特点"><a href="#3-2-继承的特点" class="headerlink" title="3.2 继承的特点"></a>3.2 继承的特点</h3><h4 id="3-2-1-成员变量"><a href="#3-2-1-成员变量" class="headerlink" title="3.2.1 成员变量"></a>3.2.1 成员变量</h4><ul>
<li>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。</li>
<li>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123; </span><br><span class="line">	<span class="comment">// Fu中的成员变量。 </span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">3</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123; </span><br><span class="line">	<span class="comment">// Zi中的成员变量 </span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="comment">// 访问父类中的num </span></span><br><span class="line">		System.out.println(<span class="string">&quot;Fu num=&quot;</span> + num); </span><br><span class="line">		<span class="comment">// 访问子类中的num </span></span><br><span class="line">		System.out.println(<span class="string">&quot;Zi num=&quot;</span> + num); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo01</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		<span class="comment">// 创建子类对象 </span></span><br><span class="line">		Zi z = <span class="keyword">new</span> Zi(); </span><br><span class="line">		<span class="comment">// 调用子类中的show方法 </span></span><br><span class="line">		z.show(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// Fu num=6</span></span><br><span class="line"><span class="comment">// Zi num=6</span></span><br></pre></td></tr></table></figure>

<p><strong>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量，类似于之前学过的 this 。</strong></p>
<h4 id="3-2-2成员方法"><a href="#3-2-2成员方法" class="headerlink" title="3.2.2成员方法"></a>3.2.2成员方法</h4><h5 id="3-2-2-1成员方法不重名"><a href="#3-2-2-1成员方法不重名" class="headerlink" title="3.2.2.1成员方法不重名"></a>3.2.2.1成员方法不重名</h5><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>。</p>
<p>调用方法时，先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。</p>
<h5 id="3-2-2-2-成员方法重名"><a href="#3-2-2-2-成员方法重名" class="headerlink" title="3.2.2.2 成员方法重名"></a>3.2.2.2 成员方法重名</h5><p>如果子类父类中出现<strong>重名</strong>的成员方法，这时的访问是一种特殊情况，并且分为两种情况。</p>
<ul>
<li>如果子类出现与父类重名方法，但是<strong>方法参数不同</strong>，这种情况属于方法重载；</li>
<li>如果子类出现与父类重名方法，同时<strong>方法参数也相同</strong>，这种情况叫做<strong>方法重写Override</strong>。</li>
</ul>
<p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（方法名和参数列表都相同，<strong>重写的返回值类型相同或者是父类方法的子类</strong>），会出现覆盖效果，也称为重写或者复写。</p>
<p><strong>如果是父类的私有方法，因为根本无法继承，所以不存在重写。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;Fu show&quot;</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;Zi show&quot;</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo2</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		<span class="comment">// 创建子类对象 </span></span><br><span class="line">		Zi z = <span class="keyword">new</span> Zi(); </span><br><span class="line">		<span class="comment">// 子类中有show方法，只执行重写后的show方法</span></span><br><span class="line">		z.show(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// Zi show</span></span><br></pre></td></tr></table></figure>

<p><strong>重写的应用：</strong>子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。</p>
<h5 id="3-2-2-3-注意事项"><a href="#3-2-2-3-注意事项" class="headerlink" title="3.2.2.3 注意事项"></a>3.2.2.3 注意事项</h5><ul>
<li><p>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</p>
</li>
<li><p>子类方法覆盖父类方法，方法名和参数列表都要一模一样。</p>
</li>
<li><p>子类方法覆盖父类方法，返回值类型可以与父类保持一致，或者返回父类返回值的子类。</p>
</li>
<li><p>私有方法不是不能继承，而是无法访问，所以不能重写。</p>
</li>
</ul>
<h4 id="3-2-3-构造方法"><a href="#3-2-3-构造方法" class="headerlink" title="3.2.3 构造方法"></a>3.2.3 构造方法</h4><ul>
<li><p>构造方法的名字是与类名一致的。所以<strong>子类是无法继承父类构造方法</strong>的。</p>
</li>
<li><p>构造方法的作用是创建对象并初始化成员变量的。所以<strong>子类的初始化过程中，必须先执行父类的初始化动作</strong>。子类的构造方法中<strong>默认有一个 super()</strong> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Fu</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;Fu()&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123; 	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span> </span>&#123; <span class="comment">// super()，调用父类构造方法</span></span><br><span class="line"><span class="comment">//		super();  // super()方法默认提供，可以省略</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Zi()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo03</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		<span class="comment">// 创建子类对象 </span></span><br><span class="line">		Zi z = <span class="keyword">new</span> Zi(); 	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// Fu()</span></span><br><span class="line"><span class="comment">// Zi()</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>super代表父类对象，在子类构造方法中默认提供了一个super()方法来执行父类的空参构造方法。</p>
<h3 id="3-3-super关键字"><a href="#3-3-super关键字" class="headerlink" title="3.3 super关键字"></a>3.3 super关键字</h3><h4 id="3-3-1-继承空间介绍"><a href="#3-3-1-继承空间介绍" class="headerlink" title="3.3.1 继承空间介绍"></a>3.3.1 继承空间介绍</h4><p><strong>父类空间优先于子类对象产生：</strong></p>
<p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。</p>
<p><img src="/2021/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/image-20200618153241577.jpg"></p>
<h4 id="3-3-2-super关键字说明"><a href="#3-3-2-super关键字说明" class="headerlink" title="3.3.2 super关键字说明"></a>3.3.2 super关键字说明</h4><ul>
<li><p><strong>super</strong> ：代表父类的<strong>存储空间标识</strong>(可以理解为父亲的引用)。</p>
</li>
<li><p><strong>this</strong> ：代表<strong>当前对象的引用</strong></p>
</li>
</ul>
<p><strong>super、this用法对比：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.成员变量 -- 本类的 </span><br><span class="line">super.成员变量 -- 父类的 </span><br><span class="line"></span><br><span class="line">this.成员方法名() -- 本类的 </span><br><span class="line">super.成员方法名() -- 父类的</span><br><span class="line"></span><br><span class="line">this(...) -- 本类的构造方法 </span><br><span class="line">super(...) -- 父类的构造方法</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">3</span>; 	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fun run()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Fu</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;Fu()&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123; 	</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">5</span>; </span><br><span class="line">	<span class="comment">// 1、变量调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu N=&quot;</span>+<span class="keyword">super</span>.n);</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu N=&quot;</span>+<span class="keyword">this</span>.n);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Zi run()&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">// 2、成员方法调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">this</span>.run();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">// 3、构造方法调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123; </span><br><span class="line">		<span class="comment">// super()调用父类空参构造方法，默认已经提供，可以省略</span></span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Zi()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo4</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		<span class="comment">// 创建子类对象 </span></span><br><span class="line">		Zi z = <span class="keyword">new</span> Zi(); 	</span><br><span class="line">		z.test();		</span><br><span class="line">		z.runTest();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-注意"><a href="#3-3-3-注意" class="headerlink" title="3.3.3 注意"></a>3.3.3 注意</h4><ul>
<li><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p>
</li>
<li><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p>
</li>
</ul>
<h3 id="3-4-继承的特点"><a href="#3-4-继承的特点" class="headerlink" title="3.4 继承的特点"></a>3.4 继承的特点</h3><p><strong>1、Java只支持单继承，不支持多继承</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一个类只能有一个父类，不可以有多个父类。 </span><br><span class="line">class C extends A&#123;&#125; //ok </span><br><span class="line"></span><br><span class="line">class C extends A，B... //error</span><br></pre></td></tr></table></figure>

<p><strong>2、Java支持多层继承(继承体系)</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;&#125; </span><br><span class="line"></span><br><span class="line">class B extends A&#123;&#125; </span><br><span class="line"></span><br><span class="line">class C extends B&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、所有的类都直接或者间接继承了Object类，Object类是所有类的父类。</strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之多态</title>
    <url>/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、掌握Java多态的使用</span><br><span class="line">2、掌握引用数据类型转换及异常处理</span><br><span class="line">3、掌握几种内部类的使用</span><br><span class="line">4、理解Java内存管理与垃圾回收机制</span><br></pre></td></tr></table></figure>



<h1 id="1-多态"><a href="#1-多态" class="headerlink" title="1. 多态"></a>1. 多态</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="1-1-1-什么是多态"><a href="#1-1-1-什么是多态" class="headerlink" title="1.1.1 什么是多态"></a><strong>1.1.1 什么是多态</strong></h3><p>多态是继封装、继承之后，面向对象的第三大特性。</p>
<p>生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是</p>
<p>不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。</p>
<p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p>
<h3 id="1-1-2-多态分类"><a href="#1-1-2-多态分类" class="headerlink" title="1.1.2 多态分类"></a>1.1.2 多态分类</h3><p>对面向对象来说，多态分为<strong>编译时多态和运行时多态</strong>。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。</p>
<p><a href="http://c.biancheng.net/java/">Java</a> 实现运行时多态有 3 个必要条件：<strong>继承、重写和向上转型</strong>。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。</p>
<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</li>
</ul>
<h2 id="1-2-运行时多态"><a href="#1-2-运行时多态" class="headerlink" title="1.2 运行时多态"></a>1.2 运行时多态</h2><p>运行时多态一个最显著的例子就是子类的上转型对象，即父类引用指向之类对象,调用的方法只能是父类下包含的方法(指向子类的那个父类引用)，执行的结果是子类重写以后的。</p>
<p><strong>多态体现的格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类类型 变量名 = new 子类对象； </span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> Zi(); </span><br><span class="line">f.method();</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后的方法。</strong></p>
</blockquote>
<p><strong>父类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 多态形式，创建对象 </span></span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat(); </span><br><span class="line">        <span class="comment">// 调用的是 Cat 的eat </span></span><br><span class="line">        a1.eat(); </span><br><span class="line">        <span class="comment">// 多态形式，创建对象 </span></span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Dog(); </span><br><span class="line">        <span class="comment">// 调用的是 Dog 的 eat </span></span><br><span class="line">        a2.eat(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-多态的好处"><a href="#1-3-多态的好处" class="headerlink" title="1.3 多态的好处"></a>1.3 多态的好处</h2><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下：</p>
<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 多态形式，创建对象 </span></span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat(); </span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog(); </span><br><span class="line">        <span class="comment">// 调用showCatEat </span></span><br><span class="line">        showCatEat(c); </span><br><span class="line">        <span class="comment">// 调用showDogEat </span></span><br><span class="line">        showDogEat(d); </span><br><span class="line">        <span class="comment">// 以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代 而执行效果一致</span></span><br><span class="line">        showAnimalEat(c); </span><br><span class="line">        showAnimalEat(d); </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCatEat</span> <span class="params">(Cat c)</span></span>&#123; </span><br><span class="line">        c.eat(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDogEat</span> <span class="params">(Dog d)</span></span>&#123; </span><br><span class="line">        d.eat(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showAnimalEat</span> <span class="params">(Animal a)</span></span>&#123; </span><br><span class="line">        a.eat(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。</p>
<p>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。</p>
<p>不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。</p>
<p>所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p>
<h2 id="1-4-多态的成员访问特点"><a href="#1-4-多态的成员访问特点" class="headerlink" title="1.4 多态的成员访问特点"></a>1.4 多态的成员访问特点</h2><ul>
<li>成员变量：编译看左边（父类），运行看左边（父类）</li>
</ul>
<p>​    所有的成员变量取决于编译时类型</p>
<ul>
<li>成员方法：编译看左边（父类），运行看右边（子类）</li>
</ul>
<p>​    所有的成员方法取决于运行时类型</p>
<ul>
<li>静态方法：编译看左边（父类），运行看左边（父类）</li>
</ul>
<p>​    所有的静态方法取决于编译时类型</p>
<h2 id="1-5-引用类型转换"><a href="#1-5-引用类型转换" class="headerlink" title="1.5 引用类型转换"></a>1.5 引用类型转换</h2><h3 id="1-5-1-引用类型转换介绍"><a href="#1-5-1-引用类型转换介绍" class="headerlink" title="1.5.1 引用类型转换介绍"></a>1.5.1 引用类型转换介绍</h3><p>多态的转型分为向上转型与向下转型两种：</p>
<p><strong>向上转型：</strong>多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</p>
<p>当父类引用指向一个子类对象时，便是向上转型。</p>
<p><strong>使用格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类类型 变量名 = new 子类类型();</span><br><span class="line">如：Animal a = new Cat();</span><br></pre></td></tr></table></figure>

<p><strong>向下转型：</strong>父类类型向子类类型向下转换的过程，这个过程是强制的。</p>
<p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p>
<p><strong>使用格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:Cat c =(Cat) a;</span><br></pre></td></tr></table></figure>



<h3 id="1-5-2-为什么要转换"><a href="#1-5-2-为什么要转换" class="headerlink" title="1.5.2 为什么要转换"></a>1.5.2 为什么要转换</h3><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类有而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p>
<p><strong>修改一下Dog类，添加特有方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;吃骨头&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchHouse</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;看家&quot;</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		<span class="comment">// 向上转型 </span></span><br><span class="line">		Animal a = <span class="keyword">new</span> Cat(); </span><br><span class="line">		a.eat(); <span class="comment">// 调用的是 Cat 的 eat </span></span><br><span class="line">		<span class="comment">// 向下转型 </span></span><br><span class="line">		Cat c = (Cat)a; </span><br><span class="line">		c.catchMouse(); <span class="comment">// 调用的是 Cat 的 catchMouse </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-5-3-类型转换异常"><a href="#1-5-3-类型转换异常" class="headerlink" title="1.5.3 类型转换异常"></a>1.5.3 类型转换异常</h3><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		<span class="comment">// 向上转型 </span></span><br><span class="line">		Animal a = <span class="keyword">new</span> Cat(); </span><br><span class="line">		a.eat(); <span class="comment">// 调用的是 Cat 的 eat </span></span><br><span class="line">		<span class="comment">// 向下转型 </span></span><br><span class="line">		Dog d = (Dog)a; </span><br><span class="line">		d.watchHouse(); <span class="comment">// 调用的是 Dog 的 watchHouse 【运行报错】 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。</p>
<p>为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量名 instanceof 数据类型 如果变量属于该数据类型，返回true。 如果变量不属于该数据类型，返回false。</span><br></pre></td></tr></table></figure>

<p>所以，转换前，我们最好先做一个判断，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 向上转型 </span></span><br><span class="line">        Animal a = <span class="keyword">new</span> Cat(); </span><br><span class="line">        a.eat(); <span class="comment">// 调用的是 Cat 的 eat </span></span><br><span class="line">        <span class="comment">// 向下转型 </span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)&#123; </span><br><span class="line">            Cat c = (Cat)a; </span><br><span class="line">            c.catchMouse(); <span class="comment">// 调用的是 Cat 的 catchMouse </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog)&#123; </span><br><span class="line">            Dog d = (Dog)a; </span><br><span class="line">            d.watchHouse(); <span class="comment">// 调用的是 Dog 的 watchHouse </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2. 内部类"></a>2. 内部类</h1><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。</p>
<p>内部类可以很好地实现隐藏，一般的非内部类是不允许有 private 与 protected 权限的，但内部类可以。内部类拥有外部类的所有元素的访问权限。</p>
<p>内部类可以分为<strong>：成员内部类、局部内部类、静态内部类、匿名内部类</strong>，每种内部类都有它特定的一些特点。</p>
<h2 id="2-1-成员内部类"><a href="#2-1-成员内部类" class="headerlink" title="2.1 成员内部类"></a>2.1 成员内部类</h2><p><strong>成员内部类</strong> ：定义在<strong>类中方法外</strong>的类。</p>
<p><strong>定义格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 外部类 &#123; </span><br><span class="line">	// 成员变量</span><br><span class="line">	// 成员方法</span><br><span class="line">	class 内部类&#123; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 成员内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问特点：</strong></p>
<ul>
<li>内部类可以直接访问外部类的成员，包括私有成员。</li>
<li>外部类要访问内部类的成员，必须要建立内部类的对象。</li>
</ul>
<p><strong>创建内部类对象格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类型().new 内部类型()；</span><br></pre></td></tr></table></figure>



<h2 id="2-2-静态内部类"><a href="#2-2-静态内部类" class="headerlink" title="2.2 静态内部类"></a>2.2 静态内部类</h2><p><strong>成员内部类</strong> ：静态内部类是指使用 static 修饰的内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问特点：</strong></p>
<ul>
<li>在创建静态内部类的实例时，不需要创建外部类的实例；</li>
<li>静态内部类可以直接访问外部类的静态成员，如果要访问外部类的实例成员，则需要通过外部类的实例去访问。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Outer.Inner inner =new Outer.Inner();</span><br></pre></td></tr></table></figure>





<h2 id="3-3-局部内部类"><a href="#3-3-局部内部类" class="headerlink" title="3.3 局部内部类"></a>3.3 局部内部类</h2><p><strong>局部内部类：</strong>局部内部类是指在一个方法中局部位置定义的内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 局部内部类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问特点：</strong></p>
<ul>
<li>局部内部类与局部变量一样，不能使用访问控制修饰符（public、private 和 protected）和 static 修饰符修饰；</li>
<li>局部内部类只在当前方法中有效；</li>
<li>局部内部类中不能定义 static 成员。</li>
</ul>
<h2 id="3-4-匿名内部类"><a href="#3-4-匿名内部类" class="headerlink" title="3.4 匿名内部类"></a>3.4 匿名内部类</h2><p><strong>匿名内部类：</strong>是内部类的简化写法，它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象<strong>。</strong></p>
<p>开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作，</p>
<blockquote>
<ol>
<li>定义子类</li>
<li>重写接口中的方法</li>
<li>创建子类对象</li>
<li>调用重写后的方法</li>
</ol>
</blockquote>
<p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p>
<p><strong>前提：</strong>存在一个<strong>类或者接口</strong>，这里的<strong>类可以是具体类也可以是抽象类</strong>。</p>
<p><strong>格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new 父类名或者接口名()&#123; </span><br><span class="line">	// 方法重写 </span><br><span class="line">	@Override </span><br><span class="line">	public void 方法名() &#123; </span><br><span class="line">		// 执行语句 </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="第3章-Java内存管理-amp-垃圾回收机制"><a href="#第3章-Java内存管理-amp-垃圾回收机制" class="headerlink" title="第3章 Java内存管理&amp;垃圾回收机制"></a>第3章 Java内存管理&amp;垃圾回收机制</h1><p>我们知道，java所谓的跨平台特性（hardware- and operating system-independence）是依赖于JVM的。也就是，JAVA代码写好了之后会被编译成java的字节，一般存放为class文件，之后由JVM负责解释执行。</p>
<p>而做java后台开发，对jvm的考察就是最重要的了！面试官肯定会问你对jvm的理解，你就要从以下几个角度来描述：</p>
<blockquote>
<ol>
<li>JVM内存的划分</li>
<li>垃圾回收问题(定义、回收的东西)</li>
<li>GC算法</li>
<li>新生代、老年代、(jdk8之前还有永久代，jdk8开始取消了永久代的划分)</li>
</ol>
</blockquote>
<p>java代码的执行依赖于JVM，这里我们了解一下JVM的内存管理机制和垃圾回收机制。</p>
<h2 id="3-1-Java内存管理机制"><a href="#3-1-Java内存管理机制" class="headerlink" title="3.1 Java内存管理机制"></a>3.1 Java内存管理机制</h2><p>关于Java内存管理，可以查看官方文档声明：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<p><img src="/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/image-20201228145334441.jpg">)</p>
<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分成为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的随着虚拟机的进程启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 8版）》规定，Java虚拟机所管理的内存将包括以下几个运行时数据区域，如下图所示：</p>
<p><img src="/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/image-20201228145143326.jpg"></p>
<h3 id="3-1-1-程序计数器"><a href="#3-1-1-程序计数器" class="headerlink" title="3.1.1 程序计数器"></a>3.1.1 程序计数器</h3><p>程序计数器有以下 三个特点：</p>
<ul>
<li><strong>较小</strong></li>
</ul>
<p>程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所指向的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要指向字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<ul>
<li><strong>线程私有</strong></li>
</ul>
<p>由于 Java 虚拟机的多线程是通过线程轮流 切换并分配处理器指向时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<ul>
<li><strong>无异常</strong></li>
</ul>
<p>如果线程正在执行的是一个 Java 的方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有任何 OutOfMemoryError 情况的区域。</p>
<h3 id="3-1-2-虚拟机栈"><a href="#3-1-2-虚拟机栈" class="headerlink" title="3.1.2 虚拟机栈"></a>3.1.2 虚拟机栈</h3><ul>
<li><strong>线程私有</strong></li>
</ul>
<p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。</p>
<ul>
<li><strong>描述 Java 方法执行的内存模型</strong></li>
</ul>
<p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame，栈帧是方法运行期的基础数据结构）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈栈从入栈到出栈的过程。</p>
<ul>
<li><strong>异常</strong></li>
</ul>
<p>在 Java 虚拟中，对虚拟机规定了下面两种异常：</p>
<p>① <strong>StockOverflowError</strong></p>
<p>当执行 Java 方法是会进行压栈的操作，在栈栈会保存局部变量、操作栈和方法出口等信息。</p>
<p>JVM 规定了栈的最大胜读，如果线程请求执行方法时栈的深度大于规定的深度，就会抛出栈溢出异常 StockOverflowError。</p>
<p>② <strong>OutOfMemoryError</strong></p>
<p>如果虚拟机在扩展时无法申请到足够的内存，就会抛出内存溢出异常 OutOfMemoryError。</p>
<h3 id="3-1-3-本地方法栈"><a href="#3-1-3-本地方法栈" class="headerlink" title="3.1.3 本地方法栈"></a>3.1.3 本地方法栈</h3><p>本地方法栈的作用于虚拟机非常相似，它有下面两个特点。</p>
<p><strong>① 为 native 服务</strong></p>
<p>本地方法栈与虚拟机栈的区别是虚拟机栈为 Java 服务，而本地方法栈为 native 方法服务。</p>
<p><strong>② 异常</strong></p>
<p>与虚拟机栈一样，本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<h3 id="3-1-4-Java堆"><a href="#3-1-4-Java堆" class="headerlink" title="3.1.4 Java堆"></a>3.1.4 Java堆</h3><p>Java 堆（Java Heap）也就是实例堆，它有以下四个特点：</p>
<p><strong>① 最大</strong></p>
<p>对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。</p>
<p><strong>② 线程共享</strong></p>
<p>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p>
<p><strong>③ 存放实例</strong></p>
<p>此内存区域的唯一目的就是存放对象的实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发送，所有的对象都分配在堆上也渐渐变得不那么“绝对”了 。</p>
<p><strong>④ GC</strong></p>
<p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”（Garbage Collected Heap）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法（详见下节），所以 Java 堆中还可以细分为：新生代和老年代。如果从内存分配的角度看，线程共享的 Java 堆中可能划分多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都依然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p>
<h3 id="3-1-5-方法区"><a href="#3-1-5-方法区" class="headerlink" title="3.1.5 方法区"></a>3.1.5 方法区</h3><p>方法区存储的是已经被虚拟机加载的数据，它有以下三个特点:</p>
<p><strong>① 线程共享</strong></p>
<p>方法区域 Java 堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的等数据。</p>
<p><strong>② 存储的数据类型</strong></p>
<p><strong>◇</strong> 类的信息；</p>
<p><strong>◇</strong> 常量；</p>
<p><strong>◇</strong> 静态变量；</p>
<p><strong>◇</strong> 即时编译器编译后的代码，等。</p>
<p><strong>③ 异常</strong></p>
<p>方法区的大小决定履历系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样抛出内存溢出异常 OutOfMemoryError。</p>
<p><strong>方法区又可以分为运行时常量池和直接内存两部分：</strong></p>
<p><strong>① 运行常量池</strong></p>
<p>运行时常量池（Run-time Constant Pool）是方法区的一部分。</p>
<p>Class 文件中处了有类的 版本、字段、方法和接口等描述信息，还有一项信息就是常量池（Constant Pool Table）。</p>
<p>常量池用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>运行时常量池受到方法区内存的限制，当常量池无法再申请到内存时就会抛出 OutOfMemoryError 异常。</p>
<p><strong>② 直接内存</strong></p>
<p>直接内存（Direct Memory）有以下四个特点：</p>
<p>a）在虚拟机数据区外</p>
<p>直接内存不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。</p>
<p>b）直接分配</p>
<p>在 JDK1.4 中新加入的 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用操作，这样能避免在 Java 堆和 native 堆中来回复制数据。</p>
<p>c）受设备内存大小限制</p>
<p>直接内存的分配不会受到 Java 堆大小的限制，但是会受到设备总内存（RAM 以及 SWAP 区）大小以及处理器寻址空间的限制。</p>
<p>d）异常</p>
<p>直接内存的容量默认与 Java 对的最大值一样，如果超额申请内存，也可能导致 OOM 异常出现。</p>
<h2 id="3-2-java垃圾回收机制"><a href="#3-2-java垃圾回收机制" class="headerlink" title="3.2 java垃圾回收机制"></a>3.2 java垃圾回收机制</h2><p> java  语言中一个显著的特点就是引入了java回收机制，是c++程序员最头疼的内存管理的问题迎刃而解，它使得java程序员在编写程序的时候不在考虑内存管理。由于有个垃圾回收机制，java中的额对象不在有“作用域”的概念，只有对象的引用才有“作用域”。</p>
<p>垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存；java语言规范没有明确的说明JVM 使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做两件基本事情：（1）发现无用的信息对象；（2）回收将无用对象占用的内存空间。使该空间可被程序再次使用。</p>
<h3 id="3-2-1-标记-清除算法"><a href="#3-2-1-标记-清除算法" class="headerlink" title="3.2.1 标记-清除算法"></a>3.2.1 标记-清除算法</h3><p>标记-清除算法（Mark-Sweep）相当于是先把货架上有人买的、没人买的、空着的商品和位置都记录下来，然后再把没人买的商品统一进行下架，这是垃圾收集器中的早期策略。</p>
<p><img src="/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/image-20201228160210269.jpg"></p>
<ul>
<li><strong>工作原理</strong></li>
</ul>
<p><strong>◇</strong> 第一步：标记所有需要回收的对象；</p>
<p><strong>◇</strong> 第二步：标记完成后，统一回收所有被标记的对象。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p><strong>◇</strong> 效率低</p>
<p>标记和清除的效率都不高。</p>
<p><strong>◇</strong> 内存碎片</p>
<p>标记清除后会产生大量不连续的内存碎片，内存碎片大多会导致当程序需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发 GC。</p>
<h3 id="4-2-2-复制算法"><a href="#4-2-2-复制算法" class="headerlink" title="4.2.2 复制算法"></a>4.2.2 复制算法</h3><p>为了解决效率问题，复制（Copying）收集算法出现了。</p>
<p><img src="/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/image-20201228160155295.jpg"></p>
<ul>
<li><strong>工作原理</strong></li>
</ul>
<p>复制算法把可用内存按容量划分为大小相同的两块，每次只使用其中的一块。</p>
<p>当使用中的这块内存用完了，就把存活的对象复制到另一块内存上，然后把已使用的空间一次清理掉。</p>
<p>这样每次都是对半个内存区域进行回收，内存分配时也不用考虑内存碎片等复杂问题。</p>
<ul>
<li><strong>优点</strong></li>
</ul>
<p>复制算法的优点是每次只对半个内存区域进行内存回收，分配内存时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p><strong>◇</strong> 浪费空间</p>
<p>把内存缩小一半用太浪费空间。</p>
<p><strong>◇</strong> 有时效率低</p>
<p>在对象存活率高时，要进行较多的复制操作，这时效率就低了。</p>
<h3 id="4-2-3-标记-整理算法"><a href="#4-2-3-标记-整理算法" class="headerlink" title="4.2.3 标记-整理算法"></a>4.2.3 标记-整理算法</h3><p>在复制算法中，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用内存中所有对象都存活的低端情况所以养老区不能用这种算法。</p>
<p>根据养老区的特点，有人提出了一种标记-整理（Mark-Compact）算法。</p>
<p><img src="/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/image-20201228160418278.jpg"></p>
<ul>
<li><strong>工作原理</strong></li>
</ul>
<p>标记-整理算法的标记过程与标记-清除算法一样，但后续步骤是让所有存活的对象向一端移动，然后直接清除掉边界外的内存。</p>
<h3 id="4-2-4-分代收集算法"><a href="#4-2-4-分代收集算法" class="headerlink" title="4.2.4 分代收集算法"></a>4.2.4 分代收集算法</h3><p>现代商业虚拟机的垃圾回收机制都是采用分代收集算法（Generational Collection）算法，这种算法会根据对象存活周期的不同将内存划分为几块，这样就可以根据各个区域的特点采用最适当的收集算法。</p>
<p>在新生区，每次垃圾收集都有大批对象死去，只有少了存活，所以可以用复制算法。</p>
<p>养老区中因为对象存活率高、没有额外空间对它进行担保，就必须使用标记-清除或标记-整理算法进行回收。</p>
<p>对内存可分为新生区、养老区永久存储区三个区域。</p>
<p><img src="/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/image-20201228160527396.jpg"></p>
<p><strong>一、新生区（Young Generation Space）</strong></p>
<blockquote>
<p>新生区也叫年轻代。</p>
</blockquote>
<ol>
<li><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p>
</li>
<li><p>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。</p>
<p>回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p>
</li>
<li><p>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</p>
</li>
<li><p>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</p>
</li>
</ol>
<p><strong>二、养老区（Tenure Generation Space）</strong></p>
<blockquote>
<p>养老区也叫老年代。</p>
</blockquote>
<p>1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p>
<p><strong>三、永久存储区（Permanent Space）</strong></p>
<blockquote>
<p>永久存储区也叫持久代。</p>
</blockquote>
<p>持久代用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>
<h3 id="4-2-5-总结"><a href="#4-2-5-总结" class="headerlink" title="4.2.5 总结"></a>4.2.5 总结</h3><p>​        目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p>
<p>　　而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。</p>
<p><img src="/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/image-20201228162847419.jpg"></p>
<ol>
<li><p>当Eden区满的时候，会触发第一次Minor gc，把还活着的对象拷贝到Survivor From区；</p>
</li>
<li><p>当Eden区再次触发Minor gc的时候，会扫描Eden区和From区，对两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域，并将Eden区和From区清空，然后将From区和to区交换，即保持to区为空；</p>
</li>
<li><p>接着，重复1、2步操作；</p>
</li>
<li><p>部分对象会在From区域和To区域中复制来复制去，如此交换15次(由JVM参数MaxTenuringThreshold决定，这个参数默认是15)，最终如果还存活，就存入老年代。</p>
<blockquote>
<p>但并非意味着，对象必须要经历15次YGC才会晋升到老年代中。例如，当survivor区空间不够时，便会提前进入到老年代中，但这个次数一定不大于设置的最大阈值。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之抽象类与接口</title>
    <url>/2021/07/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="面向对象之抽象类与基础"><a href="#面向对象之抽象类与基础" class="headerlink" title="面向对象之抽象类与基础"></a>面向对象之抽象类与基础</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、掌握抽象类的定义及使用</span><br><span class="line">2、掌握接口的定义及使用</span><br><span class="line">3、掌握比较器的使用</span><br></pre></td></tr></table></figure>



<h1 id="第1章-抽象类"><a href="#第1章-抽象类" class="headerlink" title="第1章 抽象类"></a>第1章 抽象类</h1><h2 id="1-1-抽象类概述"><a href="#1-1-抽象类概述" class="headerlink" title="1.1 抽象类概述"></a>1.1 抽象类<strong>概述</strong></h2><p><strong>由来：</strong></p>
<p>当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的功能具体实现方式，那么这些方法都有具体的方法体。分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。例如：</p>
<ul>
<li>描述讲师的行为：工作。</li>
<li>描述督导的行为：工作。</li>
</ul>
<p>讲师、督导之间有共性，可以进行向上抽取。抽取它们的所属共性类型：员工。由于讲师、督导都具有工作功能，但是他们具体工作内容却不一样。这时在描述员工时，发现了有些功能不能够具体描述，那么，这些不具体的功能，需要在类中标识出来，通过java中的关键字abstract(抽象)修饰。当定义了抽象函数的类也必须被abstract关键字修饰，被abstract关键字修饰的类是抽象类。</p>
<p><strong>含义：</strong></p>
<ul>
<li><strong>抽象方法</strong> ：没有方法体的方法。</li>
<li><strong>抽象类</strong>：包含抽象方法的类。</li>
</ul>
<h2 id="1-2-抽象类定义及使用"><a href="#1-2-抽象类定义及使用" class="headerlink" title="1.2 抽象类定义及使用"></a>1.2 抽象类定义及使用</h2><h3 id="1-2-1-抽象方法"><a href="#1-2-1-抽象方法" class="headerlink" title="1.2.1 抽象方法"></a>1.2.1 抽象方法</h3><p>使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p><strong>定义格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 abstract 返回值类型 方法名 (参数列表)；</span><br></pre></td></tr></table></figure>

<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract void work();</span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-抽象类"><a href="#1-2-2-抽象类" class="headerlink" title="1.2.2 抽象类"></a>1.2.2 抽象类</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p>
<p><strong>定义格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 abstract class 类名字 &#123;</span><br><span class="line">	抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Employee &#123; </span><br><span class="line">	public abstract void work(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-3-抽象类的基本使用"><a href="#1-2-3-抽象类的基本使用" class="headerlink" title="1.2.3 抽象类的基本使用"></a>1.2.3 抽象类的基本使用</h3><p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，<strong>该子类也必须声明为抽象类</strong>。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，就失去意义。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lecturer</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;讲师在讲课&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3、测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Lecturer lt= <span class="keyword">new</span> Lecturer();</span><br><span class="line">		lt.work();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<h2 id="1-3-注意事项"><a href="#1-3-注意事项" class="headerlink" title="1.3 注意事项"></a>1.3 注意事项</h2><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p>
<ol>
<li>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</li>
</ol>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
</blockquote>
<ol start="2">
<li>抽象类中，<strong>可以有构造方法，</strong>是供子类创建对象时，初始化父类成员使用的。</li>
</ol>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p>
</blockquote>
<ol start="3">
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
</ol>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
<ol start="4">
<li>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</li>
</ol>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
<h1 id="第2章-接口"><a href="#第2章-接口" class="headerlink" title="第2章 接口"></a>第2章 接口</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1</strong> <strong>概述</strong></h2><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是<strong>封装了方法</strong>，包含常量、抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8）。</p>
<p>接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
<ul>
<li>public class 类名.java–&gt;.class</li>
<li>public interface 接口名.java–&gt;.class</li>
</ul>
<p><strong>引用数据类型：</strong>数组，类，接口。</p>
<p>接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p>
<h2 id="2-2-接口定义及使用"><a href="#2-2-接口定义及使用" class="headerlink" title="2.2 接口定义及使用"></a><strong>2.2</strong> 接口定义及使用</h2><h3 id="2-2-1-接口定义使用语法概述"><a href="#2-2-1-接口定义使用语法概述" class="headerlink" title="2.2.1 接口定义使用语法概述"></a>2.2.1 接口定义使用语法概述</h3><p><strong>定义语法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123; </span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">	<span class="comment">// 抽象方法 </span></span><br><span class="line">	<span class="comment">// 默认方法 </span></span><br><span class="line">	<span class="comment">// 静态方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>在JDK 8之前，Java接口中只包括常量与抽象方法，从JDK8开始，接口中新增了默认方法与静态方法。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、常量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_URL = <span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>;</span><br><span class="line">	<span class="comment">// 2、抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 3、静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4、默认方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃饭了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用：</strong></p>
<p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。</p>
<p><strong>非抽象子类实现接口：</strong></p>
<ol>
<li><p>必须重写接口中所有抽象方法。</p>
</li>
<li><p>继承了接口的默认方法，即可以直接通过实现类对象调用，也可以重写。</p>
</li>
<li><p>接口中的静态方法不能继承与重写，直接使用接口名调用即可。</p>
</li>
</ol>
<p><strong>实现格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名 implements 接口名 &#123; </span><br><span class="line">	// 重写接口中抽象方法【必须】 </span><br><span class="line">	// 重写接口中默认方法【可选】 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-2-接口常量"><a href="#2-2-2-接口常量" class="headerlink" title="2.2.2 接口常量"></a>2.2.2 接口常量</h3><p><strong>定义语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final 常量类型 常量名 = 常量值;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final String DRIVER_URL = &quot;jdbc:mysql://localhost:3306/mydb&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>Java接口中只能存在常量，不存在变量；</li>
<li>接口中定义常量时，<strong>public static final关键字默认可以省略</strong>，JVM会自动进行添加；</li>
<li>接口中定义常量时，<strong>必须进行初始化赋值，其初始化赋值后，值不能改变</strong>；</li>
<li>接口的实现类默认继承了接口中的常量，可以通过接口、子类、子类对象调用；</li>
<li>常量名要符合Java标识符规范，常量名通常用大写与下划线结合的形式。</li>
</ul>
<p><strong>使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span> <span class="keyword">implements</span> <span class="title">InterfaceName</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		InterfaceTest ift=<span class="keyword">new</span> InterfaceTest();</span><br><span class="line">		<span class="comment">// 1、通过接口调用接口常量</span></span><br><span class="line">		System.out.println(InterfaceName.DRIVER_URL);</span><br><span class="line">		<span class="comment">// 2、通过实现类调用接口常量</span></span><br><span class="line">		System.out.println(InterfaceTest.DRIVER_URL);</span><br><span class="line">		<span class="comment">// 3、通过实现类对象调用接口常量</span></span><br><span class="line">		System.out.println(ift.DRIVER_URL);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-3-抽象方法"><a href="#2-2-3-抽象方法" class="headerlink" title="2.2.3 抽象方法"></a>2.2.3 抽象方法</h3><p><strong>定义语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 abstract 返回值类型 方法名 (参数列表);</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract void work();</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>接口中抽象方法的定义与抽象类中方法的定义及使用是一样的；</li>
<li>接口中，定义抽象方法时，abstract关键字可以省略，JVM会自动添加。</li>
</ul>
<p><strong>使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span> <span class="keyword">implements</span> <span class="title">InterfaceName</span></span>&#123;</span><br><span class="line">	<span class="comment">// 重写接口方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;该工作了&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 入口测试方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		InterfaceTest ift=<span class="keyword">new</span> InterfaceTest();</span><br><span class="line">		<span class="comment">// 1.1、通过接口调用接口常量</span></span><br><span class="line">		System.out.println(InterfaceName.DRIVER_URL);</span><br><span class="line">		<span class="comment">// 1.2、通过实现类调用接口常量</span></span><br><span class="line">		System.out.println(InterfaceTest.DRIVER_URL);</span><br><span class="line">		<span class="comment">// 1.3、通过实现类对象调用接口常量</span></span><br><span class="line">		System.out.println(ift.DRIVER_URL);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2、通过实现类对象调用重写的接口方法</span></span><br><span class="line">		ift.work();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-4-静态方法"><a href="#2-2-4-静态方法" class="headerlink" title="2.2.4 静态方法"></a>2.2.4 静态方法</h3><p><strong>定义语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 static 返回值类型 方法名 (参数列表)&#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>静态方法使用 static 关键字修饰，不可省略，供接口直接调用；</li>
<li>静态方法不能被继承，也不能被重写；</li>
<li>静态方法只能通过接口名直接调用。</li>
</ul>
<p><strong>使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span> <span class="keyword">implements</span> <span class="title">InterfaceName</span></span>&#123;</span><br><span class="line">	<span class="comment">// 重写接口方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;该工作了&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 入口测试方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		InterfaceTest ift=<span class="keyword">new</span> InterfaceTest();</span><br><span class="line">		<span class="comment">// 1.1、通过接口调用接口常量</span></span><br><span class="line">		System.out.println(InterfaceName.DRIVER_URL);</span><br><span class="line">		<span class="comment">// 1.2、通过实现类调用接口常量</span></span><br><span class="line">		System.out.println(InterfaceTest.DRIVER_URL);</span><br><span class="line">		<span class="comment">// 1.3、通过实现类对象调用接口常量</span></span><br><span class="line">		System.out.println(ift.DRIVER_URL);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2、通过实现类对象调用重写的接口方法</span></span><br><span class="line">		ift.work();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3、通过接口名来调用接口静态方法</span></span><br><span class="line">		InterfaceName.sleep();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-5-默认方法"><a href="#2-2-5-默认方法" class="headerlink" title="2.2.5 默认方法"></a>2.2.5 默认方法</h3><p><strong>定义语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 default 返回值类型 方法名 (参数列表)&#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;吃饭了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>默认方法使用 default 关键字修饰，不可省略，供子类调用；</li>
<li>默认方法可以被子类继承、同时也可以被子类重写，被子类实现时必须去除default关键字。</li>
<li>默认方法只能被实现类对象调用。</li>
<li>default方法只允许在接口中定义。</li>
</ul>
<p><strong>使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span> <span class="keyword">implements</span> <span class="title">InterfaceName</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;该工作了&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写接口默认方法，去除default关键字</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃饭了22&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 入口测试方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		InterfaceTest ift=<span class="keyword">new</span> InterfaceTest();</span><br><span class="line">		<span class="comment">// 1.1、通过接口调用接口常量</span></span><br><span class="line">		System.out.println(InterfaceName.DRIVER_URL);</span><br><span class="line">		<span class="comment">// 1.2、通过实现类调用接口常量</span></span><br><span class="line">		System.out.println(InterfaceTest.DRIVER_URL);</span><br><span class="line">		<span class="comment">// 1.3、通过实现类对象调用接口常量</span></span><br><span class="line">		System.out.println(ift.DRIVER_URL);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2、通过实现类对象调用重写的接口方法</span></span><br><span class="line">		ift.work();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3、通过接口名来调用接口静态方法</span></span><br><span class="line">		InterfaceName.sleep();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 4、通过子类对象调用重写的默认方法</span></span><br><span class="line">		ift.eat();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-接口的多实现"><a href="#2-3-接口的多实现" class="headerlink" title="2.3 接口的多实现"></a>2.3 接口的多实现</h2><h3 id="2-3-1-接口的多实现说明"><a href="#2-3-1-接口的多实现说明" class="headerlink" title="2.3.1 接口的多实现说明"></a>2.3.1 接口的多实现说明</h3><p>之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的<strong>多实现</strong>。并且，一个类能继承一个父类，同时实现多个接口。</p>
<p><strong>实现格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123; </span><br><span class="line">	// 重写接口中抽象方法【必须】 </span><br><span class="line">	// 重写接口中默认方法【不重名时可选】 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、常量</span></span><br><span class="line">	<span class="keyword">int</span> A=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 2、抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 3、静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;睡觉了A&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4、默认方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃饭了A&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、常量</span></span><br><span class="line">	<span class="keyword">int</span> A=<span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 2、抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 3、静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;睡觉了B&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4、默认方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃饭了B&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreInterfaceTest</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 必须实现所有的接口方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;该工作了&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 实现的接口默认方法重名，必须重写一次</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;重写的接口的eat()默认方法&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、实现多接口时的接口常量使用</span></span><br><span class="line">		System.out.println(InterfaceA.A);</span><br><span class="line">		System.out.println(InterfaceB.A);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2、接口抽象方法调用</span></span><br><span class="line">		MoreInterfaceTest mit=<span class="keyword">new</span> MoreInterfaceTest();</span><br><span class="line">		mit.work();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3、调用接口的静态方法</span></span><br><span class="line">		InterfaceA.sleep();</span><br><span class="line">		InterfaceB.sleep();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 4、调用默认方法</span></span><br><span class="line">		mit.eat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-2-注意事项"><a href="#2-3-2-注意事项" class="headerlink" title="2.3.2 注意事项"></a><strong>2.3.2 注意事项</strong></h3><ul>
<li>子类进行多接口实现时，如果接口常量没有重名，可以按照之前的方式进行使用；如果接口常量出现重名，就必须通过接口名调用常量。</li>
<li>子类进行多接口实现时，接口中有多个抽象方法时，实现类必须重写所有抽象方法<strong>。如果抽象方法有重名的，只需要重写一次。</strong></li>
<li>子类进行多接口实现时，接口中存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。</li>
<li>子类进行多接口实现时，接口中有多个默认方法时，实现类都可以选择继承使用。<strong>如果默认方法有重名的，必须重写一次。</strong></li>
<li>当一个类既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</li>
</ul>
<h2 id="2-4-接口的多继承【了解】"><a href="#2-4-接口的多继承【了解】" class="headerlink" title="2.4 接口的多继承【了解】"></a><strong>2.4</strong> <strong>接口的多继承【了解】</strong></h2><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。<strong>如果父接口中的默认方法有重名的，那么子接口需要重写一次。</strong>代码如下：</p>
<p><strong>定义父接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义子接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小贴士：</strong></p>
<p>子接口重写默认方法时，default关键字必须保留。</p>
<p>子类重写默认方法时，default关键字不可以保留。</p>
</blockquote>
<h1 id="第3章-接口应用-比较器"><a href="#第3章-接口应用-比较器" class="headerlink" title="第3章 接口应用-比较器"></a>第3章 接口应用-比较器</h1><p>假设现在有一个需求，将班级的学生类Student（包括String类型name和int类型age）随机存储在一个数组中，然后对该学生数组进行排序。该如何实现？</p>
<h2 id="3-1-实验测试"><a href="#3-1-实验测试" class="headerlink" title="3.1 实验测试"></a>3.1 实验测试</h2><p>这里，我们先直接使用之前学习过的数组工具类Arrays的排序方法进行排序，进行尝试，看是否可行。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 初始化学生类数组</span></span><br><span class="line">		Student[] str=<span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">		str[<span class="number">0</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;tom&quot;</span>,<span class="number">22</span>);</span><br><span class="line">		str[<span class="number">1</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;kitty&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		str[<span class="number">2</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;Jacklove&quot;</span>,<span class="number">23</span>);</span><br><span class="line">		str[<span class="number">3</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;uzi&quot;</span>,<span class="number">23</span>);</span><br><span class="line">		str[<span class="number">4</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;tom&quot;</span>,<span class="number">17</span>);</span><br><span class="line">		<span class="comment">// 打印原生数组</span></span><br><span class="line">		System.out.println(Arrays.toString(str));		</span><br><span class="line">		<span class="comment">// 工具类默认排序</span></span><br><span class="line">		Arrays.sort(str);</span><br><span class="line">		<span class="comment">// 排序后再次打印</span></span><br><span class="line">		System.out.println(Arrays.toString(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p><strong>执行效果：</strong></p>
<p><img src="/2021/07/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20200624114302432.jpg">)</p>
<p><strong>问题分析：</strong>从执行结果可以看出，最开始正确初始化并打印了学生类数组且按照初始化的顺序打印结果。但是，在使用Arrays工具类默认排序方法sort()进行排序时出现“com.hopu.study.Student cannot be cast to java.lang.Comparable”的错误。错误的意思是，学生类Student无法转换为Comparable。</p>
<p>为什么出现这种错误？我们之前对字符串String类型数组，还有int类型数组排序都没有问题，这是为什么呢？这里，我们以String为例可以参考下String类的源码。</p>
<p><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20200624114656344.jpg"></p>
<p><img src="/2021/07/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20200624114726691.jpg"></p>
<p>同时，查看Comparable源码。</p>
<p><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20200624114947809.jpg"></p>
<p>查看String类与Comparable接口源代码，同时参考对应的注释说明以及相关资料可以明白：</p>
<ul>
<li>Comparable接口是Java提供的一个类排序比较器，默认只有一个compareTo()抽象方法；</li>
<li>Java内部提供的数据类型默认已经实现了Comparable接口，可以实现默认排序；</li>
<li>其他自定义类要实现排序，可以手动排序或者实现Comparable接口并重写compareTo()抽象方法。</li>
</ul>
<h2 id="3-2-比较器介绍"><a href="#3-2-比较器介绍" class="headerlink" title="3.2 比较器介绍"></a>3.2 比较器介绍</h2><p>Java中针对类对象的排序比较，提供了两个对应的接口Comparable和Comparator。</p>
<h3 id="3-2-1-Comparable接口比较器"><a href="#3-2-1-Comparable接口比较器" class="headerlink" title="3.2.1 Comparable接口比较器"></a>3.2.1 Comparable接口比较器</h3><p>Comparable的中文意思就是可被排序的，代表本身支持排序功能。只要我们的类实现了这个接口，那么这个类的对象就会自动拥有了可被排序的能力。而且这个排序被称为类的自然顺序。这个类的对象的列表可以被Collections.sort和Arrays.sort来执行排序。同时这个类的实例具备作为sorted map的key和sorted set的元素的资格。</p>
<p>Comparable接口内部只有一个比较方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int compareTo(T o);</span><br></pre></td></tr></table></figure>

<p>这个方法主要就是为了定义我们的类所要排序的方式。compareTo方法用于比较当前元素a与指定元素b，结果为int值，如果a &gt; b，int&gt;0；如果a=b，int=0；如果a&lt;b，int&lt;0。</p>
<h3 id="3-2-2-Comparator接口比较器"><a href="#3-2-2-Comparator接口比较器" class="headerlink" title="3.2.2 Comparator接口比较器"></a>3.2.2 Comparator接口比较器</h3><p>Comparator中文译为比较器，它可以作为一个参数传递到Collections.sort和Arrays.sort方法来指定某个类对象的排序方式。同时它也能为sorted set和sorted map指定排序方式。</p>
<p>Comparator接口内部只有一个比较方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int compare(T o1, T o2);</span><br></pre></td></tr></table></figure>



<p>Comparable可以看做是内部比较器，Comparator可以看做是外部比较器。一个类，可以通过实现Comparable接口来自带有序性，也可以通过额外指定Comparator来附加有序性， 二者的作用其实是一致的。</p>
<h2 id="3-3-比较器使用"><a href="#3-3-比较器使用" class="headerlink" title="3.3 比较器使用"></a>3.3 比较器使用</h2><p>下面，使用Comparable和Comparator两种比较器的方式完成上述Student类型数组的比较排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义比较器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 初始化学生类数组</span></span><br><span class="line">		Student[] str=<span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">		str[<span class="number">0</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;tom&quot;</span>,<span class="number">22</span>);</span><br><span class="line">		str[<span class="number">1</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;kitty&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		str[<span class="number">2</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;Jacklove&quot;</span>,<span class="number">23</span>);</span><br><span class="line">		str[<span class="number">3</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;uzi&quot;</span>,<span class="number">23</span>);</span><br><span class="line">		str[<span class="number">4</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;tom&quot;</span>,<span class="number">17</span>);</span><br><span class="line">		<span class="comment">// 打印原生数组</span></span><br><span class="line">		System.out.println(Arrays.toString(str));		</span><br><span class="line">		<span class="comment">// 使用比较器默认排序</span></span><br><span class="line">		Arrays.sort(str);</span><br><span class="line">		<span class="comment">// 排序后再次打印</span></span><br><span class="line">		System.out.println(Arrays.toString(str));</span><br><span class="line">		<span class="comment">// 使用比较器排序</span></span><br><span class="line">		Arrays.sort(str, <span class="keyword">new</span> MyComparator());</span><br><span class="line">		<span class="comment">// 排序后再次打印</span></span><br><span class="line">		System.out.println(Arrays.toString(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之方法</title>
    <url>/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="面向对象之方法"><a href="#面向对象之方法" class="headerlink" title="面向对象之方法"></a>面向对象之方法</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>掌握方法的定义与使用</li>
<li>掌握方法的参数传递</li>
<li>掌握方法重载的定义与使用</li>
<li>掌握方法的可变参数定义及使用</li>
<li>掌握方法的可变参数定义及使用</li>
<li>掌握递归算法以及其他优缺点</li>
<li>掌握构造方法的定义及使用</li>
</ol>
<h2 id="1方法"><a href="#1方法" class="headerlink" title="1方法"></a>1方法</h2><p><strong>方法：</strong>就是将具有<strong>独立功能</strong>的代码块组织成为一个整体，使具有特殊功能的代码集</p>
<p><strong>作用：</strong>提高代码的复用性，解决代码冗余的现象，同时还封装了一个类应有的行为特性</p>
<h3 id="1-1方法定义"><a href="#1-1方法定义" class="headerlink" title="1.1方法定义"></a>1.1方法定义</h3><p><strong>语法：</strong></p>
<p><img src="/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/image-20210720141047422.jpg"></p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">访问权限修身符 静态修饰符 返回值类型 方法名(参数类型 参数名，参数类型 参数名...)&#123;</span><br><span class="line">	代码块...</span><br><span class="line">	<span class="keyword">return</span> 返回语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><p><strong>访问权限修饰符：</strong>控制方法的可用方法，包括有public、protected、default  、private，<strong>通常方法</strong>的权限修饰符都为public。</p>
</li>
<li><p><strong>静态修饰符：</strong>定义了改方法可以被访问，其关键字为static(静态)。如果方法前有static关键字，不用创建类对象直接使用类就可以直接访问；如果没有static关键字，必须创建出具体的对象，使用对象才能访问</p>
</li>
<li><p><strong>返回值类型：</strong>方法执行完成后的返回结果类型</p>
</li>
<li><p><strong>方法名：</strong>通常用<strong>小驼峰命名法</strong>命名，<strong>见名知意</strong></p>
</li>
<li><p><strong>参数类型：</strong> 定义的方法可能需要传递一个动态的数据，可以用方法参数进行接收。其中，参数类型表示限定了当前方法允许接收的参数类型。</p>
</li>
<li><p><strong>参数名：</strong>与参数类型是一一对应的，用来接收调用方法时传递的参数值。参数类型与参数名统称为参数列表，多个参数列表直接可以用逗号“，”分隔。</p>
</li>
<li><p><strong>代码块：</strong>一个方法具体要干的事</p>
</li>
<li><p><strong>return：</strong>方法中的执行代码执行后要返回的结果。如果有返回值，就用“return 返回的结果”来表示；如果没有要返回的结果，可以直接用一个return关键字即可，甚至可以省略。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、普通无参、无返回值方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是一个普通的无参、无返回值方法&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;  <span class="comment">// 无返回值方法，return关键字可以省略</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2、普通有参、无返回值方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=a+b;</span><br><span class="line">		System.out.println(a+<span class="string">&quot;与&quot;</span>+<span class="string">&quot;b的和为：&quot;</span>+sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3、普通有参数、有返回值的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max=a&gt;b ? a : b;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4、静态有参数、有返回值的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAbs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -a;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2定义方法注意事项"><a href="#1-2定义方法注意事项" class="headerlink" title="1.2定义方法注意事项"></a>1.2定义方法注意事项</h3><ul>
<li><p><strong>方法不能嵌套定义</strong><br>方法只能定义在类中，不支持在方法中再嵌套定义方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       		<span class="comment">// 这里会引发编译错误!!!</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>返回值类型，必须和return语句返回的类型相同或者比返回值类型范围小，否则编译失效</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值类型要求是int</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;<span class="comment">// 正确，int类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.2</span>;<span class="comment">// 错误，类型不匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 错误，类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>不能在return后面写代码，</strong>return意味着方法结束，所以后面的代码永远不会执行，属于无效代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> a + b;</span><br><span class="line">  	System.out.println(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">// 错误，return已经结束，这里不会执行，无效代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>void表示无返回值，可以省略returnn,也可以单独的书写return,后面不加数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;	 <span class="comment">// 也可以省略return，后续不能编写其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-main方法详解"><a href="#2-main方法详解" class="headerlink" title="2. main方法详解"></a>2. main方法详解</h2><p>在java中，main方法是<strong>java应用程序的入口方法</strong>，也就是说，程序在运行的时候，<strong>第一个执行</strong>的方法就是main()方法，这个方法和其他的方法有很大的不同，比如<strong>方法的名字必须是main</strong>,方法<strong>必须是public static void 类型的，方法必须接收一个字符串数组</strong>的参数等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello Word&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/image-20200612142638138.jpg"></p>
<p><strong>说明：</strong></p>
<ul>
<li><p><strong>为什么是公共的(public)</strong></p>
<p>Java设计了几个访问修饰符，包括：private、default 、protected、public。 在Java中声明为public的任何方法或变量都可以从该类的外部访问。 而JVM访问main方法显然不是在类的内部访问，因此main方法需要定义为public的方法。</p>
</li>
<li><p><strong>为什么是静态的(static)</strong></p>
<p>静态可以让JVM调用main方法的时候更加方便，不需要通过对象调用。关于static关键字我们知道的是，static关键字修饰的方法，可以不用通过创建一个实例去访问，而是可以通过类名直接访问。并且static修饰的方法以及变量存储在虚拟机当中的方法区当中，而非堆内存当中。那么，对于虚拟机来说也是一样的道理。main方法定义为static的，则对于虚拟机来说，在程序启动之后并不需要创建一个实例，就可以去调用这个main方法。</p>
</li>
<li><p><strong>为什么没有返回值</strong></p>
<p>void表示main方法没有返回值，没有返回值的原因是因为Java不需要main方法向操作系统返回退出信息。如果main方法正常退出，那么Java应用层序的退出代码为0，表示成功的运行了程序。</p>
</li>
<li><p><strong>main</strong></p>
<p>main的名称不能变是为了JVM能够识别程序运行的起点，main方法可以被重载，重载的main方法不会被执行。main方法作为程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程，非守护线程和守护线程，main方法属于非守护线程，守护线程通常由JVM自己使用，Java程序也可以表明自己的线程是守护线程。当程序中所有的非守护线程终止时，JVM退出。也可以用Runtime类或者System.exit()来退出。</p>
</li>
<li><p><strong>String [] args</strong></p>
<p>String[] args,是main方法中唯一可以改变的地方！args是arguments的缩写，只是一个变量默认名，习惯性写作它，但是也可以改变的，只要符合命名规则随便你写成什么。在使用集成开发工具的今天，String[] args更像是一种摆设了，很多初学者都不知道它的作用，其实它是程序运行传入的一个参数组。</p>
</li>
</ul>
<h2 id="3-方法调用"><a href="#3-方法调用" class="headerlink" title="3.方法调用"></a>3.方法调用</h2><h3 id="3-1基本介绍"><a href="#3-1基本介绍" class="headerlink" title="3.1基本介绍"></a>3.1基本介绍</h3><p>方法在前面介绍过，其实就是类的一个行为，所以，要调用具体的一个行为，就需要说明执行哪个具体对象的方法。因此，标准的方法调用，应该是先创建对象，然后使用对象来调用具体的方法。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建具体的Student对象</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//接着，使用对象来调用具体方法</span></span><br><span class="line">s.run(<span class="string">&quot;tom&quot;</span>,<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>我们在定义方法时可以使用static关键字将方法定义为静态方法，此时，如果在要调用类中的方法，可以省略创建对象的步骤，直接用类名调用即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于类中的static静态方法，直接使用类名调用即可</span></span><br><span class="line">Student.study();</span><br></pre></td></tr></table></figure>

<h3 id="3-2无参无返回值的方法调用"><a href="#3-2无参无返回值的方法调用" class="headerlink" title="3.2无参无返回值的方法调用"></a>3.2无参无返回值的方法调用</h3><p>调用格式：</p>
<ul>
<li><p>不同类的方法调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.普通方法名();</span><br><span class="line">类名.静态方法名();</span><br></pre></td></tr></table></figure></li>
<li><p>同类方法调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.方法名();   <span class="comment">// this关键字可以省略</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、调用其他类的具体方法</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.run(<span class="string">&quot;tom&quot;</span>,<span class="number">123</span>);</span><br><span class="line">Student.study();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、调用本类中的相关方法</span></span><br><span class="line">method();</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/image-20200612144746473.jpg"></p>
</li>
</ul>
<p><strong>总结：</strong>每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。</p>
<h3 id="3-3有参无返回值的方法调用"><a href="#3-3有参无返回值的方法调用" class="headerlink" title="3.3有参无返回值的方法调用"></a>3.3有参无返回值的方法调用</h3><p><strong>调用格式：</strong></p>
<ul>
<li><p>不同类的方法调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.普通方法名(参数<span class="number">1</span>,参数<span class="number">2</span>)；</span><br><span class="line">类名.静态方法名(参数<span class="number">1</span>,参数<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>同类方法调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.方法名(参数<span class="number">1</span>,参数<span class="number">2</span>);   <span class="comment">// this关键字可以省略</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/image-20200612145130906.jpg"></p>
<h3 id="3-4有返回值的方法调用"><a href="#3-4有返回值的方法调用" class="headerlink" title="3.4有返回值的方法调用"></a>3.4有返回值的方法调用</h3><p><strong>调用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 方法名 ( 参数 ) ;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result = getSum(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>方法的返回值通常会使用变量接收，否则该返回值将无意义。</p>
<p><img src="/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/image-20200612145345833.jpg"></p>
<h2 id="4-方法的参数传递"><a href="#4-方法的参数传递" class="headerlink" title="4.方法的参数传递"></a>4.方法的参数传递</h2><p>可以理解当我们要调用一个方法时，我们会把指定的数值，传递给方法中的参数，这样方法中的参数就拥有了这个指定的值，可以使用该值，在方法中运算了。这种传递方式，我们称为参数传递。</p>
<ul>
<li>在这里，定义方法时，参数列表中的变量，我们称为形式参数</li>
<li>调用方法时，传入给方法的数值，我们称为实际参数</li>
</ul>
<h3 id="4-1基本数据类型作为形参"><a href="#4-1基本数据类型作为形参" class="headerlink" title="4.1基本数据类型作为形参"></a>4.1基本数据类型作为形参</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标：基本数据类型作为方法的形式参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);  <span class="comment">//a = 10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);  <span class="comment">//b = 20</span></span><br><span class="line">        change(a,b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);  <span class="comment">//a = 10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);  <span class="comment">//b = 20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本数据类型 int,int 作为方法的形式参数 （形参）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        x += <span class="number">100</span>;</span><br><span class="line">        y += <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/image-20210720153051262.jpg"></p>
<p><strong>小结：如果方法的参数是基本数据类型，那么形式参数在方法当中的变化，不会影响实际参数。</strong></p>
<h3 id="4-2引用数据类型作为形参"><a href="#4-2引用数据类型作为形参" class="headerlink" title="4.2引用数据类型作为形参"></a>4.2引用数据类型作为形参</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标：引用数据类型作为方法的形式参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;</span><br><span class="line">                <span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        change(array);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用数据类型 int[] 作为方法的形式参数 （形参）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        array[<span class="number">0</span>] += <span class="number">100</span>;</span><br><span class="line">        array[<span class="number">2</span>] += <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/image-20210720155215537.jpg"></p>
<p><strong>小结：如果方法的参数是引用数据类型，形参在方法当中的变化，会影响到实参</strong></p>
<h2 id="5-方法重载"><a href="#5-方法重载" class="headerlink" title="5.方法重载"></a>5.方法重载</h2><ul>
<li><p><strong>方法重载：</strong>指在<strong>同一个类</strong>中，允许存在一个以上的<strong>同名方法</strong>，只要它们的<strong>参数列表不同</strong>即可，<strong>与修饰符和返回值无关</strong></p>
</li>
<li><p>注意</p>
<ul>
<li><p>参数列表：个数不同，数据类型不同，顺序不同</p>
</li>
<li><p>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">double</span> d)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-可变参数"><a href="#6-可变参数" class="headerlink" title="6.可变参数"></a>6.可变参数</h2><p><strong>目的</strong>：用于解决实际情况中类型相同，个数不确定的情况。</p>
<p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getSum(<span class="keyword">int</span>... v);</span><br><span class="line">getOrder(String a,<span class="keyword">int</span>... ids);</span><br></pre></td></tr></table></figure>

<p><strong>例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getSum(<span class="keyword">int</span>... v);</span><br><span class="line">getOrder(String a,<span class="keyword">int</span>... ids);</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><p>当需求设计方法时，方法的部分参数类型一致且个数不定，就可以使用java的可变变参数定义方法</p>
</li>
<li><p>定义可变参数方法时，允许加入其它类型的固定参数列表，且可变参数<strong>必须放在最后</strong></p>
</li>
<li><p>在方法中定义可变参数后，我们可以像操作数组一样操作该参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VariableParamTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rs1= getSum();</span><br><span class="line">		System.out.println(rs1);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> rs2= getSum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		System.out.println(rs2);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义一个可变参数方法，求取n个整数之和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... numbers)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">			sum+=numbers[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-递归方法"><a href="#7-递归方法" class="headerlink" title="7.递归方法"></a>7.递归方法</h2><p>递归算法：</p>
<p>（英语：recursion algorithm）在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/9132">计算机科学</a>中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念。绝大多数<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131">编程语言</a>支持<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912">函数</a>的自调用，在这些语言中函数可以通过调用自身来进行递归。<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/3729830">计算理论</a>可以证明递归的作用可以完全取代<a href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF">循环</a>，因此在很多<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">函数编程语言</a>（如<a href="https://baike.baidu.com/item/Scheme">Scheme</a>）中习惯用递归来实现循环。</p>
<p>示例：<br>求N!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*5!=5*4!</span></span><br><span class="line"><span class="comment">*4!=4*3!</span></span><br><span class="line"><span class="comment">*3!=3*2!</span></span><br><span class="line"><span class="comment">*2!=2*1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用递归方法，求n的阶乘</span></span><br><span class="line">		<span class="keyword">int</span> res=getRecursive(<span class="number">5</span>);</span><br><span class="line">		System.out.println(res);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归方法，求n的阶乘</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRecursive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>) &#123; <span class="comment">// 如果为1的时候，就跳出，不再递归</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			 <span class="comment">// n非1的情况下，继续调用本身，获取前一个数的递归结果</span></span><br><span class="line">			 <span class="keyword">int</span> res=n*getRecursive(n-<span class="number">1</span>);</span><br><span class="line">			 <span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/image-20200616114031766.jpg"></p>
<p>内存图</p>
<p><img src="/2021/07/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%96%B9%E6%B3%95/image-20210721101118194.jpg"></p>
<p><strong>步骤:</strong></p>
<ol>
<li><p>写个方法  递归是方法自己调用自己，说到递归，必须有方法</p>
</li>
<li><p>找到规律  罗列几项内容，通过罗列出来的数据，观察思考，找到规律</p>
</li>
<li><p>找到出口  什么时候，递归可以结束</p>
</li>
</ol>
<p><strong>优缺点：</strong></p>
<ul>
<li><p>优点</p>
<ul>
<li>递归方法可以重复使用方法，少量代码，即可实现复杂功能的代码</li>
</ul>
</li>
<li><p>缺点</p>
<p>消耗内存，容易造成栈内存溢出</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>递归方法<strong>一定要有出口</strong>,否则无限递归调用，直到出现StackOverflowError（栈内存溢出）错误；</li>
<li>递归方法的递归次数也不能过多，否则同样出现StackOverflowError(栈内存溢出)错误</li>
</ul>
<h2 id="8-构造方法"><a href="#8-构造方法" class="headerlink" title="8.构造方法"></a>8.构造方法</h2><p>**定义:**就是类构造对象时调用的方法，主要用于来实例化对象。构造方法分为有参构造，无参构造，</p>
<p>说明：</p>
<ul>
<li><p>构造方法是类的一个特殊成员方法；</p>
</li>
<li><p>作用</p>
<ul>
<li>构造出来一个类的实例</li>
<li>对构造出来个一个类的实例（对象）初始化；[给成员变量赋值]</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>构造方法的名字必须与定义他的<strong>类名完全相同，没有返回类型，甚至连void也没有</strong></li>
<li>类中<strong>必定有</strong>构造方法，若不写，系统自动提供一个无参构造方法；而<strong>一旦提供了有参构造方法</strong>，就<strong>不再提供默认的无参构造方法</strong></li>
<li>构造方法存在重载，比如无参构造方法和有参构造方法</li>
</ul>
</li>
<li><p>构造方法就是来创建对象的，使用new关键字，然后根据提供的构造方法进行选择构造即可。</p>
</li>
</ul>
<p><strong>格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名称()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 成员变量</span></span><br><span class="line">	String username; </span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是一个无参构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.username = username;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是一个有参构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成员方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">		System.out.println(username+<span class="string">&quot;在学习&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法使用语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、无参构造方法进行对象创建，创建的对象属性只有默认的初始化值</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、有参构造方法进行对象创建，创建时可以进行对象属性赋值</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(属性值<span class="number">1</span>,属性值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、通过无参构造方法创建对象</span></span><br><span class="line">		Student stu1 =<span class="keyword">new</span> Student();</span><br><span class="line">		System.out.println(stu1.username);</span><br><span class="line">		System.out.println(stu1.age);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 2、通过有参构造方法创建对象</span></span><br><span class="line">		Student stu2 =<span class="keyword">new</span> Student(<span class="string">&quot;李师师&quot;</span>,<span class="number">20</span>);</span><br><span class="line">		System.out.println(stu2.username);</span><br><span class="line">		System.out.println(stu2.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>错题集1</title>
    <url>/2021/08/02/%E9%94%99%E9%A2%98%E9%9B%861/</url>
    <content><![CDATA[<h1 id="错题集1"><a href="#错题集1" class="headerlink" title="错题集1"></a>错题集1</h1><h2 id="1-以下说法描述当中，正确的是"><a href="#1-以下说法描述当中，正确的是" class="headerlink" title="1.以下说法描述当中，正确的是()"></a>1.以下说法描述当中，正确的是()</h2><p>A.  Java面向对象的三大特性是 封装，继承，接口。</p>
<p>B.  Java支持多继承</p>
<p>C.  Java抽象类当中，没有构造方法。</p>
<p>D. Java继承当中，创建子类对象的时候，必须执行父类构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目正确答案是： D</span><br><span class="line">答案解析：</span><br><span class="line">A Java面向对象的三大特性是封装，继承，多态</span><br><span class="line">B Java只能单继承，</span><br><span class="line">C Java的抽象类，有构造方法。目的是为了在创建子类对象的时候，给父类成员变量初始化数据</span><br><span class="line">D java继承当中，创建子类对象的时候，目的是为了在创建子类对象的时候，给父类成员变量初始化数据。</span><br></pre></td></tr></table></figure>

<h2 id="2-以下说法描述中，错误的是"><a href="#2-以下说法描述中，错误的是" class="headerlink" title="2. 以下说法描述中，错误的是()"></a>2. 以下说法描述中，错误的是()</h2><p>A.  Calendar类的使用，需要创建对象，在调用方法</p>
<p>B.  Object类是所有类的父类，它里面的所有方法，都可以被子类使用</p>
<p>C.  Integer类是int类型的包装类，可以完成字符串类型转化成int的操作</p>
<p>D.  如果一个类，想要进行排序操作，则需要实现Comparable接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目正确答案是： A</span><br><span class="line">A. Calendar类是抽象类，不能创建对象，Calendar.getInstance创建的对象是其子类的对象</span><br><span class="line">B. Object是所有类的父类，它里面有public 和protected方法，只有一个private方法，但是其被静态方法引用，在创建对象的时候，先执行父类的构造方法，改私有类就被调用了</span><br><span class="line">C. 字符串转换int类型的方式是  Integer.parseInt(&quot;520&quot;);</span><br><span class="line">D. 内部比较器，使用的就是   Comparable接口 需要重写 compareTo()方法</span><br></pre></td></tr></table></figure>

<h2 id="3-观察下面代码，请分析，请问答案是（-）"><a href="#3-观察下面代码，请分析，请问答案是（-）" class="headerlink" title="3.观察下面代码，请分析，请问答案是（  ）"></a>3.观察下面代码，请分析，请问答案是（  ）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//问题: 这里创建了几个对象?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>A. 1个对象</p>
<p>B.  2个对象</p>
<p>C. 3个对象</p>
<p>D. 1个或两个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目正确答案： B</span><br><span class="line">答案解析：</span><br><span class="line">    第一个指的是 new 出来的 String 对象，直接存放在 堆内存当中。  </span><br><span class="line">    第二个指的是 &quot;abc&quot; 字符串胡对象，存在于 堆内存的常量池当中。</span><br></pre></td></tr></table></figure>

<h4 id="4-观察下面代码，说明结果，解释原因？"><a href="#4-观察下面代码，说明结果，解释原因？" class="headerlink" title="4.观察下面代码，说明结果，解释原因？"></a>4.观察下面代码，说明结果，解释原因？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String  s1  = “ab”;</span><br><span class="line">String  s2  = “c”</span><br><span class="line">String  s3  = “ab” + “c”;</span><br><span class="line">String  s4  = s1 + s2;</span><br><span class="line">请问： s3 == s4 执行的结果是什么？为什么？</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">说明：s3 是常量相加。直接加，会在堆内存的常量池当中的地址。</span><br><span class="line">s4是变量相加，相加的过程，实际上会创建新的对象，是堆内存的地址。（备注：底层是StringBuilder的append方法）</span><br></pre></td></tr></table></figure>

<h2 id="5-和-equals-的区别是什么"><a href="#5-和-equals-的区别是什么" class="headerlink" title="5.== 和 equals 的区别是什么?"></a>5.== 和 equals 的区别是什么?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">== 等于比较运算符,如果进行比较的两个操作数都是基本数据类型,即使他们的数据类型不相同,只要他们的值相等,也都将返回true.如果两个操作数都是引用类型,那么只有当两个引用变量的类型具有父子关系时才可以比较,而且这两个引用必须指向同一个对象,才会返回true.(在这里我们可以理解成==比较的是两个变量的内存地址)</span><br><span class="line"></span><br><span class="line">equals()方法是Object类的方法,在Object类中的equals()方法体内实际上返回的就是使用==进行比较的结果.但是我们知道所有的类都继承Object,而且Object中的equals()方法没有使用final关键字修饰,那么当我们使用equal()方法进行比较的时候,我们需要关注的就是这个类有没有重写Object中的equals()方法.</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2021/08/03/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、了解异常和错误的区别</span><br><span class="line">2、了解异常的分类</span><br><span class="line">3、掌握异常的捕获跟处理</span><br><span class="line">3、掌握自定义异常</span><br></pre></td></tr></table></figure>

<h1 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>​     正常情况下，小王从家里去上班，路上大概需要1个小时。</p>
<p><img src="/1609745117928.jpg"></p>
<p>但是，偶尔总会有各种情况发生，比如堵车、撞车等。这就是上班过程中的异常行为。</p>
<p><img src="/1609745140833.jpg" alt="1609745140833"></p>
<p>​        生活中我们有各种异常情况发生，我们写的程序也同样有各种异常情况发生。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> i = input.nextInt();</span><br></pre></td></tr></table></figure>

<p>当用户控制台输入非数字的字符时，程序就出现异常情况了。</p>
<p>​        那么什么是异常呢？异常是指在程序的运行过程中所发生的不正常的事件，它会中断正在运行 </p>
<p>的程序。Java提供了一套处理异常情况的机制，我们可以使用这套机制为程序提供了错误处理的能力。好比上班堵车了就需要等待或者绕行，撞车了就需要交警跟保险处理，然后再去上班。 </p>
<h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p><img src="/2021/08/03/%E5%BC%82%E5%B8%B8/wps1.jpg" alt="wps1"></p>
<p>​        通过上面的异常体系图中我们可以发现，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>。</p>
<ul>
<li><strong>Error</strong>： 严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒。</li>
</ul>
<p>​    由于Error无法避免，我们上面说的异常处理机制主要是针对Exception。</p>
<h2 id="1-3-异常的分类"><a href="#1-3-异常的分类" class="headerlink" title="1.3 异常的分类"></a>1.3 异常的分类</h2><p>​    Exception又可以分为2类，编译异常跟运行时异常。</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li>
</ul>
<h2 id="1-4-异常的处理"><a href="#1-4-异常的处理" class="headerlink" title="1.4 异常的处理"></a>1.4 异常的处理</h2><p>Java异常处理的五个关键字：try、catch、finally、throw、throws</p>
<h4 id="1-4-1-throw抛出异常"><a href="#1-4-1-throw抛出异常" class="headerlink" title="1.4.1 throw抛出异常"></a>1.4.1 throw抛出异常</h4><p>​        在JAVA中，可以通过throw关键字来抛出一个指定的异常对象。throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
<ul>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throw new 异常类名(描述信息);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> element = getElement(arr, index);</span><br><span class="line">        System.out.println(element);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">// 当数组下表越界时抛出下标越界异常</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;blb提醒您，数组下标已越界。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        throw抛出去的异常给谁了呢？谁调用谁处理，一层层往上找，没人处理则由JVM处理。</p>
<h4 id="1-4-2-throws声明异常"><a href="#1-4-2-throws声明异常" class="headerlink" title="1.4.2 throws声明异常"></a>1.4.2 throws声明异常</h4><p>​        throws用于方法上，表示此方法中出现的异常自己不处理，丢给调用者来处理。就像小孩子之间发生了矛盾自己解决不了，由父母来负责处理。当然父母也可以不处理继续上抛，交给爷爷奶奶来处理。</p>
<ul>
<li> 语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;	</span><br></pre></td></tr></table></figure>

<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    Date date = format.parse(<span class="string">&quot;2020-10-10&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="1-4-3-try-catch捕获异常"><a href="#1-4-3-try-catch捕获异常" class="headerlink" title="1.4.3 try-catch捕获异常"></a>1.4.3 try-catch捕获异常</h4><p>​        刚刚我们都是在抛出异常，那如何进行捕获跟处理异常呢？通过try catch块进行异常的捕获跟处理。 </p>
<ul>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">     代码</span><br><span class="line">&#125;catch(异常类型  e)&#123;</span><br><span class="line">     发生了异常1，进行处理。     </span><br><span class="line">&#125;catch(异常类型  e)&#123;</span><br><span class="line">	 发生了异常2，进行处理。     </span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p><code>try</code>块中写编写可能产生异常的代码。</p>
<p><code>catch</code>块中用来表示发生了异常，如何进行处理的逻辑。</p>
</li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            制造一个异常。</span></span><br><span class="line">            System.out.println(<span class="number">5</span>/<span class="number">0</span>);</span><br><span class="line">            String s = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生了算术运算的异常。&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生了空指针的异常。&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips: try-catch不能单独使用，必须一起使用。</p>
<h4 id="1-4-4-finally代码块"><a href="#1-4-4-finally代码块" class="headerlink" title="1.4.4 finally代码块"></a>1.4.4 finally代码块</h4><p>​        生活中，有时候即使发生了异常情况，干扰了生活的秩序，但有些事是无论是否异常都需要完成的。比如发生了疫情，我们不能正常的聚会、娱乐。但是无论是否发生疫情我们都必须活着，我们都需要吃饭睡觉。程序也一样，有时候当代码无论是否发生了异常我们都要保证执行一些操作，比如当我们打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。可以通过<code>finally</code>代码块来实现。</p>
<ul>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">     代码</span><br><span class="line">&#125;catch(异常类型  e)&#123;</span><br><span class="line">     发生了异常1，进行处理。     </span><br><span class="line">&#125;catch(异常类型  e)&#123;</span><br><span class="line">	 发生了异常2，进行处理。     </span><br><span class="line">&#125;...</span><br><span class="line">	fianlly&#123;</span><br><span class="line">	  一定会执行的代码</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTryCatchFinally</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream fs = <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;blb.txt&quot;</span>);</span><br><span class="line">            fs = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//            无论是否发生了异常都执行关闭打开的文件流</span></span><br><span class="line">            <span class="keyword">if</span>(fs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                fs.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>tips: <code>finally</code>中的代码无论是否异常都会执行，return也无法阻止，除非使用<code>System.exit(1);</code>退出虚拟机。<code>finally</code>也不能单独使用。    </p>
</li>
</ul>
<h4 id="1-4-5-try-finally块"><a href="#1-4-5-try-finally块" class="headerlink" title="1.4.5 try-finally块"></a>1.4.5 try-finally块</h4><p>​    开发中还有一种比较少用的结果，<code>try-finally</code>结构，语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">     代码</span><br><span class="line">&#125;fianlly&#123;</span><br><span class="line">	  一定会执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTryFinally</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream fs = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;blb.txt&quot;</span>);</span><br><span class="line">        fs = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//            无论是否发生了异常都执行关闭打开的文件流</span></span><br><span class="line">        <span class="keyword">if</span>(fs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fs.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-4-6-注意事项"><a href="#1-4-6-注意事项" class="headerlink" title="1.4.6 注意事项"></a>1.4.6 注意事项</h4><ul>
<li>运行时异常被抛出可以不处理，由JVM处理。</li>
<li>多个catch块捕获多个异常且有父子关系时，子类的捕获在前面，父类的捕获在后面。</li>
<li>如果finally有return语句,永远返回finally中的结果</li>
<li>子类重写父类方法时，子类不能抛出比父类更宽泛的的异常，可以不抛出异常</li>
<li>子类不能抛出比父类更多的异常</li>
</ul>
<p><img src="/2021/08/03/%E5%BC%82%E5%B8%B8/%E6%AD%BB%E4%BA%86%E9%83%BD%E8%A6%81try.jpg" alt="死了都要try"></p>
<h4 id="1-4-7-常见异常"><a href="#1-4-7-常见异常" class="headerlink" title="1.4.7 常见异常"></a>1.4.7 常见异常</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th>异常名称</th>
<th>异常描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>java.lang.NullPointerException</td>
<td>空指针异常:对象为空，并且调用相应方法。</td>
</tr>
<tr>
<td align="center">2</td>
<td>java.lang.ClassNotFoundException</td>
<td>找不到指定类，常出现在反射中</td>
</tr>
<tr>
<td align="center">3</td>
<td>java.lang.ArrayIndexOutOfBoundsException</td>
<td>数组下标越界</td>
</tr>
<tr>
<td align="center">4</td>
<td>java.lang.NumberFormatException:</td>
<td>数字格式化异常</td>
</tr>
<tr>
<td align="center">5</td>
<td>java.lang.ArithmeticException:</td>
<td>数学运算异常</td>
</tr>
<tr>
<td align="center">6</td>
<td>java.lang.StackOverflowError</td>
<td>内存空间溢出错误，方法递归调用中，经常发生</td>
</tr>
<tr>
<td align="center">7</td>
<td>java.lang.ClassCastException</td>
<td>类型转换异常，向下转型中经常发生</td>
</tr>
<tr>
<td align="center">8</td>
<td>java.text.ParseException</td>
<td>时间格式化异常，SimpleDateFormart中经常发生</td>
</tr>
<tr>
<td align="center">9</td>
<td>java.util.InputMismatchException</td>
<td>输入类型不匹配异常</td>
</tr>
</tbody></table>
<h2 id="1-5-自定义异常"><a href="#1-5-自定义异常" class="headerlink" title="1.5 自定义异常"></a>1.5 自定义异常</h2><p>​        JAVA提供了很多异常类供我们使用，但是在实际开发中，根据业务的需求，有些异常情况是JDK没有提供的，比如年龄输入不合法等，此时我们要像JAVA一样来定义异常。</p>
<ul>
<li>自定义一个编译异常类，继承<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期异常类，继承<code>java.lang.RuntimeException</code>。</li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义一个年龄越界的运行时异常，如果要定义编译异常改为Exception即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeOutOfBoundException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeOutOfBoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeOutOfBoundException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置年龄的时候，检查如果为负数抛出此异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        setAge(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> <span class="keyword">throws</span> AgeOutOfBoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果年龄为负数抛出此异常</span></span><br><span class="line">        <span class="keyword">if</span>(age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AgeOutOfBoundException(<span class="string">&quot;年龄不能为负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8新特性之时间类</title>
    <url>/2021/08/03/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="JDK8新特性之时间类"><a href="#JDK8新特性之时间类" class="headerlink" title="JDK8新特性之时间类"></a>JDK8新特性之时间类</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><h3 id="1-1旧版的Java中，日期时间API存在的问题"><a href="#1-1旧版的Java中，日期时间API存在的问题" class="headerlink" title="1.1旧版的Java中，日期时间API存在的问题"></a>1.1旧版的Java中，日期时间API存在的问题</h3><ul>
<li><strong>非线程安全</strong> − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li><strong>设计很差</strong> −  Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li>
<li><strong>时区处理麻烦</strong> − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li>
</ul>
<h3 id="1-2Java8在java。time包下提供了很多新的API。"><a href="#1-2Java8在java。time包下提供了很多新的API。" class="headerlink" title="1.2Java8在java。time包下提供了很多新的API。"></a>1.2Java8在java。time包下提供了很多新的API。</h3><ul>
<li>Local(本地) - 简化了日期时间的处理，没有时区的问题</li>
<li>Zoned(地区) - 通过制定的时间处理日期时间</li>
</ul>
<blockquote>
<p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p>
</blockquote>
<h2 id="2-LocalDateTime"><a href="#2-LocalDateTime" class="headerlink" title="2.LocalDateTime"></a>2.LocalDateTime</h2><p>操作日期和时间</p>
<ul>
<li>日期 包括年,月,日,星期</li>
<li>时间 包括时,分,秒,毫秒</li>
</ul>
<h3 id="2-1常用API"><a href="#2-1常用API" class="headerlink" title="2.1常用API"></a>2.1常用API</h3><table>
<thead>
<tr>
<th>返回值</th>
<th>方法名</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><code>static LocalDateTime</code></td>
<td><code>now()</code></td>
<td>从默认时区的系统时钟获取当前的日期时间</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code> of(int year,int month,int dayofMonth,int hour,int minute,int second)</code></td>
<td>从年，月，日，时，分，秒获得LocalDateTime的实例</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getYear()</code></td>
<td>获取年份字段</td>
</tr>
<tr>
<td><code>Month</code></td>
<td><code>getMonth()</code></td>
<td>获取Month枚举获取月份字段</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getMonthValue()</code></td>
<td>获取月份字段从1到12</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getDayOfMonth()</code></td>
<td>获取这个月的第几天</td>
</tr>
<tr>
<td><code>DayOfWeek</code></td>
<td><code>getDayofWeek()</code></td>
<td>获取星期几(DayOfWeek枚举)</td>
</tr>
<tr>
<td><code>int </code></td>
<td><code>getHour()</code></td>
<td>获取时间字段</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getMinute()</code></td>
<td>获取分钟字段</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getSecond()</code></td>
<td>获取秒</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>minusDays(long days)</code></td>
<td>返回此 <code>LocalDateTime</code>的副本，其中指定的时间间隔以天为单位。</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>minusHours(long hours)</code></td>
<td>以指定的时间段返回此 <code>LocalDateTime</code>的副本，以减少的小时数。</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>minusMonths(long months)</code></td>
<td>返回此<code>LocalDateTime</code>的副本，指定的时间以月为单位减去。</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusDays(long days)</code></td>
<td>返回此 <code>LocalDateTime</code>的副本，并以指定的时间段添加天数。</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusMonths(long months)</code></td>
<td>返回这个 <code>LocalDateTime</code>的副本，其中指定的时间段以月为单位</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>with(TemporalField field,  long newValue</code></td>
<td>返回此日期时间的副本，并将指定的字段设置为新值。</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>format(DateTimeFormatter formatter)</code></td>
<td>使用指定的格式化程序格式化此日期时间。</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code>parse(CharSequence text, DateTimeFormatter formatter)</code></td>
<td>使用特定的格式化 <code>LocalDateTime</code>从文本字符串获取 <code>LocalDateTime</code>的实例。</td>
</tr>
</tbody></table>
<h3 id="2-2举例"><a href="#2-2举例" class="headerlink" title="2.2举例"></a>2.2举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前时间</span></span><br><span class="line">       LocalDateTime now = LocalDateTime.now();</span><br><span class="line">       System.out.println(<span class="string">&quot;now = &quot;</span> + now);<span class="comment">//now = 2021-08-03T19:43:02.639</span></span><br><span class="line">       <span class="comment">//设置时间</span></span><br><span class="line">       LocalDateTime of = LocalDateTime.of(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;of = &quot;</span> + of);<span class="comment">//of = 2018-08-08T08:08:08</span></span><br><span class="line">       <span class="comment">//获取当前的年份</span></span><br><span class="line">       <span class="keyword">int</span> year = now.getYear();</span><br><span class="line">       System.out.println(<span class="string">&quot;year = &quot;</span> + year);<span class="comment">//year = 2021</span></span><br><span class="line">       <span class="comment">//获取当前的月份</span></span><br><span class="line">       Month month = now.getMonth();</span><br><span class="line">       System.out.println(<span class="string">&quot;month = &quot;</span> + month);<span class="comment">//month = AUGUST [返回的是Month枚举]</span></span><br><span class="line">       <span class="comment">//获取当前月份</span></span><br><span class="line">       <span class="keyword">int</span> monthValue = now.getMonthValue();</span><br><span class="line">       System.out.println(<span class="string">&quot;monthValue = &quot;</span> + monthValue);<span class="comment">//monthValue = 8</span></span><br><span class="line">       <span class="comment">//获取这个月的第几天</span></span><br><span class="line">       <span class="keyword">int</span> dayOfMonth = now.getDayOfMonth();</span><br><span class="line">       System.out.println(<span class="string">&quot;dayOfMonth = &quot;</span> + dayOfMonth);<span class="comment">//dayOfMonth = 3</span></span><br><span class="line">       <span class="comment">//获取这周的星期几</span></span><br><span class="line">       DayOfWeek dayOfWeek = now.getDayOfWeek();</span><br><span class="line">       System.out.println(<span class="string">&quot;dayOfWeek = &quot;</span> + dayOfWeek);<span class="comment">//dayOfWeek = TUESDAY [DayOfWeek枚举]</span></span><br><span class="line">       <span class="comment">//获取这周的星期几</span></span><br><span class="line">       <span class="keyword">int</span> value = now.getDayOfWeek().getValue();</span><br><span class="line">       System.out.println(<span class="string">&quot;value = &quot;</span> + value);<span class="comment">//value = 2</span></span><br><span class="line">       <span class="comment">//往后推两天</span></span><br><span class="line">       LocalDateTime localDateTime = now.plusDays(<span class="number">2</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;localDateTime = &quot;</span> + localDateTime);<span class="comment">//localDateTime = 2021-08-05T19:43:02.639</span></span><br><span class="line">       <span class="comment">//往前推两个月</span></span><br><span class="line">       LocalDateTime localDateTime1 = now.minusMonths(<span class="number">2</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;localDateTime1 = &quot;</span> + localDateTime1);<span class="comment">//localDateTime1 = 2021-06-03T19:43:02.639</span></span><br><span class="line">       <span class="comment">//这个月的第3天</span></span><br><span class="line">       LocalDateTime localDateTime2 = now.withDayOfMonth(<span class="number">7</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;localDateTime2 = &quot;</span> + localDateTime2);<span class="comment">//localDateTime2 = 2021-08-07T19:43:02.639</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//时间对象 ---&gt;字符串</span></span><br><span class="line"></span><br><span class="line">       String pattern = <span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>;</span><br><span class="line">       String format = now.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">       System.out.println(<span class="string">&quot;format = &quot;</span> + format);<span class="comment">//format = 2021年08月03日 19:53:40</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//字符串 ---&gt;时间对象</span></span><br><span class="line"></span><br><span class="line">       String s1 =<span class="string">&quot;2021年08月03日 10:18:14&quot;</span>;</span><br><span class="line">       LocalDateTime parse = now.parse(s1, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">       System.out.println(<span class="string">&quot;parse = &quot;</span> + parse);<span class="comment">//parse = 2021-08-03T10:18:14</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-LocaDate"><a href="#3-LocaDate" class="headerlink" title="3.LocaDate"></a>3.LocaDate</h2><p>操作日期</p>
<h3 id="3-1常用API"><a href="#3-1常用API" class="headerlink" title="3.1常用API"></a>3.1常用API</h3><table>
<thead>
<tr>
<th align="left">返回值</th>
<th>方法名</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static LocalDate</code></td>
<td><code>now()</code></td>
<td>从默认时区的系统时钟获取当前日期</td>
</tr>
<tr>
<td align="left"><code>static LocalDate</code></td>
<td><code>of(int year,  int month, int dayOfMonth)</code></td>
<td>从一年，一个月和一天获得一个 <code>LocalDate</code>的实例。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td><code>getDayOfMonth()</code></td>
<td>获取月份字段。</td>
</tr>
<tr>
<td align="left"><code>DayOfWeek</code></td>
<td><code>getDayOfWeek()</code></td>
<td>获取星期几字段，这是一个枚举 <code>DayOfWeek</code> 。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td><code>getMonthValue()</code></td>
<td>将月份字段从1到12。</td>
</tr>
<tr>
<td align="left"><code>LocalDate</code></td>
<td><code>minusDays(long daysToSubtract)</code></td>
<td>返回此 <code>LocalDate</code>的副本，并减去指定的天数。</td>
</tr>
<tr>
<td align="left"><code>LocalDate</code></td>
<td><code>plusDays(long daysToAdd)</code></td>
<td>返回指定天数的 <code>LocalDate</code>的副本。</td>
</tr>
<tr>
<td align="left"><code>LocalDate</code></td>
<td><code>withYear(int year)</code></td>
<td>返回此日期的副本，并更改年份。</td>
</tr>
</tbody></table>
<h3 id="3-2实例"><a href="#3-2实例" class="headerlink" title="3.2实例"></a>3.2实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//      获取当前对应的日期</span></span><br><span class="line">        LocalDate now = LocalDate.now();</span><br><span class="line">        System.out.println(now);<span class="comment">//2021-08-03</span></span><br><span class="line"></span><br><span class="line">        LocalDate date = LocalDate.of(<span class="number">2020</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(date);<span class="comment">//2020-12-13</span></span><br><span class="line"><span class="comment">//      获取年份</span></span><br><span class="line">        System.out.println(now.getYear());<span class="comment">//2021</span></span><br><span class="line"><span class="comment">//       获取月份，英文</span></span><br><span class="line">        System.out.println(now.getMonth());<span class="comment">//AUGUST</span></span><br><span class="line"><span class="comment">//       获取月份值</span></span><br><span class="line">        System.out.println(now.getMonthValue());<span class="comment">//8</span></span><br><span class="line"><span class="comment">//        获取当月中的第几天，也就是几号</span></span><br><span class="line">        System.out.println(now.getDayOfMonth());<span class="comment">//3</span></span><br><span class="line"><span class="comment">//        获取当周中的第几天，也就是星期</span></span><br><span class="line">        System.out.println(now.getDayOfWeek());<span class="comment">//TUESDAY</span></span><br><span class="line"><span class="comment">//        获取年中的第几天</span></span><br><span class="line">        System.out.println(now.getDayOfYear());<span class="comment">//215</span></span><br><span class="line"><span class="comment">//        修改年份为2019</span></span><br><span class="line">        System.out.println(now.withYear(<span class="number">2019</span>));<span class="comment">//2019-08-03</span></span><br><span class="line"><span class="comment">//        修改月份为2</span></span><br><span class="line">        System.out.println(now.withMonth(<span class="number">2</span>));<span class="comment">//2021-02-03</span></span><br><span class="line"><span class="comment">//        修改日期为3号</span></span><br><span class="line">        System.out.println(now.withDayOfMonth(<span class="number">3</span>));<span class="comment">//2021-08-03</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-LocalTime"><a href="#4-LocalTime" class="headerlink" title="4.LocalTime"></a>4.LocalTime</h2><p>操作时间</p>
<p>API和上面的差不多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime time = LocalTime.of(<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>);</span><br><span class="line">        System.out.println(time);<span class="comment">//11:12:13</span></span><br><span class="line">        <span class="comment">//      获取当前时间</span></span><br><span class="line">        LocalTime now = LocalTime.now();</span><br><span class="line">        <span class="comment">//       获取小时</span></span><br><span class="line">        System.out.println(now.getHour());<span class="comment">//20</span></span><br><span class="line">        <span class="comment">//       获取分</span></span><br><span class="line">        System.out.println(now.getMinute());<span class="comment">//17</span></span><br><span class="line">        <span class="comment">//       获取秒</span></span><br><span class="line">        System.out.println(now.getSecond());<span class="comment">//10</span></span><br><span class="line">        <span class="comment">//       获取纳秒</span></span><br><span class="line">        System.out.println(now.getNano());<span class="comment">//296000000</span></span><br><span class="line">        <span class="comment">//      修改小时为12</span></span><br><span class="line">        System.out.println(now.withHour(<span class="number">12</span>));<span class="comment">//12:17:10.296</span></span><br><span class="line">        <span class="comment">//       修改分钟为22</span></span><br><span class="line">        System.out.println(now.withMinute(<span class="number">22</span>));<span class="comment">//20:22:10.296</span></span><br><span class="line">        <span class="comment">//        修改秒为33</span></span><br><span class="line">        System.out.println(now.withSecond(<span class="number">33</span>));<span class="comment">//20:17:33.296</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-相互转换"><a href="#5-相互转换" class="headerlink" title="5.相互转换"></a>5.相互转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成日期时间</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;now = &quot;</span> + now);<span class="comment">//now = 2021-08-03T20:26:07.972</span></span><br><span class="line">        <span class="comment">//转化成日期</span></span><br><span class="line">        LocalDate localDate = now.toLocalDate();</span><br><span class="line">        System.out.println(<span class="string">&quot;localDate = &quot;</span> + localDate);<span class="comment">//localDate = 2021-08-03</span></span><br><span class="line">        <span class="comment">//转化为时间</span></span><br><span class="line">        LocalTime localTime = now.toLocalTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;localTime = &quot;</span> + localTime);<span class="comment">//localTime = 20:26:07.972</span></span><br><span class="line">        <span class="comment">//将时间和日期转化为时间日期</span></span><br><span class="line">        LocalDateTime of = LocalDateTime.of(localDate, localTime);</span><br><span class="line">        System.out.println(<span class="string">&quot;of = &quot;</span> + of);<span class="comment">//of = 2021-08-03T20:26:07.972</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-日期时间差"><a href="#6-日期时间差" class="headerlink" title="6.日期时间差"></a>6.日期时间差</h2><p>K8中通过<code>Duration </code>用于计算两个“时间”间隔。通过<code>Period</code>用于计算两个“日期”间隔的类。</p>
<p><strong>Duration代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime now = LocalTime.now();</span><br><span class="line">        System.out.println(now);<span class="comment">//20:28:55.080</span></span><br><span class="line">        LocalTime time = LocalTime.of(<span class="number">17</span>,<span class="number">48</span>,<span class="number">12</span>);</span><br><span class="line">        System.out.println(time);<span class="comment">//17:48:12</span></span><br><span class="line"></span><br><span class="line">        Duration duration = Duration.between(time,now);</span><br><span class="line">        <span class="comment">//      时间差转成小时</span></span><br><span class="line">        System.out.println(duration.toHours());<span class="comment">//2</span></span><br><span class="line">        <span class="comment">//      时间差转成分钟</span></span><br><span class="line">        System.out.println(duration.toMinutes());<span class="comment">//160</span></span><br><span class="line">        <span class="comment">//      时间差转成秒</span></span><br><span class="line">        System.out.println(duration.getSeconds());<span class="comment">//9643</span></span><br><span class="line">        <span class="comment">//      时间差转成纳秒</span></span><br><span class="line">        System.out.println(duration.toNanos());<span class="comment">//9643080000000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Period代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate now = LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;now = &quot;</span> + now);<span class="comment">//now = 2021-08-03</span></span><br><span class="line">        LocalDate date = LocalDate.of(<span class="number">2030</span>,<span class="number">4</span>,<span class="number">30</span>);</span><br><span class="line">        Period period = Period.between(now,date);</span><br><span class="line">        <span class="comment">//      获取年份差</span></span><br><span class="line">        System.out.println(period.getYears());<span class="comment">//8</span></span><br><span class="line">        <span class="comment">//      获取月份差</span></span><br><span class="line">        System.out.println(period.getMonths());<span class="comment">//8</span></span><br><span class="line">        <span class="comment">//       获取日期差</span></span><br><span class="line">        System.out.println(period.getDays());<span class="comment">//27</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>JDK新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2021/08/05/IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="1-file类"><a href="#1-file类" class="headerlink" title="1. file类"></a>1. file类</h1><p>由于经常需要使用IO流来操作硬盘上的文件，JDK将硬盘上的文件映射为<code>java.io.File</code>类，所以我们先要学习如何使用这个类。</p>
<p>​    File类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</p>
<p>File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。</p>
<h2 id="1-1-常用构造方法"><a href="#1-1-常用构造方法" class="headerlink" title="1.1  常用构造方法"></a>1.1  常用构造方法</h2><table>
<thead>
<tr>
<th>创建对象格式</th>
<th>格式说明</th>
</tr>
</thead>
<tbody><tr>
<td>File   f1 = new  File(“文件或者文件夹的路径”);</td>
<td>将路径字符串，直接封装成为 File 对象</td>
</tr>
<tr>
<td>File f2 = new File(“父文件夹的路径”, “文件或文件夹的路径”);</td>
<td>将父文件夹路径和子文件或子文件夹路径，拼接成为File对象</td>
</tr>
<tr>
<td>File f3 = new File(file对象，”子文件或文件夹的路径”);</td>
<td>将file对象和子文件或子文件夹路径，拼接成为File对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> File(File parent,String child );</span><br><span class="line"><span class="keyword">new</span> File(String parent,String child);</span><br><span class="line"><span class="keyword">new</span> File(String pathName);</span><br></pre></td></tr></table></figure>

<h2 id="1-2-常用方法"><a href="#1-2-常用方法" class="headerlink" title="1.2 常用方法"></a>1.2 常用方法</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>获取文件（夹）名</td>
</tr>
<tr>
<td>String getPath()</td>
<td>获取文件（夹）路径</td>
</tr>
<tr>
<td>boolean exists()</td>
<td>文件（夹）是否存在</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>是否是一个文件</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>是否是一个目录（文件夹）</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>创建一个文件</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>创建一个具体的文件夹</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>创建多级文件夹</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>删除某个文件（夹）</td>
</tr>
<tr>
<td>String [] list()</td>
<td>返回某个文件夹下的所有文件（夹）名</td>
</tr>
<tr>
<td>File [] listFiles()</td>
<td>获取某个文件夹下所有的文件（夹）</td>
</tr>
</tbody></table>
<p><strong>概念两个路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 相对路径</span><br><span class="line">	A. 含义: 不包含盘符的路径。如果在idea当中，则相对于项目路径（省略了项目路径不写）</span><br><span class="line">	B. 例如: &quot;JavaSEDay18\\abc\\def\\A.txt&quot;   ---》 相当于在 项目路径\\JavaSEDay18\\abc\\def\\A.txt</span><br><span class="line">	C. 例如： 定浩坐在什么地方? </span><br><span class="line">			 D8存在研发八部的川哥旁边。</span><br><span class="line">			 D10存在研发八部的川哥旁边。</span><br><span class="line"></span><br><span class="line">2. 绝对路径</span><br><span class="line">	A. 含义: 包含盘符的路径。</span><br><span class="line">	B. 例如: C:\develop\workspace\java210712\JavaSEDay18\abc\def\A.txt</span><br><span class="line">	C. 例如: 定浩坐在什么地方?</span><br><span class="line">			宇宙、银河系、太阳系、地球、亚洲、中国、湖北、xxx、D8存在研发八部的川哥旁边。</span><br></pre></td></tr></table></figure>

<p><strong>listFiles注意事项</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 如果文件对象是 文件，采用 listFiles() 方法，得到的结果是：返回值是 null</span><br><span class="line">2. 如果文件对象是 空文件夹，采用 listFiles() 方法，得到的结果是： 返回值是 长度为0的数组</span><br><span class="line">3. 如果文件对象是 不存在的，采用 listFiles() 方法，得到的结果是：返回值是 null</span><br><span class="line">4. 如果文件对象是 系统权限文件夹，采用 listFiles() 方法，得到的结果是：返回值是 null </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06File</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:/a.txt&quot;</span>);</span><br><span class="line"><span class="comment">//      输出个文件是否存在</span></span><br><span class="line">        System.out.println(file.exists());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line"><span class="comment">//            创建这个文件</span></span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        判断这个文件是否是文件</span></span><br><span class="line">        System.out.println(file.isFile());</span><br><span class="line"><span class="comment">//        判断这个文件是否是目录</span></span><br><span class="line">        System.out.println(file.isDirectory());</span><br><span class="line"><span class="comment">//        输出文件的名字</span></span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line"><span class="comment">//        输出文件的路径</span></span><br><span class="line">        System.out.println(file.getPath());</span><br><span class="line"><span class="comment">//        输出文件的绝对路径</span></span><br><span class="line">        System.out.println(file.getAbsolutePath());</span><br><span class="line"><span class="comment">//         删除此文件</span></span><br><span class="line">        file.delete();</span><br><span class="line"></span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;d:/blb&quot;</span>);</span><br><span class="line"><span class="comment">//        创建这个目录，前提是所有父级目录都存在</span></span><br><span class="line">        dir.mkdir();</span><br><span class="line"><span class="comment">//        创建这个目录，父级目录不存在，则把所有父级目录都创建</span></span><br><span class="line">        dir.mkdirs();</span><br><span class="line"><span class="comment">//        返回dir目录中的所有文件，以String [] 的形式保存</span></span><br><span class="line">        String[] list = dir.list();</span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        返回dir目录中的所有文件，以File [] 的形式保存</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f:files) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        删除此目录，前提是这是一个空目录</span></span><br><span class="line">        dir.delete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-递归遍历文件夹"><a href="#1-3-递归遍历文件夹" class="headerlink" title="1.3 递归遍历文件夹"></a>1.3 递归遍历文件夹</h2><p><strong>思路</strong></p>
<p><img src="/2021/08/05/IO%E6%B5%81/image-20210804103010711.png" alt="image-20210804103010711"></p>
<p> <strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"></span><br><span class="line"><span class="comment">//递归遍历文件夹，将文件夹和文件的信息，打印输出在控制台当中</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test07</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备数据</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;JavaSEDay18\\dir&quot;</span>);</span><br><span class="line">        List&lt;File&gt; dirList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;File&gt; fileList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//直接调用方法</span></span><br><span class="line">        diGui(f,dirList,fileList);</span><br><span class="line">        <span class="comment">//查看结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件夹的数据如下:&quot;</span>);</span><br><span class="line">        <span class="comment">//采用lambda表达式快速遍历集合。里面使用方法引用</span></span><br><span class="line">        dirList.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件的数据如下:&quot;</span>);</span><br><span class="line">        <span class="comment">//采用lambda表达式快速遍历集合。里面使用方法引用</span></span><br><span class="line">        fileList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个递归操作的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">diGui</span><span class="params">(File f, List&lt;File&gt; dirList, List&lt;File&gt; fileList)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 判断，如果是文件，则直接存放到集合当中</span></span><br><span class="line">        <span class="keyword">if</span> (f.isFile())&#123;</span><br><span class="line">            fileList.add(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判断，如果是文件夹，则直接存放到文件夹的集合。还需要得到子文件数组，遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (f.isDirectory())&#123;</span><br><span class="line">            dirList.add(f);</span><br><span class="line">            <span class="comment">//------------------</span></span><br><span class="line">            <span class="comment">//获取到亲儿子 子文件的对象数组</span></span><br><span class="line">            File[] array = f.listFiles();</span><br><span class="line">            <span class="comment">//判断当前的数组是否不为空，防止空指针异常的问题</span></span><br><span class="line">            <span class="keyword">if</span> (array!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//增强for，获取到每一个儿子</span></span><br><span class="line">                <span class="keyword">for</span> (File child : array) &#123;</span><br><span class="line">                    <span class="comment">//再次获取文件和文件夹，递归操作</span></span><br><span class="line">                    diGui(child,dirList,fileList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//------------------</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-IO流"><a href="#2-IO流" class="headerlink" title="2. IO流"></a>2. IO流</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>​    我们遇到这种场景：打开文本编辑工具记事本，写入内容，然后保存。在这个过程中，写内容是写在电脑的内存中，当点击保存的时候会把内存中的数据传到硬盘中，当下次开机的时候这些数据仍然还在。但是如果在保存之前就重启电脑，那这些内容就会丢失，因为数据在内存中会被清空。数据在内存跟硬盘中传输的过程就是IO流。</p>
<p>​    I/O流称为输入/输出流，是指数据在程序跟另一端进行流向的一个过程，另一端可以是硬盘上的文件，也可以是网络或者其它。</p>
<p>​    这里的入跟出都是相对程序而已的，输入流是指数据源流向程序，输出是指从程序将数据写出到数据源中。</p>
<p><img src="/2021/08/05/IO%E6%B5%81/1609828860802.png" alt="1609828860802"></p>
<h2 id="2-2-IO的分类"><a href="#2-2-IO的分类" class="headerlink" title="2.2 IO的分类"></a>2.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><p><strong>输入流</strong> ：把数据从数据源上读取到程序中的流。 </p>
</li>
<li><p><strong>输出流</strong> ：把数据从程序中写出到数据源上的流。</p>
<p>从流向划分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. I: in  输入（从硬盘到内存的过程） 从电脑文件到 Java程序的过程   //键盘、鼠标、扫描仪</span><br><span class="line">2. O: out 输出（从内存到硬盘的过程） 从Java程序到 电脑文件的过程   //显示器、打印机</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/05/IO%E6%B5%81/image-20210804140813253.png" alt="image-20210804140813253"></p>
</li>
</ul>
<p>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><p><strong>字节流</strong> ：以字节为单位，读写数据的流。</p>
</li>
<li><p><strong>字符流</strong> ：以字符为单位，读写数据的流。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 字节流（byte） 操作的是 0或者1数据。 InputStream 和 OutputStream  任何数据都可以使用字节流</span><br><span class="line">2. 字符流（char） 操作的是 中午、英文、符号等字符数据。 Reader 和 Writer  文本类型的数据（可以解决中文乱码问题）</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/05/IO%E6%B5%81/image-20210804140845674.png" alt="image-20210804140845674"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>输入流</strong></th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">字节输入流<strong>InputStream</strong></td>
<td align="center">字节输出流<strong>OutputStream</strong></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">字符输入流<strong>Reader</strong></td>
<td align="center">字符输出流<strong>Writer</strong></td>
</tr>
</tbody></table>
<p><img src="/2021/08/05/IO%E6%B5%81/IO%E4%BD%93%E7%B3%BB%E5%9B%BE.jpg" alt="IO体系图"></p>
<h2 id="2-3-字节流"><a href="#2-3-字节流" class="headerlink" title="2.3 字节流"></a>2.3 字节流</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，传输时只需要传输对应的二进制数据即可。流的传输底层就是这些二进制的数据的流动。</p>
<h3 id="2-3-1-FileOutputStream"><a href="#2-3-1-FileOutputStream" class="headerlink" title="2.3.1 FileOutputStream"></a>2.3.1 FileOutputStream</h3><p>构造方法：</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>FileOutputStream(String)</td>
<td>参数1：文件的路径</td>
</tr>
<tr>
<td>FileOutputStream(String,boolean)</td>
<td>参数1：文件的路径 参数2：是否开启追加写，默认false</td>
</tr>
<tr>
<td>FileOutputStream(File)</td>
<td>参数1：文件的对象</td>
</tr>
<tr>
<td>FileOutputStream(File,boolean)</td>
<td>参数1：文件的对象 参数2：是否开启追加写，默认false</td>
</tr>
</tbody></table>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 如果构造方法参数当中，文件不存在，则创建文件</span><br><span class="line">2. 如果构造方法参数当中，文件夹不存在，则出现异常 FileNotFoundException</span><br><span class="line">3. 如果构造方法参数当中，文件存在，而且文件当中有内容，创建对象的时候，会创建新的文件，覆盖之前的文件。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int)</td>
<td>参数1：写入的字节数据</td>
</tr>
<tr>
<td>void write(byte[])</td>
<td>参数1：写入的字节数组数据</td>
</tr>
<tr>
<td>void write(byte[],int,int)</td>
<td>参数1：写入的字节数组数据，参数2：开始索引，参数3：写几个数据</td>
</tr>
<tr>
<td>void close()</td>
<td>这里的 close()方法表示断开和操作系统之间的关联关系</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新此输出流并强制任何缓冲的输出字节被写出。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：释放资源一旦使用完毕，后面将不能继续调用 write()方法</p>
</blockquote>
<h3 id="2-3-2-FileInputStream"><a href="#2-3-2-FileInputStream" class="headerlink" title="2.3.2 FileInputStream"></a>2.3.2 FileInputStream</h3><p>构造方法：</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>FileInputStream(String)</td>
<td>参数1：文件的路径</td>
</tr>
<tr>
<td>FileInputStream(File)</td>
<td>参数1：文件的对象</td>
</tr>
</tbody></table>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>一次读取一个字节，返回字节数据</td>
</tr>
<tr>
<td>int read(byte[])</td>
<td>一次读取一个字节数组，返回读取的字节数组有效长度</td>
</tr>
<tr>
<td>int read(byte[],int,int)</td>
<td>一次读取一个字节数组一部分，返回读取的字节数组长度</td>
</tr>
<tr>
<td>void close()</td>
<td>释放资源，断开文件与程序之间的联系</td>
</tr>
</tbody></table>
<h3 id="2-3-3-文件复制案例"><a href="#2-3-3-文件复制案例" class="headerlink" title="2.3.3 文件复制案例"></a>2.3.3 文件复制案例</h3><p>文件复制案例（一次一字节）</p>
<p><img src="/2021/08/05/IO%E6%B5%81/%E4%B8%80%E6%AC%A1%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82.gif" alt="一次复制一个字节"></p>
<p>文件复制（一次一字节数组）</p>
<p><img src="/2021/08/05/IO%E6%B5%81/%E4%B8%80%E6%AC%A1%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84.gif" alt="一次复制一个字节数组"></p>
<h3 id="2-3-4-代码演示"><a href="#2-3-4-代码演示" class="headerlink" title="2.3.4 代码演示"></a>2.3.4 代码演示</h3><p>要求：将盘中的一张图片（D:\a\blb.jpg）通过程序复制到另一个路径下（D:\b\blb.jpg）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07IO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把一个图片的数据读取到程序中，把程序中的数据写到另一个文件（图片）中。 复制</span></span><br><span class="line">        InputStream input = <span class="keyword">null</span> ;</span><br><span class="line">        OutputStream output = <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File f1 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\a\\blb.jpg&quot;</span>);</span><br><span class="line">            File f2 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\b\\blb.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="keyword">if</span> (!f2.exists()) &#123;</span><br><span class="line">                f2.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把f1读取到程序中</span></span><br><span class="line">            input = <span class="keyword">new</span> FileInputStream(f1);</span><br><span class="line">            output = <span class="keyword">new</span> FileOutputStream(f2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = input.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                output.write(b, <span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(input != <span class="keyword">null</span> )&#123;</span><br><span class="line">                    input.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(output != <span class="keyword">null</span> )&#123;</span><br><span class="line">                    output.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-字符文件流"><a href="#2-4-字符文件流" class="headerlink" title="2.4 字符文件流"></a>2.4 字符文件流</h2><h3 id="2-4-1-基础理论"><a href="#2-4-1-基础理论" class="headerlink" title="2.4.1 基础理论"></a>2.4.1 基础理论</h3><p>为什么需要使用字符流呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为字节流操作文本文件的时候，容易出现 中文乱码问题。这种情况下，我们需要使用字符流。</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">	将文本文件的数据，读取到控制台当中，展示结果（采用字节流）</span><br></pre></td></tr></table></figure>

<p><strong>编码表</strong></p>
<p><img src="/2021/08/05/IO%E6%B5%81/image-20210805142048200.png" alt="image-20210805142048200"></p>
<p><strong>介绍公式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char = byte + 编码表；</span><br><span class="line">字符 = 字节（0和1） + 编码表;</span><br><span class="line">//字符流的由来就是 字节流和编码表的组合。</span><br></pre></td></tr></table></figure>





<h3 id="2-4-2-FileWriter"><a href="#2-4-2-FileWriter" class="headerlink" title="2.4.2 FileWriter"></a>2.4.2 FileWriter</h3><p>字符文件输出流 FileWriter </p>
<p>构造方法</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>FileWriter(String)</td>
<td>参数1：文件的路径</td>
</tr>
<tr>
<td>FileWriter(String,boolean)</td>
<td>参数1：文件的路径 参数2：是否开启追加写，默认false</td>
</tr>
<tr>
<td>FileWriter(File)</td>
<td>参数1：文件的对象</td>
</tr>
<tr>
<td>FileWriter(File,boolean)</td>
<td>参数1：文件的对象 参数2：是否开启追加写，默认false</td>
</tr>
</tbody></table>
<p>常用方法，来自于父类的方法</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int)</td>
<td>参数1：写入的字符数据</td>
</tr>
<tr>
<td>void write(char[])</td>
<td>参数1：写入的字符数组数据</td>
</tr>
<tr>
<td>void write(char[],int,int)</td>
<td>参数1：写入的字符数组数据，参数2：开始索引，参数3：写几个数据</td>
</tr>
<tr>
<td>void write(String)</td>
<td>参数1：写入的字符数组数据</td>
</tr>
<tr>
<td>void write(String,int,int)</td>
<td>参数1：写入的字符数组数据，参数2：开始索引，参数3：写几个数据</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流对象，将内存当中的数据刷新到硬盘当中</td>
</tr>
<tr>
<td>void close()</td>
<td>这里的 close()方法表示断开和操作系统之间的关联关系</td>
</tr>
</tbody></table>
<p>要求：将下面的一段话输入到D盘的文本文件中。</p>
<p><code>昨夜雨疏风骤，浓睡不消残酒。试问卷帘人，却道海棠依旧。知否，知否？应是绿肥红瘦。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09IO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;D:\\blb.txt&quot;</span>);</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//          创建文件输出流</span></span><br><span class="line">            fileWriter = <span class="keyword">new</span> FileWriter(f,<span class="keyword">true</span>);<span class="comment">// 第2个参数表示是追加还是覆盖</span></span><br><span class="line">            fileWriter.write(<span class="string">&quot;昨夜雨疏风骤，浓睡不消残酒。试问卷帘人，却道海棠依旧。知否，知否？应是绿肥红瘦。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fileWriter!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    fileWriter.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-3-FileReader"><a href="#2-4-3-FileReader" class="headerlink" title="2.4.3 FileReader"></a>2.4.3 FileReader</h3><p>字符文件输入流 FileReader</p>
<p>构造方法</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>FileReader(String)</td>
<td>参数1：文件的路径</td>
</tr>
<tr>
<td>FileReader(File)</td>
<td>参数1：文件的对象</td>
</tr>
</tbody></table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>一次读取一个字符，返回字符对应的整数值</td>
</tr>
<tr>
<td>int read(int[])</td>
<td>一次读取一个字符数组，返回读取到的字符数组有效长度</td>
</tr>
<tr>
<td>int read(char[],int,int)</td>
<td>一次读取一个字符数组的一部分，返回读取到的字符数组有效长度</td>
</tr>
<tr>
<td>void close()</td>
<td>释放资源，断开程序和操作系统之间的关联关系</td>
</tr>
</tbody></table>
<p><strong>代码演示</strong></p>
<p>要求：将文本文件中的内容读取到控制台中显示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08IO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            读取D盘中a.txt文件的内容</span></span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line"><span class="comment">//            创建对应的输入流</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(f);</span><br><span class="line">            <span class="keyword">int</span> c ;</span><br><span class="line">            <span class="keyword">while</span>((c = fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println( (<span class="keyword">char</span>)c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                关闭流</span></span><br><span class="line">                <span class="keyword">if</span> (fileReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-缓冲流"><a href="#2-5-缓冲流" class="headerlink" title="2.5 缓冲流"></a>2.5 缓冲流</h2><h3 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h3><p>​        JAVA的IO体系中有些流不能独立使用，必须套在其它流的上面才能使用，称为包装流。JAVA的IO体系就是通过装饰模式来实现。需要什么流的功能就在外面套一个对应的流即可，就像一个武士，需要一把武器就装饰一把武器，需要一身铠甲就套一层铠甲，这个武士就能使用武器跟铠甲的功能了。</p>
<p>​        而缓冲流就是常用的一个包装流，也叫高效流，是对4个基本的<code>File</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<h3 id="2-5-2-字节缓冲流"><a href="#2-5-2-字节缓冲流" class="headerlink" title="2.5.2 字节缓冲流"></a>2.5.2 字节缓冲流</h3><p><strong>案例一：采用字节缓冲流一次读写一个字节复制文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节缓冲流 一次一字节 复制文件</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String srcPath = <span class="string">&quot;JavaSEDay18\\dir\\图片1.png&quot;</span>;</span><br><span class="line">        String destPath = <span class="string">&quot;JavaSEDay18\\dir\\目标图片3.png&quot;</span>;</span><br><span class="line">        <span class="comment">//1. 创建对象</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(srcPath));</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(destPath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 读写数据</span></span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch = bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 释放资源</span></span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>案例二：采用字节缓冲流一次读写一个字节数组复制文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节缓冲流 一次一字节数组 复制文件</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();  <span class="comment">//开始时间，距离1970年1月1号 00:00:00 毫秒值</span></span><br><span class="line">        String srcPath = <span class="string">&quot;JavaSEDay18\\dir\\图片1.png&quot;</span>;</span><br><span class="line">        String destPath = <span class="string">&quot;JavaSEDay18\\dir\\目标图片4.png&quot;</span>;</span><br><span class="line">        <span class="comment">//1. 创建对象</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(srcPath));</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(destPath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(array))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(array,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 释放资源</span></span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();  <span class="comment">//结束时间，距离1970年1月1号 00:00:00 毫秒值</span></span><br><span class="line">        System.out.println(end-start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-字符缓冲流"><a href="#2-5-3-字符缓冲流" class="headerlink" title="2.5.3 字符缓冲流"></a>2.5.3 字符缓冲流</h3><h4 id="2-5-3-1-BufferedWriter"><a href="#2-5-3-1-BufferedWriter" class="headerlink" title="2.5.3.1 BufferedWriter"></a>2.5.3.1 BufferedWriter</h4><p>字符缓冲输出流 BufferedWriter</p>
<p>构造方法</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedWriter(Writer)</td>
<td>参数1：字符输出流的对象</td>
</tr>
<tr>
<td>BufferedWriter(Writer,int)</td>
<td>参数1：字符输出流的对象，参数2：缓冲区大小</td>
</tr>
</tbody></table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(String)</td>
<td>参数：字符串</td>
</tr>
<tr>
<td>void newLine()</td>
<td>写换行符，不区分操作系统</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新IO流</td>
</tr>
<tr>
<td>void close()</td>
<td>释放资源</td>
</tr>
</tbody></table>
<h4 id="2-5-3-2-BufferedReader"><a href="#2-5-3-2-BufferedReader" class="headerlink" title="2.5.3.2  BufferedReader"></a>2.5.3.2  BufferedReader</h4><p>字符缓冲输入流 BufferedReader</p>
<p>构造方法</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedReader(Reader)</td>
<td>参数1：字符输入流的对象</td>
</tr>
<tr>
<td>BufferedReader(Reader,int)</td>
<td>参数1：字符输入流的对象 参数2：缓冲区的大小</td>
</tr>
</tbody></table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法API</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>String readLine()</td>
<td>一次性读取一行数据，不会读取换行符</td>
</tr>
<tr>
<td>void close()</td>
<td>释放资源，断开和操作系统之间的关联</td>
</tr>
</tbody></table>
<h4 id="2-5-3-3-复制文件案例"><a href="#2-5-3-3-复制文件案例" class="headerlink" title="2.5.3.3  复制文件案例"></a>2.5.3.3  复制文件案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//练习：采用字符缓冲流实现文件复制代码（重点）特殊方法</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String spath = <span class="string">&quot;JavaSEDay19\\dir\\测试05.txt&quot;</span>;</span><br><span class="line">        String dpath = <span class="string">&quot;JavaSEDay19\\dir\\目标文件04.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(spath));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(dpath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读写数据</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();   <span class="comment">//换行</span></span><br><span class="line">            bw.flush();     <span class="comment">//刷新</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-3-4-同文反转案例"><a href="#2-5-3-4-同文反转案例" class="headerlink" title="2.5.3.4  同文反转案例"></a>2.5.3.4  同文反转案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目：同文反转【正确的写法】</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String path = <span class="string">&quot;JavaSEDay19\\dir\\hello.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//1. 将文件的数据读取到集合当中</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            array.add(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        <span class="comment">//2. 将集合的数据写回到文件当中</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(path));</span><br><span class="line">        <span class="comment">//循环遍历集合，准备写数据</span></span><br><span class="line">        <span class="keyword">for</span> (String s : array) &#123;</span><br><span class="line">            <span class="comment">//反转操作</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">            String str = sb.reverse().toString();</span><br><span class="line">            <span class="comment">//写回数据</span></span><br><span class="line">            bw.write(str);</span><br><span class="line">            bw.newLine(); <span class="comment">//换行</span></span><br><span class="line">            bw.flush(); <span class="comment">//刷新</span></span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-转换流"><a href="#2-6-转换流" class="headerlink" title="2.6 转换流"></a>2.6 转换流</h2><h4 id="2-6-1-OutputStreamWriter"><a href="#2-6-1-OutputStreamWriter" class="headerlink" title="2.6.1 OutputStreamWriter"></a>2.6.1 OutputStreamWriter</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标：学习OutputStreamWriter的快速入门</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String path = <span class="string">&quot;JavaSEDay19\\dir\\测试04.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(path),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">//2.读写数据</span></span><br><span class="line">        osw.write(<span class="string">&quot;定浩和腚耗&quot;</span>);</span><br><span class="line">        osw.flush();</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="2-6-2-InputStreamReader"><a href="#2-6-2-InputStreamReader" class="headerlink" title="2.6.2 InputStreamReader"></a>2.6.2 InputStreamReader</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标：学习 InputStreamReader 的快速入门</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String path = <span class="string">&quot;JavaSEDay19\\dir\\测试03.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(path),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">//2.读写数据</span></span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="2-6-3-编码转换"><a href="#2-6-3-编码转换" class="headerlink" title="2.6.3 编码转换"></a>2.6.3 编码转换</h4><p>将一个 gbk 格式的文件，转换成 utf-8格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分析：</span><br><span class="line">	原始文件 gbk 格式  ---【InputStreamReader】---&gt; 读取到程序当中 --【OutputStreamWriter】--&gt; 目标文件 utf-8格式</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	之前是什么格式的文件，读取的时候，就需要采用什么编码。</span><br><span class="line">	写出的过程，需要转换编码。</span><br><span class="line">	读：gbk</span><br><span class="line">	写：utf-8</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//练习：编码转换 GBK --&gt; UTF-8</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String spath = <span class="string">&quot;C:\\Users\\chenhaochuan\\Desktop\\新建文件夹\\hello.txt&quot;</span>;</span><br><span class="line">        String dpath = <span class="string">&quot;JavaSEDay19\\dir\\目标文件03.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(spath),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(dpath),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读写数据</span></span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span> ((ch = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            osw.write(ch);</span><br><span class="line">            osw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        isr.close();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-对象操作流"><a href="#2-7-对象操作流" class="headerlink" title="2.7 对象操作流"></a>2.7 对象操作流</h2><h3 id="2-7-1-概述"><a href="#2-7-1-概述" class="headerlink" title="2.7.1 概述"></a>2.7.1 概述</h3><p>​    Java 提供了一种对象<strong>序列化</strong>的机制。用来将某个对象保存到磁盘上或者在网络上传输。可以理解为将内存中的对象进行持久化保存下来。反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。 </p>
<p>​    JAVA中是通过对象流来实现对象的序列化跟反序列化的，对象流也是一种包装流。</p>
<p><img src="/2021/08/05/IO%E6%B5%81/1609834689811.png" alt="1609834689811"></p>
<h3 id="2-7-2-ObjectOutputStream"><a href="#2-7-2-ObjectOutputStream" class="headerlink" title="2.7.2 ObjectOutputStream"></a>2.7.2 ObjectOutputStream</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标：学习对象操作流的快速入门(对象序列化操作)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String path = <span class="string">&quot;JavaSEDay20\\dir\\文件01.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path));</span><br><span class="line">        <span class="comment">//2.读写数据</span></span><br><span class="line">        oos.writeObject(<span class="number">1314</span>);</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小结：将对象，保存到本地文件当中，序列化操作。 对象 --&gt; 文件。</span></span><br></pre></td></tr></table></figure>

<p><strong>常见问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 为什么序列化接口 Serializable 当中没有任何方法呢?</span><br><span class="line">	序列化接口 Serializable 称之为 &quot;标记型接口&quot;  （标记型接口：没有任何方法的接口）</span><br><span class="line">	他只是给出一个标记，用于给 ObjectOuputStream 进行识别的。 </span><br><span class="line"></span><br><span class="line">2. 异常问题：</span><br><span class="line">	A. 未序列化的异常 NotSerializableException</span><br><span class="line">		原因: 我们的类，没有实现标识接口 Serializable</span><br><span class="line">		解决：类上限需要实现序列化接口 Serializable</span><br></pre></td></tr></table></figure>



<h3 id="2-7-3-ObjectInputStream"><a href="#2-7-3-ObjectInputStream" class="headerlink" title="2.7.3 ObjectInputStream"></a>2.7.3 ObjectInputStream</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标：学习ObjectInputStream 读取数据的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String path = <span class="string">&quot;JavaSEDay20\\dir\\文件01.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path));</span><br><span class="line">        <span class="comment">//2.读写数据</span></span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常见问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 异常：InvalidClassException</span><br><span class="line">	A. 原因: 当我们先采用 writeObject 写对象，然修改了 类文件信息，再次 readObject 就会出现此异常。因为字节码变化了。</span><br><span class="line">	B. 解决: 需要告诉字节码无论怎么改变，我就是我。 需要添加序列化的 ID 证明我就是我</span><br><span class="line">	C. 例如:  private static final long serialVersionUID = 1L;</span><br><span class="line">	</span><br><span class="line">2. 不想被序列化怎么办？</span><br><span class="line">	可以采用 瞬态关键字，给成员变量，添加瞬态。</span><br><span class="line">	例如:  transient int age;</span><br><span class="line">	举例:  java.util.Date 类底层有一个 fastTime</span><br><span class="line">	</span><br><span class="line">3. 出现异常 EOFException</span><br><span class="line">	原因: 写对象 writeObject() 的次数和读对象 readObject() 的次数不一致。</span><br><span class="line">	解决: 我们的对象只写一次，我们的对象只读一次即可。</span><br></pre></td></tr></table></figure>





<h3 id="2-7-4-标准写法"><a href="#2-7-4-标准写法" class="headerlink" title="2.7.4 标准写法"></a>2.7.4 标准写法</h3><p>汽车类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车类</span></span><br><span class="line"><span class="comment">//1. 需要实现序列化的接口</span></span><br><span class="line"><span class="comment">//2. 需要添加序列化的ID</span></span><br><span class="line"><span class="comment">//3. 可以添加瞬态关键字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        <span class="comment">//writeData();</span></span><br><span class="line">        <span class="comment">//读数据</span></span><br><span class="line">        readData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写数据的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ArrayList&lt;Car&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        array.add(<span class="keyword">new</span> Car(<span class="string">&quot;五菱宏光&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        array.add(<span class="keyword">new</span> Car(<span class="string">&quot;劳斯莱斯&quot;</span>,<span class="number">3000</span>));</span><br><span class="line">        <span class="comment">//写数据的操作</span></span><br><span class="line">        String path = <span class="string">&quot;JavaSEDay20\\dir\\文件03.txt&quot;</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path));</span><br><span class="line">        oos.writeObject(array);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读数据的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String path = <span class="string">&quot;JavaSEDay20\\dir\\文件03.txt&quot;</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path));</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        ArrayList&lt;Car&gt; array = (ArrayList&lt;Car&gt;) o;</span><br><span class="line">        array.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="2-7-5-深浅克隆"><a href="#2-7-5-深浅克隆" class="headerlink" title="2.7.5 深浅克隆"></a>2.7.5 深浅克隆</h3><p><strong>基础理论</strong></p>
<p>对象的拷贝复制是不可以使用 等号的。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student one = new Student(&quot;迪丽热巴&quot;,23);</span><br><span class="line">Student two = one; //这里叫做把 one的地址赋值给two 指向是相同的堆内存空间。</span><br></pre></td></tr></table></figure>

<p>采用 等号赋值的模型图。==两个引用<code>one</code>和<code>two</code>指向相同的内存地址==</p>
<p><img src="/2021/08/05/IO%E6%B5%81/image-20210806103808733.png" alt="image-20210806103808733"></p>
<h4 id="2-7-5-1-浅克隆"><a href="#2-7-5-1-浅克隆" class="headerlink" title="2.7.5.1 浅克隆"></a>2.7.5.1 <strong>浅克隆</strong></h4><p><img src="/2021/08/05/IO%E6%B5%81/image-20210806105718534.png" alt="image-20210806105718534"></p>
<p>手机类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String brand, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学生类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Phone p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写方法。来自于Object类的克隆 clone方法，快捷键 Ctrl+o (欧)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, Phone p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setP</span><span class="params">(Phone p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;p = &quot;</span> + p);</span><br><span class="line">        System.out.println(<span class="string">&quot;p.getBrand() = &quot;</span> + p.getBrand());</span><br><span class="line">        System.out.println(<span class="string">&quot;p.getPrice() = &quot;</span> + p.getPrice());</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生类的对象</span></span><br><span class="line">        Student one = <span class="keyword">new</span> Student(<span class="string">&quot;迪丽热巴&quot;</span>,<span class="number">23</span>,<span class="keyword">new</span> Phone(<span class="string">&quot;IPhoneXX&quot;</span>,<span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//克隆对象</span></span><br><span class="line">        Student two = (Student) one.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;one = &quot;</span> + one);</span><br><span class="line">        System.out.println(<span class="string">&quot;two = &quot;</span> + two);</span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        one.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        two.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果</p>
<p><img src="/2021/08/05/IO%E6%B5%81/image-20210806110054652.png" alt="image-20210806110054652"></p>
<hr>
<h4 id="2-7-5-2-深克隆"><a href="#2-7-5-2-深克隆" class="headerlink" title="2.7.5.2 深克隆"></a>2.7.5.2 <strong>深克隆</strong></h4><p><img src="/2021/08/05/IO%E6%B5%81/image-20210806111012542.png" alt="image-20210806111012542"></p>
<p>手机类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String brand, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学生类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span>,<span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Phone p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写方法。来自于Object类的克隆 clone方法，快捷键 Ctrl+o (欧)</span></span><br><span class="line">    <span class="comment">//深克隆的方式:</span></span><br><span class="line">    <span class="comment">//将对象 ---写入到内存---&gt; 内存 ---读取处理---&gt; 新的对象</span></span><br><span class="line">    <span class="comment">//ByteArrayOutputStream 和 ByteArrayInputStream</span></span><br><span class="line">    <span class="comment">//ByteArrayOutputStream --&gt; 写数据到数组里面（存在于内存当中）</span></span><br><span class="line">    <span class="comment">//ByteArrayInputStream ---&gt; 读取上面数组的内容即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//定义对象的引用</span></span><br><span class="line">        Student stu = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.将当前的对象，写入到内存当中。</span></span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            <span class="comment">//写对象，谁调用 clone()方法，我就写谁。</span></span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//2.重新读取数据，读取写入的内存数据，数据来自于 bos</span></span><br><span class="line">            <span class="comment">//在 bos 当中保存的就是 oos 里面写的对象 this</span></span><br><span class="line">            ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            Object o = ois.readObject();</span><br><span class="line">            <span class="comment">//3. 强制类型转换</span></span><br><span class="line">            stu = (Student)o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接返回</span></span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, Phone p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setP</span><span class="params">(Phone p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;p = &quot;</span> + p);</span><br><span class="line">        System.out.println(<span class="string">&quot;p.getBrand() = &quot;</span> + p.getBrand());</span><br><span class="line">        System.out.println(<span class="string">&quot;p.getPrice() = &quot;</span> + p.getPrice());</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生类的对象</span></span><br><span class="line">        Student one = <span class="keyword">new</span> Student(<span class="string">&quot;迪丽热巴&quot;</span>,<span class="number">23</span>,<span class="keyword">new</span> Phone(<span class="string">&quot;IPhoneXX&quot;</span>,<span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//克隆对象</span></span><br><span class="line">        Student two = (Student) one.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;one = &quot;</span> + one);</span><br><span class="line">        System.out.println(<span class="string">&quot;two = &quot;</span> + two);</span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        one.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        two.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果</p>
<p><img src="/2021/08/05/IO%E6%B5%81/image-20210806113013369.png" alt="image-20210806113013369"></p>
<h3 id="2-7-6-标准IO流异常处理"><a href="#2-7-6-标准IO流异常处理" class="headerlink" title="2.7.6 标准IO流异常处理"></a>2.7.6 标准IO流异常处理</h3><h5 id="2-7-6-1-以前的写法"><a href="#2-7-6-1-以前的写法" class="headerlink" title="2.7.6.1 以前的写法"></a>2.7.6.1 以前的写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标:ObjectOuputStream写数据的方法(标准处理异常的代码)以前写法</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        String path = <span class="string">&quot;JavaSEDay20\\dir\\文件04.txt&quot;</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读写数据</span></span><br><span class="line">        oos.writeObject(<span class="string">&quot;川哥，你是真的帅炸啦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-7-6-2-标准IO流处理异常的方式"><a href="#2-7-6-2-标准IO流处理异常的方式" class="headerlink" title="2.7.6.2 标准IO流处理异常的方式"></a>2.7.6.2 标准IO流处理异常的方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标:ObjectOuputStream写数据的方法(标准处理异常的代码) 标准写法</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//1.创建对象</span></span><br><span class="line">            String path = <span class="string">&quot;JavaSEDay20\\dir\\文件05.txt&quot;</span>;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// System.out.println(3/0);</span></span><br><span class="line">            <span class="comment">//2.读写数据</span></span><br><span class="line">            oos.writeObject(<span class="string">&quot;川哥，你是真的帅炸啦&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//出现异常之后的处理的代码。</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//不管你最后走的是 try...还是 catch... 始终都会执行 finally</span></span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;我执行了。。finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-8-属性集-Properties"><a href="#2-8-属性集-Properties" class="headerlink" title="2.8 属性集 Properties"></a>2.8 属性集 Properties</h2><h3 id="2-8-1-概述"><a href="#2-8-1-概述" class="headerlink" title="2.8.1 概述"></a>2.8.1 概述</h3><p><img src="/2021/08/05/IO%E6%B5%81/image-20210806142753830.png" alt="image-20210806142753830"></p>
<p>说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hashtable 在JDK1.0版本出现。Hashtable 目前已经不适用了。被 HashMap取代了。（原因：HashMap效率高）</span><br><span class="line">但是 Hashtable 他的儿子 Properties 依然在使用。（原因：Properties可以和IO结合使用）</span><br></pre></td></tr></table></figure>

<p>说到 Hashtable 需要注意和 HashMap的小区别：能否存放 空值空键的问题。</p>
<p><img src="/2021/08/05/IO%E6%B5%81/image-20210806143648225.png" alt="image-20210806143648225"></p>
<h3 id="2-8-2-常用API"><a href="#2-8-2-常用API" class="headerlink" title="2.8.2 常用API"></a>2.8.2 常用API</h3><ul>
<li><p><code>public Properties()</code> :创建一个空的属性列表。</p>
</li>
<li><p><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </p>
</li>
<li><p><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</p>
</li>
<li><p><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</p>
</li>
<li><p><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对数据。</p>
</li>
<li><p><code>public void store(OutputStream out,String comments)</code>:从字节输入流中存储键值对数据</p>
</li>
</ul>
<h3 id="2-8-3-案例"><a href="#2-8-3-案例" class="headerlink" title="2.8.3 案例"></a>2.8.3 案例</h3><p><strong>作为集合的常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标: 学习属性集 Properties的快速入门</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Properties pp = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//存放数据</span></span><br><span class="line">        pp.setProperty(<span class="string">&quot;萧峰&quot;</span>, <span class="string">&quot;阿朱&quot;</span>);</span><br><span class="line">        pp.setProperty(<span class="string">&quot;段誉&quot;</span>, <span class="string">&quot;语嫣&quot;</span>);</span><br><span class="line">        pp.setProperty(<span class="string">&quot;虚竹&quot;</span>, <span class="string">&quot;梦姑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取值操作</span></span><br><span class="line">        String value1 = pp.getProperty(<span class="string">&quot;西门庆&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;value1 = &quot;</span> + value1);</span><br><span class="line">        String value2 = pp.getProperty(<span class="string">&quot;段誉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;value2 = &quot;</span> + value2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合  stringPropertyNames()获取到所有的键，类似于keySet()</span></span><br><span class="line">        Set&lt;String&gt; keys = pp.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            String value = pp.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;,&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>作为与IO结合的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties pp = <span class="keyword">new</span> Properties();</span><br><span class="line">    pp.setProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    pp.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">//需要将上述的数据，存储到文件当中。</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;JavaSEDay20\\dir\\文件07.properties&quot;</span>);</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">//将Properties的数据通过流保存到文件当中</span></span><br><span class="line">    pp.store(osw, <span class="string">&quot;chuan ge a wo zhe ci yi ding yao chao shen&quot;</span>);</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    fos.close();</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    Properties pp = <span class="keyword">new</span> Properties();</span><br><span class="line">    pp.load(<span class="keyword">new</span> FileReader(<span class="string">&quot;JavaSEDay20\\dir\\文件07.properties&quot;</span>));</span><br><span class="line">    Set&lt;String&gt; keys = pp.stringPropertyNames();</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        String value = pp.getProperty(key);</span><br><span class="line">        System.out.println(key + <span class="string">&quot;,&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-4-程序次数"><a href="#2-8-4-程序次数" class="headerlink" title="2.8.4 程序次数"></a>2.8.4 程序次数</h3><p><strong>需求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编写一个程序，统计该程序运行的次数。</span><br><span class="line">如果程序第 1次运行，则展示 &quot;第1次使用本软件&quot;。</span><br><span class="line">如果程序第 2次运行，则展示 &quot;第2次使用本软件&quot;。</span><br><span class="line">如果程序第 3次运行，则展示 &quot;第3次使用本软件&quot;。</span><br><span class="line">如果程序第 4次运行，则展示 &quot;您的试用次数已经达到上限，请给我的支付宝充值200元&quot;。</span><br><span class="line">如果程序第 5次运行，则展示 &quot;您的试用次数已经达到上限，请给我的支付宝充值200元&quot;。</span><br><span class="line">。。。。。。。</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//练习：程序次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties pp = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//定义路径</span></span><br><span class="line">        String path = <span class="string">&quot;JavaSEDay20\\dir\\次数.properties&quot;</span>;</span><br><span class="line">        <span class="comment">//将路径，封装成为File对象，用于判断文件是否存在</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="comment">//判断文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">            <span class="comment">//第一次出现，直接向文件当中，保存数据。</span></span><br><span class="line">            pp.setProperty(<span class="string">&quot;number&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="comment">//将数据写入到文件当中</span></span><br><span class="line">            pp.store(<span class="keyword">new</span> FileWriter(path),<span class="keyword">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第1次使用本软件&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//去加载数据</span></span><br><span class="line">            pp.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">            <span class="comment">//不是第一次出现。取出数据</span></span><br><span class="line">            String countStr = pp.getProperty(<span class="string">&quot;number&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> count = Integer.parseInt(countStr);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//说明:这里加上双引号的原因是 setProperty方法的参数是字符串类型</span></span><br><span class="line">            pp.setProperty(<span class="string">&quot;number&quot;</span>,count+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">//将数据写入到文件当中</span></span><br><span class="line">            pp.store(<span class="keyword">new</span> FileWriter(path),<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//判断是否达到了上限</span></span><br><span class="line">            <span class="keyword">if</span> (count&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+count+<span class="string">&quot;次使用本软件&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您的试用次数已经达到上限，请给我的支付宝充值200元&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips: </p>
<ul>
<li><code>properties</code>文件中键值对之间的分割可以使用<code>=</code> <code> :</code>跟空格。</li>
<li>由于<code>properties</code>继承<code>Hashtable</code>，所有还可以通过枚举器来遍历。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>xml</title>
    <url>/2021/08/09/xml/</url>
    <content><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>XML（EXtensible Markup Language）可扩展的标记语言。主要用于数据交换。在HTML发展过程中，由于游览器厂商的恶性竞争，都在兼容不规范的写法，以用来吸引开发者。这与W3C的初衷相违背。于是W3C制定了XML标准，想以此替代HTML进行数据展示。但此并不能吸引开发者，XML最终以失败告终。XML接着又向数据交互方向寻求生存之路，并在此取得一定的成功。现主要功能用于配置文件跟网络中进行数据交互。</p>
<h3 id="1-2-什么是xml"><a href="#1-2-什么是xml" class="headerlink" title="1.2  什么是xml"></a>1.2  什么是xml</h3><ul>
<li>XML 指可扩展标记语言（<em>EX</em>tensible <em>M</em>arkup <em>L</em>anguage）</li>
<li>XML 是一种<em>标记语言</em>，很类似 HTML</li>
<li>XML 的设计宗旨是<em>传输数据</em>，而非显示数据</li>
<li>XML 标签没有被预定义。您需要<em>自行定义标签</em>。</li>
<li>XML 被设计为具有<em>自我描述性</em>。</li>
<li>XML 是 <em>W3C 的推荐标准</em></li>
</ul>
<h3 id="1-3-XML与HTML的主要差异"><a href="#1-3-XML与HTML的主要差异" class="headerlink" title="1.3 XML与HTML的主要差异"></a>1.3 XML与HTML的主要差异</h3><ul>
<li>XML标签都是自定义的，HTML标签都是预定义的</li>
<li>XML的语法严格，HTML语法松散</li>
<li>XML存储数据的，HTML展示数据的</li>
</ul>
<h3 id="1-4-用途"><a href="#1-4-用途" class="headerlink" title="1.4 用途"></a>1.4 用途</h3><p><strong>XML 应用于 web 开发的许多方面，常用于简化数据的存储和共享。</strong></p>
<ul>
<li><p>XML 把数据从 HTML 分离</p>
<p>如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p>
<p>通过 XML，数据能够存储在独立的 XML 文件中。这样你就可以专注于使用 HTML 进行布局和显示，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p>
<p>通过使用几行 JavaScript，你就可以读取一个外部 XML 文件，然后更新 HTML 中的数据内容。</p>
</li>
<li><p>XML 简化数据共享</p>
<p>在真实的世界中，计算机系统和数据使用不兼容的格式来存储数据。</p>
<p>XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。</p>
<p>这让创建不同应用程序可以共享的数据变得更加容易。</p>
</li>
<li><p>XML 简化数据传输</p>
</li>
<li><p>XML 简化平台的变更</p>
</li>
<li><p>XML 使您的数据更有用</p>
</li>
</ul>
<h2 id="2-XML语法"><a href="#2-XML语法" class="headerlink" title="2. XML语法"></a>2. XML语法</h2><h3 id="2-1-语法规则"><a href="#2-1-语法规则" class="headerlink" title="2.1 语法规则"></a>2.1 语法规则</h3><ul>
<li>XML文件的后缀必须都是xml</li>
<li>XML第一行必须写文档声明</li>
<li>XML中有且仅有一个根标签</li>
<li>属性值必须使用引号，单引号、双引号都可以</li>
<li>标签必须正确关闭，要么成对标签，要么自闭合</li>
<li>XML区分大小写</li>
</ul>
<h3 id="2-2-XML组成"><a href="#2-2-XML组成" class="headerlink" title="2.2  XML组成"></a>2.2  XML组成</h3><h4 id="2-2-1-文档声明"><a href="#2-2-1-文档声明" class="headerlink" title="2.2.1 文档声明"></a>2.2.1 文档声明</h4><ul>
<li><p>格式：<code>&lt;?xml 属性列表 ?</code></p>
</li>
<li><p>属性列表</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">version</td>
<td align="center">版本号，必须属性</td>
</tr>
<tr>
<td align="center">encoding</td>
<td align="center">编码方式，告知解析引擎当前文档使用的字符集，默认ISO-8859-1</td>
</tr>
<tr>
<td align="center">standalone</td>
<td align="center">是否独立，取值yes表示不依赖其它文件，取值no表示依赖其它文件</td>
</tr>
</tbody></table>
</li>
<li><p>例子</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-2-指令"><a href="#2-2-2-指令" class="headerlink" title="2.2.2  指令"></a>2.2.2  指令</h4><p>xml中还可以定义指令（CSS），毕竟发明xml的初衷还是做数据展示的。了解即可。</p>
<ul>
<li><p>demo.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet  type=&quot;text/css&quot; href=&quot;test.css&quot;  ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>28<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>test.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@CHARSET</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">name&#123;</span><br><span class="line">	<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-3-元素"><a href="#2-2-3-元素" class="headerlink" title="2.2.3 元素"></a>2.2.3 元素</h4><p>xml中还可以自定义元素，有如下规则：</p>
<ul>
<li>名称可以包含字母，数字以及其它字符</li>
<li>不能以数字或者标点符号开头</li>
<li>名称不能以xml或者XML、Xml等等开始</li>
<li>名称不能包含空格</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>在上例中，<bookstore> 和 <book> 都拥有<em>元素内容</em>，因为它们包含了其他元素。<author> 只有<em>文本内容</em>，因为它仅包含文本。</author></book></bookstore></p>
<p>在上例中，只有 <book> 元素拥有<em>属性</em> (category=”CHILDREN”)。</book></p>
<h4 id="2-2-4-属性"><a href="#2-2-4-属性" class="headerlink" title="2.2.4 属性"></a>2.2.4 属性</h4><p>标签内还可以定义属性，主要以K-V对的形式，属性值必须使用引号，单引号、双引号都行。id属性值唯一。</p>
<h4 id="2-2-5-文本"><a href="#2-2-5-文本" class="headerlink" title="2.2.5 文本"></a>2.2.5 文本</h4><ul>
<li><p>标签对中还可以定义文本内容。文本中如果用到需要转义的字符则需要转义，比如：</p>
<table>
<thead>
<tr>
<th>显示结果</th>
<th>描述</th>
<th>转义字符</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td><code>&amp;lt;</code></td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td><code>&amp;gt;</code></td>
</tr>
<tr>
<td>&amp;</td>
<td>与号</td>
<td><code>&amp;amp;</code></td>
</tr>
<tr>
<td>“</td>
<td>双引号</td>
<td><code>&amp;quot;</code></td>
</tr>
<tr>
<td>‘</td>
<td>单引号</td>
<td><code>&amp;apos;</code></td>
</tr>
<tr>
<td>×</td>
<td>乘号</td>
<td><code>&amp;times;</code></td>
</tr>
<tr>
<td>÷</td>
<td>除号</td>
<td><code>&amp;divde;</code></td>
</tr>
</tbody></table>
</li>
<li><p>CDATA区中的文本会原样输出，特殊字符不需要转义。<code>&lt;![CDATA[    ]]&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">	&lt;![CDATA[</span><br><span class="line">			if(a&gt;1 &amp;&amp; a&lt;3)&#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">	]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;<span class="symbol">&amp;quot;</span>001<span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> <span class="symbol">&amp;lt;</span><span class="symbol">&amp;lt;</span>西游记<span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span> <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>作者：&#x27;吴承恩&#x27;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">            &lt;![CDATA[</span><br><span class="line">                    我在这，想写什么都可以的，不一定要写标准代码。</span><br><span class="line">                    &lt;&lt;嘻嘻，我是西游记&gt;&gt;</span><br><span class="line">                    Sys.out.println(&quot;西游记讲的是两个和尚和三个动物的故事&quot;);</span><br><span class="line"></span><br><span class="line">            ]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：XML当中标签是 包裹嵌套，不能写 交叉嵌套。</p>
</blockquote>
<p><img src="/2021/08/09/xml/image-20210809214228769.jpg" alt="image-20210809214228769"></p>
</li>
</ul>
<h4 id="2-2-6-注释"><a href="#2-2-6-注释" class="headerlink" title="2.2.6 注释"></a>2.2.6 注释</h4><p>xml中的注释同HTML，<code>&lt;!--      --&gt;</code></p>
<h2 id="3-约束"><a href="#3-约束" class="headerlink" title="3. 约束"></a>3. 约束</h2><h3 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h3><p>XML的约束主要分为dtd跟schema两种。</p>
<ul>
<li><p>dtd是一种简单的约束技术，已经过时。</p>
</li>
<li><p>schema是一种复杂的约束技术，功能更加强大。</p>
</li>
</ul>
<h3 id="3-2-DTD"><a href="#3-2-DTD" class="headerlink" title="3.2 DTD"></a>3.2 DTD</h3><p><strong>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</strong></p>
<p><strong>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们知道 XML 的标签是自定义的。你想写什么，就可以写什么，只要符合标识符的规范就可以了。</span><br><span class="line">但是很多情况下，我们要求 xml 的标签，不能随便写，这种情况下，就需要使用 xml的约束了。</span><br><span class="line"></span><br><span class="line">例如: 在properties当中规定说: 用户名的键必须叫做 username 不能写别的，否则无法识别。</span><br><span class="line">但是在 xml 当中，因为名字的太不规范了，所以为了规范要求，根据现实需求，就需要添加约束信息。</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-DTD引用"><a href="#3-2-1-DTD引用" class="headerlink" title="3.2.1 DTD引用"></a>3.2.1 DTD引用</h4><h5 id="3-2-1-1-内部的-DOCTYPE-声明"><a href="#3-2-1-1-内部的-DOCTYPE-声明" class="headerlink" title="3.2.1.1 内部的 DOCTYPE 声明"></a>3.2.1.1 内部的 DOCTYPE 声明</h5><p>假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure>

<p>带有 DTD 的 XML 文档实例（请在 IE5 以及更高的版本打开，并选择查看源代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">  &lt;to&gt;George&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;John&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>

<p>解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!DOCTYPE note (第二行)定义此文档是 note 类型的文档。</span><br><span class="line"></span><br><span class="line">!ELEMENT note (第三行)定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;</span><br><span class="line"></span><br><span class="line">!ELEMENT to (第四行)定义 to 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line"></span><br><span class="line">!ELEMENT from (第五行)定义 from 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line"></span><br><span class="line">!ELEMENT heading (第六行)定义 heading 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line"></span><br><span class="line">!ELEMENT body (第七行)定义 body 元素为 &quot;#PCDATA&quot; 类型</span><br></pre></td></tr></table></figure>

<h5 id="3-2-1-2-外部文档声明"><a href="#3-2-1-2-外部文档声明" class="headerlink" title="3.2.1.2 外部文档声明"></a>3.2.1.2 外部文档声明</h5><p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这个 XML 文档和上面的 XML 文档相同，但是拥有一个外部的 DTD: （<a href="https://www.w3school.com.cn/dtd/note_ex_dtd.xml">在 IE5 中打开</a>，并选择“查看源代码”命令。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt; </span><br></pre></td></tr></table></figure>

<p>这是包含 DTD 的 “note.dtd” 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-1-2-引入网络当中的DTD约束"><a href="#3-2-1-2-引入网络当中的DTD约束" class="headerlink" title="3.2.1.2 引入网络当中的DTD约束"></a>3.2.1.2 引入网络当中的DTD约束</h5><p>网络DTD <code>&lt;!DOCTYPE 根标签名  PUBLIC &quot;dtd文件名&quot;  &quot;dtd文件的位置URL&quot; &gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span> <span class="meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-元素"><a href="#3-2-3-元素" class="headerlink" title="3.2.3  元素"></a>3.2.3  元素</h4><h5 id="3-2-3-1-声明一个元素"><a href="#3-2-3-1-声明一个元素" class="headerlink" title="3.2.3.1 声明一个元素"></a>3.2.3.1 声明一个元素</h5><p>在 DTD 中，XML 元素通过元素声明来进行声明。元素声明使用下面的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 类别&gt;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 (元素内容)&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-2-空元素"><a href="#3-2-3-2-空元素" class="headerlink" title="3.2.3.2 空元素"></a>3.2.3.2 空元素</h5><p>空元素通过类别关键词EMPTY进行声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 EMPTY&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT br EMPTY&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-3-只有-PCDATA-的元素"><a href="#3-2-3-3-只有-PCDATA-的元素" class="headerlink" title="3.2.3.3 只有 PCDATA 的元素"></a>3.2.3.3 只有 PCDATA 的元素</h5><p>只有 PCDATA 的元素通过圆括号中的 #PCDATA 进行声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-4-带有任何内容的元素"><a href="#3-2-3-4-带有任何内容的元素" class="headerlink" title="3.2.3.4 带有任何内容的元素"></a>3.2.3.4 带有任何内容的元素</h5><p>通过类别关键词 ANY 声明的元素，可包含任何可解析数据的组合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 ANY&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note ANY&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-5-带有子元素（序列）的元素"><a href="#3-2-3-5-带有子元素（序列）的元素" class="headerlink" title="3.2.3.5 带有子元素（序列）的元素"></a>3.2.3.5 带有子元素（序列）的元素</h5><p>带有一个或多个子元素的元素通过圆括号中的子元素名进行声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 (子元素名称 1)&gt;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 (子元素名称 1,子元素名称 2,.....)&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br></pre></td></tr></table></figure>

<p>当子元素按照由逗号分隔开的序列进行声明时，这些子元素必须按照相同的顺序出现在文档中。在一个完整的声明中，子元素也必须被声明，同时子元素也可拥有子元素。”note” 元素的完整声明是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body    (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-6-声明只出现一次的元素"><a href="#3-2-3-6-声明只出现一次的元素" class="headerlink" title="3.2.3.6 声明只出现一次的元素"></a>3.2.3.6 声明只出现一次的元素</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 (子元素名称)&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (message)&gt;</span><br></pre></td></tr></table></figure>

<p>上面的例子声明了：message 子元素必须出现一次，并且必须只在 “note” 元素中出现一次。</p>
<h5 id="3-2-3-7-声明最少出现一次的元素"><a href="#3-2-3-7-声明最少出现一次的元素" class="headerlink" title="3.2.3.7 声明最少出现一次的元素"></a>3.2.3.7 声明最少出现一次的元素</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 (子元素名称+)&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (message+)&gt;</span><br></pre></td></tr></table></figure>

<p>上面的例子中的加号声明了：message 子元素必须在 “note” 元素内出现至少一次。</p>
<h5 id="3-2-3-8-声明出现零次或多次的元素"><a href="#3-2-3-8-声明出现零次或多次的元素" class="headerlink" title="3.2.3.8 声明出现零次或多次的元素"></a>3.2.3.8 声明出现零次或多次的元素</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 (子元素名称*)&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (message*)&gt;</span><br></pre></td></tr></table></figure>

<p>上面的例子中的星号声明了：子元素 message 可在 “note” 元素内出现零次或多次。</p>
<h5 id="3-2-3-9-声明出现零次或一次的元素"><a href="#3-2-3-9-声明出现零次或一次的元素" class="headerlink" title="3.2.3.9 声明出现零次或一次的元素"></a>3.2.3.9 声明出现零次或一次的元素</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 (子元素名称?)&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (message?)&gt;</span><br></pre></td></tr></table></figure>

<p>上面的例子中的问号声明了：子元素 message 可在 “note” 元素内出现零次或一次。</p>
<h5 id="3-2-3-10-声明“非…-既…”类型的内容"><a href="#3-2-3-10-声明“非…-既…”类型的内容" class="headerlink" title="3.2.3.10 声明“非…/既…”类型的内容"></a>3.2.3.10 声明“非…/既…”类型的内容</h5><p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,header,(message|body))&gt;</span><br></pre></td></tr></table></figure>

<p>上面的例子声明了：”note” 元素必须包含 “to” 元素、”from” 元素、”header” 元素，以及非 “message” 元素既 “body” 元素。</p>
<h5 id="3-2-3-11-声明混合型的内容"><a href="#3-2-3-11-声明混合型的内容" class="headerlink" title="3.2.3.11 声明混合型的内容"></a>3.2.3.11 声明混合型的内容</h5><p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</span><br></pre></td></tr></table></figure>

<p>上面的例子声明了：”note” 元素可包含出现零次或多次的 PCDATA、”to”、”from”、”header” 或者 “message”。</p>
<h4 id="3-2-4-属性"><a href="#3-2-4-属性" class="headerlink" title="3.2.4 属性"></a>3.2.4 属性</h4><h5 id="3-2-4-1-声明属性"><a href="#3-2-4-1-声明属性" class="headerlink" title="3.2.4.1 声明属性"></a>3.2.4.1 声明属性</h5><p>属性声明使用下列语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</span><br></pre></td></tr></table></figure>

<p>DTD 实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>XML 实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;payment type=&quot;check&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-4-2-以下是属性类型的选项："><a href="#3-2-4-2-以下是属性类型的选项：" class="headerlink" title="3.2.4.2 以下是属性类型的选项："></a>3.2.4.2 以下是<em>属性类型</em>的选项：</h5><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CDATA</td>
<td align="left">值为字符数据 (character data)</td>
</tr>
<tr>
<td align="left">(<em>en1</em>|<em>en2</em>|..)</td>
<td align="left">此值是枚举列表中的一个值</td>
</tr>
<tr>
<td align="left">ID</td>
<td align="left">值为唯一的 id</td>
</tr>
<tr>
<td align="left">IDREF</td>
<td align="left">值为另外一个元素的 id</td>
</tr>
<tr>
<td align="left">IDREFS</td>
<td align="left">值为其他 id 的列表</td>
</tr>
<tr>
<td align="left">NMTOKEN</td>
<td align="left">值为合法的 XML 名称</td>
</tr>
<tr>
<td align="left">NMTOKENS</td>
<td align="left">值为合法的 XML 名称的列表</td>
</tr>
<tr>
<td align="left">ENTITY</td>
<td align="left">值是一个实体</td>
</tr>
<tr>
<td align="left">ENTITIES</td>
<td align="left">值是一个实体列表</td>
</tr>
<tr>
<td align="left">NOTATION</td>
<td align="left">此值是符号的名称</td>
</tr>
<tr>
<td align="left">xml:</td>
<td align="left">值是一个预定义的 XML 值</td>
</tr>
</tbody></table>
<h5 id="3-2-4-3-默认值参数可使用下列值："><a href="#3-2-4-3-默认值参数可使用下列值：" class="headerlink" title="3.2.4.3 默认值参数可使用下列值："></a>3.2.4.3 默认值参数可使用下列值：</h5><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">值</td>
<td align="left">属性的默认值</td>
</tr>
<tr>
<td align="left">#REQUIRED</td>
<td align="left">属性值是必需的</td>
</tr>
<tr>
<td align="left">#IMPLIED</td>
<td align="left">属性不是必需的</td>
</tr>
<tr>
<td align="left">#FIXED value</td>
<td align="left">属性值是固定的</td>
</tr>
</tbody></table>
<h5 id="3-2-4-4-规定一个默认的属性值"><a href="#3-2-4-4-规定一个默认的属性值" class="headerlink" title="3.2.4.4 规定一个默认的属性值"></a>3.2.4.4 规定一个默认的属性值</h5><p>DTD:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT square EMPTY&gt;</span><br><span class="line">&lt;!ATTLIST square width CDATA &quot;0&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>合法的 XML:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;square width=&quot;100&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，”square” 被定义为带有 CDATA 类型的 “width” 属性的空元素。如果宽度没有被设定，其默认值为0 。</p>
<h5 id="3-2-4-5-IMPLIED"><a href="#3-2-4-5-IMPLIED" class="headerlink" title="3.2.4.5 #IMPLIED"></a>3.2.4.5 #IMPLIED</h5><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 元素名称 属性名称 属性类型 #IMPLIED&gt;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<p>DTD:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST contact fax CDATA #IMPLIED&gt;</span><br></pre></td></tr></table></figure>

<p>合法的 XML:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;contact fax=&quot;555-667788&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>合法的 XML:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;contact /&gt;</span><br></pre></td></tr></table></figure>

<p>假如您不希望强制作者包含属性，并且您没有默认值选项的话，请使用关键词 #IMPLIED。</p>
<h5 id="3-2-4-6-REQUIRED"><a href="#3-2-4-6-REQUIRED" class="headerlink" title="3.2.4.6 #REQUIRED"></a>3.2.4.6 #REQUIRED</h5><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 元素名称 属性名称 属性类型 #REQUIRED&gt;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<p>DTD:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST person number CDATA #REQUIRED&gt;</span><br></pre></td></tr></table></figure>

<p>合法的 XML:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;person number=&quot;5677&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>非法的 XML:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;person /&gt;</span><br></pre></td></tr></table></figure>

<p>假如您没有默认值选项，但是仍然希望强制作者提交属性的话，请使用关键词 #REQUIRED。</p>
<h5 id="3-2-4-7-FIXED"><a href="#3-2-4-7-FIXED" class="headerlink" title="3.2.4.7 #FIXED"></a>3.2.4.7 #FIXED</h5><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 元素名称 属性名称 属性类型 #FIXED &quot;value&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<p>DTD:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST sender company CDATA #FIXED &quot;Microsoft&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>合法的 XML:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sender company=&quot;Microsoft&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>非法的 XML:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sender company=&quot;W3School&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>如果您希望属性拥有固定的值，并不允许作者改变这个值，请使用 #FIXED 关键词。如果作者使用了不同的值，XML 解析器会返回错误。</p>
<h5 id="3-2-4-8-列举属性值"><a href="#3-2-4-8-列举属性值" class="headerlink" title="3.2.4.8 列举属性值"></a>3.2.4.8 列举属性值</h5><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 元素名称 属性名称 (en1|en2|..) 默认值&gt;</span><br></pre></td></tr></table></figure>

<p>DTD 例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST payment type (check|cash) &quot;cash&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>XML 例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;payment type=&quot;check&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;payment type=&quot;cash&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-schema"><a href="#3-3-schema" class="headerlink" title="3.3 schema"></a>3.3 schema</h3><h4 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h4><p>XML Schema 的作用是定义 XML 文档的合法构建模块，类似 DTD。</p>
<h5 id="3-3-1-1-XML-Schema"><a href="#3-3-1-1-XML-Schema" class="headerlink" title="3.3.1.1 XML Schema:"></a>3.3.1.1 XML Schema:</h5><ul>
<li>定义可出现在文档中的元素</li>
<li>定义可出现在文档中的属性</li>
<li>定义哪个元素是子元素</li>
<li>定义子元素的次序</li>
<li>定义子元素的数目</li>
<li>定义元素是否为空，或者是否可包含文本</li>
<li>定义元素和属性的数据类型</li>
<li>定义元素和属性的默认值以及固定值</li>
</ul>
<h5 id="3-3-1-2-为何使用"><a href="#3-3-1-2-为何使用" class="headerlink" title="3.3.1.2 为何使用"></a>3.3.1.2 为何使用</h5><ul>
<li>XML Schema 可针对未来的需求进行扩展</li>
<li>XML Schema 更完善，功能更强大</li>
<li>XML Schema 基于 XML 编写</li>
<li>XML Schema 支持数据类型</li>
<li>XML Schema 支持命名空间</li>
</ul>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;xs:schema xmlns:xs=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span><br><span class="line">targetNamespace=<span class="string">&quot;http://www.w3school.com.cn&quot;</span></span><br><span class="line">xmlns=<span class="string">&quot;http://www.w3school.com.cn&quot;</span></span><br><span class="line">elementFormDefault=<span class="string">&quot;qualified&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=<span class="string">&quot;note&quot;</span>&gt;</span><br><span class="line">    &lt;xs:complexType&gt;</span><br><span class="line">      &lt;xs:sequence&gt;</span><br><span class="line">	&lt;xs:element name=<span class="string">&quot;to&quot;</span> type=<span class="string">&quot;xs:string&quot;</span>/&gt;</span><br><span class="line">	&lt;xs:element name=<span class="string">&quot;from&quot;</span> type=<span class="string">&quot;xs:string&quot;</span>/&gt;</span><br><span class="line">	&lt;xs:element name=<span class="string">&quot;heading&quot;</span> type=<span class="string">&quot;xs:string&quot;</span>/&gt;</span><br><span class="line">	&lt;xs:element name=<span class="string">&quot;body&quot;</span> type=<span class="string">&quot;xs:string&quot;</span>/&gt;</span><br><span class="line">      &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:schema&gt;</span><br></pre></td></tr></table></figure>

<p>note 元素是一个复合类型，因为它包含其他的子元素。其他元素 (to, from, heading, body) 是简易类型，因为它们没有包含其他元素。您将在下面的章节学习更多有关复合类型和简易类型的知识。</p>
<p>3.3.1.3 引用</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"> &lt;a:students xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">			xmlns:a=<span class="string">&quot;http://www.blb.com/xml&quot;</span></span><br><span class="line">			xsi:schemaLocation=<span class="string">&quot;http://www.blb.com/xml student.xsd&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;</span><br><span class="line">	&lt;a:student number=<span class="string">&quot;blb_0001&quot;</span>&gt;</span><br><span class="line">		&lt;a:name&gt;six&lt;/a:name&gt;</span><br><span class="line">		&lt;a:age&gt;<span class="number">111</span>&lt;/a:age&gt;</span><br><span class="line">		&lt;a:sex&gt;boy&lt;/a:sex&gt;</span><br><span class="line">	&lt;/a:student&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/a:students&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>schema文件的后缀是xsd。</li>
<li>schema的导入信息都是写在根标签中的。</li>
<li>在根标签中需要引入xsi的前缀<code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code></li>
<li>通过<code>xsi:schemaLocation</code>指定要使用的schema文件（<code>student.xsd</code>），并且给这个文件取一个别名<code>http://www.blb.com/xml</code></li>
<li>通过<code>xmlns:命名空间</code>给这个别名命名一个命名空间的前缀，定义了前缀以后标签需要加上前缀</li>
<li>可以不设置命名空间，则标签默认来自此xsd文件，如果有多个schema文件，只能有1个默认。</li>
</ul>
<h4 id="3-3-2-简单的类型"><a href="#3-3-2-简单的类型" class="headerlink" title="3.3.2 简单的类型"></a>3.3.2 简单的类型</h4><h5 id="3-2-2-1-元素与类型"><a href="#3-2-2-1-元素与类型" class="headerlink" title="3.2.2.1 元素与类型"></a>3.2.2.1 元素与类型</h5><h6 id="3-2-2-1-1-什么是简易元素？"><a href="#3-2-2-1-1-什么是简易元素？" class="headerlink" title="3.2.2.1.1 什么是简易元素？"></a>3.2.2.1.1 什么是简易元素？</h6><p>简易元素指那些仅包含文本的元素。它不会包含任何其他的元素或属性。</p>
<p>不过，“仅包含文本”这个限定却很容易造成误解。文本有很多类型。它可以是 XML Schema 定义中包括的类型中的一种（布尔、字符串、数据等等），或者它也可以是您自行定义的定制类型。</p>
<p>您也可向数据类型添加限定（即 facets），以此来限制它的内容，或者您可以要求数据匹配某种特定的模式。</p>
<h6 id="3-2-2-1-2-定义简易元素"><a href="#3-2-2-1-2-定义简易元素" class="headerlink" title="3.2.2.1.2 定义简易元素"></a>3.2.2.1.2 定义简易元素</h6><p>定义简易元素的语法：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=<span class="string">&quot;xxx&quot;</span> type=<span class="string">&quot;yyy&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>此处 xxx 指元素的名称，yyy 指元素的数据类型。XML Schema 拥有很多内建的数据类型。</p>
<h6 id="3-2-2-1-3-最常用的类型是："><a href="#3-2-2-1-3-最常用的类型是：" class="headerlink" title="3.2.2.1.3 最常用的类型是："></a>3.2.2.1.3 最常用的类型是：</h6><ul>
<li>xs:string</li>
<li>xs:decimal</li>
<li>xs:integer</li>
<li>xs:boolean</li>
<li>xs:date</li>
<li>xs:time</li>
</ul>
<p>例子：</p>
<p>这是一些 XML 元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;lastname&gt;Smith&lt;/lastname&gt;</span><br><span class="line">&lt;age&gt;28&lt;/age&gt;</span><br><span class="line">&lt;dateborn&gt;1980-03-27&lt;/dateborn&gt;</span><br></pre></td></tr></table></figure>

<p>这是相应的简易元素定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">&lt;xs:element name=&quot;age&quot; type=&quot;xs:integer&quot;/&gt;</span><br><span class="line">&lt;xs:element name=&quot;dateborn&quot; type=&quot;xs:date&quot;/&gt; </span><br></pre></td></tr></table></figure>

<h6 id="3-2-2-1-4-简易元素的默认值和固定值"><a href="#3-2-2-1-4-简易元素的默认值和固定值" class="headerlink" title="3.2.2.1.4 简易元素的默认值和固定值"></a>3.2.2.1.4 简易元素的默认值和固定值</h6><p>简易元素可拥有指定的默认值或固定值。</p>
<p>当没有其他的值被规定时，默认值就会自动分配给元素。</p>
<p>在下面的例子中，缺省值是 “red”：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=<span class="string">&quot;color&quot;</span> type=<span class="string">&quot;xs:string&quot;</span> default=<span class="string">&quot;red&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>固定值同样会自动分配给元素，并且您无法规定另外一个值。</p>
<p>在下面的例子中，固定值是 “red”：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=<span class="string">&quot;color&quot;</span> type=<span class="string">&quot;xs:string&quot;</span> fixed=<span class="string">&quot;red&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h6 id="3-2-2-1-5-属性的默认值和固定值"><a href="#3-2-2-1-5-属性的默认值和固定值" class="headerlink" title="3.2.2.1.5 属性的默认值和固定值"></a>3.2.2.1.5 属性的默认值和固定值</h6><p>属性可拥有指定的默认值或固定值。</p>
<p>当没有其他的值被规定时，默认值就会自动分配给元素。</p>
<p>在下面的例子中，缺省值是 “EN”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; default=&quot;EN&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>固定值同样会自动分配给元素，并且您无法规定另外的值。</p>
<p>在下面的例子中，固定值是 “EN”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; fixed=&quot;EN&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h6 id="3-2-2-1-6-可选的和必需的属性"><a href="#3-2-2-1-6-可选的和必需的属性" class="headerlink" title="3.2.2.1.6 可选的和必需的属性"></a>3.2.2.1.6 可选的和必需的属性</h6><p>在缺省的情况下，属性是可选的。如需规定属性为必选，请使用 “use” 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-2-限定"><a href="#3-2-2-2-限定" class="headerlink" title="3.2.2.2  限定"></a>3.2.2.2  限定</h5><p><strong>限定（restriction）用于为 XML 元素或者属性定义可接受的值。对 XML 元素的限定被称为 facet。</strong></p>
<h6 id="3-2-2-2-1-对值的限定"><a href="#3-2-2-2-1-对值的限定" class="headerlink" title="3.2.2.2.1 对值的限定"></a>3.2.2.2.1 对值的限定</h6><p>下面的例子定义了带有一个限定且名为 “age” 的元素。age 的值不能低于 0 或者高于 120：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;age&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:integer&quot;&gt;</span><br><span class="line">    &lt;xs:minInclusive value=&quot;0&quot;/&gt;</span><br><span class="line">    &lt;xs:maxInclusive value=&quot;120&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<h6 id="3-2-2-2-2-对一组值的限定"><a href="#3-2-2-2-2-对一组值的限定" class="headerlink" title="3.2.2.2.2 对一组值的限定"></a>3.2.2.2.2 对一组值的限定</h6><p>如需把 XML 元素的内容限制为一组可接受的值，我们要使用枚举约束（enumeration constraint）。</p>
<p>下面的例子定义了带有一个限定的名为 “car” 的元素。可接受的值只有：Audi, Golf, BMW：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;car&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;Audi&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;Golf&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;BMW&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>上面的例子也可以被写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;car&quot; type=&quot;carType&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType name=&quot;carType&quot;&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;Audi&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;Golf&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;BMW&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注释：</strong>在这种情况下，类型 “carType” 可被其他元素使用，因为它不是 “car” 元素的组成部分。</p>
<h6 id="3-2-2-2-3-对一系列值的限定"><a href="#3-2-2-2-3-对一系列值的限定" class="headerlink" title="3.2.2.2.3 对一系列值的限定"></a>3.2.2.2.3 对一系列值的限定</h6><p>如需把 XML 元素的内容限制定义为一系列可使用的数字或字母，我们要使用模式约束（pattern constraint）。</p>
<p>下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值只有小写字母 a - z 其中的一个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;letter&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:pattern value=&quot;[a-z]&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>下一个例子定义了带有一个限定的名为 “initials” 的元素。可接受的值是大写字母 A - Z 其中的三个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;initials&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:pattern value=&quot;[A-Z][A-Z][A-Z]&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>下一个例子也定义了带有一个限定的名为 “initials” 的元素。可接受的值是大写或小写字母 a - z 其中的三个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;initials&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:pattern value=&quot;[a-zA-Z][a-zA-Z][a-zA-Z]&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>下一个例子定义了带有一个限定的名为 “choice 的元素。可接受的值是字母 x, y 或 z 中的一个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;choice&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:pattern value=&quot;[xyz]&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>下一个例子定义了带有一个限定的名为 “prodid” 的元素。可接受的值是五个阿拉伯数字的一个序列，且每个数字的范围是 0-9：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;prodid&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:integer&quot;&gt;</span><br><span class="line">    &lt;xs:pattern value=&quot;[0-9][0-9][0-9][0-9][0-9]&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<h6 id="3-2-2-2-4-对一系列值的其他限定"><a href="#3-2-2-2-4-对一系列值的其他限定" class="headerlink" title="3.2.2.2.4 对一系列值的其他限定"></a>3.2.2.2.4 对一系列值的其他限定</h6><p>下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是 a - z 中零个或多个字母：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;letter&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:pattern value=&quot;([a-z])*&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是一对或多对字母，每对字母由一个小写字母后跟一个大写字母组成。举个例子，”sToP”将会通过这种模式的验证，但是 “Stop”、”STOP” 或者 “stop” 无法通过验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;letter&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:pattern value=&quot;([a-z][A-Z])+&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>下面的例子定义了带有一个限定的名为 “gender” 的元素。可接受的值是 male 或者 female：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;gender&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:pattern value=&quot;male|female&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>下面的例子定义了带有一个限定的名为 “password” 的元素。可接受的值是由 8 个字符组成的一行字符，这些字符必须是大写或小写字母 a - z 亦或数字 0 - 9：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;password&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:pattern value=&quot;[a-zA-Z0-9]&#123;8&#125;&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<h6 id="3-2-2-2-5-对空白字符的限定"><a href="#3-2-2-2-5-对空白字符的限定" class="headerlink" title="3.2.2.2.5 对空白字符的限定"></a>3.2.2.2.5 对空白字符的限定</h6><p>如需规定对空白字符（whitespace characters）的处理方式，我们需要使用 whiteSpace 限定。</p>
<p>下面的例子定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “preserve”，这意味着 XML 处理器不会移除任何空白字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;address&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:whiteSpace value=&quot;preserve&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “replace”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;address&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:whiteSpace value=&quot;replace&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “collapse”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符会被替换为空格，开头和结尾的空格会被移除，而多个连续的空格会被缩减为一个单一的空格）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;address&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:whiteSpace value=&quot;collapse&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<h6 id="3-2-2-2-6-对长度的限定"><a href="#3-2-2-2-6-对长度的限定" class="headerlink" title="3.2.2.2.6 对长度的限定"></a>3.2.2.2.6 对长度的限定</h6><p>如需限制元素中值的长度，我们需要使用 length、maxLength 以及 minLength 限定。</p>
<p>本例定义了带有一个限定且名为 “password” 的元素。其值必须精确到 8 个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;password&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:length value=&quot;8&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<p>这个例子也定义了带有一个限定的名为 “password” 的元素。其值最小为 5 个字符，最大为 8 个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xs:element name=&quot;password&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:minLength value=&quot;5&quot;/&gt;</span><br><span class="line">    &lt;xs:maxLength value=&quot;8&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;/xs:element&gt; </span><br></pre></td></tr></table></figure>

<h6 id="3-2-2-2-7-数据类型的限定"><a href="#3-2-2-2-7-数据类型的限定" class="headerlink" title="3.2.2.2.7 数据类型的限定"></a>3.2.2.2.7 数据类型的限定</h6><table>
<thead>
<tr>
<th align="left">限定</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">enumeration</td>
<td align="left">定义可接受值的一个列表</td>
</tr>
<tr>
<td align="left">fractionDigits</td>
<td align="left">定义所允许的最大的小数位数。必须大于等于0。</td>
</tr>
<tr>
<td align="left">length</td>
<td align="left">定义所允许的字符或者列表项目的精确数目。必须大于或等于0。</td>
</tr>
<tr>
<td align="left">maxExclusive</td>
<td align="left">定义数值的上限。所允许的值必须小于此值。</td>
</tr>
<tr>
<td align="left">maxInclusive</td>
<td align="left">定义数值的上限。所允许的值必须小于或等于此值。</td>
</tr>
<tr>
<td align="left">maxLength</td>
<td align="left">定义所允许的字符或者列表项目的最大数目。必须大于或等于0。</td>
</tr>
<tr>
<td align="left">minExclusive</td>
<td align="left">定义数值的下限。所允许的值必需大于此值。</td>
</tr>
<tr>
<td align="left">minInclusive</td>
<td align="left">定义数值的下限。所允许的值必需大于或等于此值。</td>
</tr>
<tr>
<td align="left">minLength</td>
<td align="left">定义所允许的字符或者列表项目的最小数目。必须大于或等于0。</td>
</tr>
<tr>
<td align="left">pattern</td>
<td align="left">定义可接受的字符的精确序列。</td>
</tr>
<tr>
<td align="left">totalDigits</td>
<td align="left">定义所允许的阿拉伯数字的精确位数。必须大于0。</td>
</tr>
<tr>
<td align="left">whiteSpace</td>
<td align="left">定义空白字符（换行、回车、空格以及制表符）的处理方式。</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.blb.com/xml&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.blb.com/xml&quot;</span> <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  定义标签students  类型是自定义类型studentsType --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;students&quot;</span> <span class="attr">type</span>=<span class="string">&quot;studentsType&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;studentsType&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 标签student，类型是自定义类型studentType  最少出现次数是1，最多次数不限 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">type</span>=<span class="string">&quot;studentType&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义自定义类型studentType --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;studentType&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- name标签是字符串类型  --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> /&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- age标签是自定义类型ageType  --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ageType&quot;</span> /&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- sex标签是自定义类型sexType  --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">type</span>=<span class="string">&quot;sexType&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 属性number，类型是自定义类型numberType，且为必须的 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">type</span>=<span class="string">&quot;numberType&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- sexType自定义类型 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;sexType&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 枚举：值只能是boy或者girl   --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&quot;boy&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&quot;girl&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 自定义类型ageType  范围从0-300之间 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;ageType&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:integer&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:minInclusive</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:maxInclusive</span> <span class="attr">value</span>=<span class="string">&quot;300&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 自定义numberType类型，必须以blb_开头，后面跟4位数字 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;numberType&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:pattern</span> <span class="attr">value</span>=<span class="string">&quot;blb_\d&#123;4&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>定义好的xml文件我们通常需要使用程序来操作，这就要求我们能够解析XML，主要的解析方式有DOM、SAX。DOM主要基于文档对象模型，操作方便，相对更占空间。SAX基于事件驱动。我们通常使用框架dom4j来解析。</p>
<p>DOM解析：易用性强，使用DOM时，将把所有的XML文档信息都存于内存中，并且遍历简单，支持XPath，增强了易用性。效率低，解析速度慢，内存占用量过高，对于大文件来说几乎不可能使用。</p>
<p>SAX解析：SAX是一个用于处理XML事件驱动的“推”模型，虽然它不是W3C标准，但它却是一个得到了广泛认可的API。SAX模型最大的优点是内存消耗小。</p>
<h4 id="4-1-DOM4J"><a href="#4-1-DOM4J" class="headerlink" title="4.1  DOM4J"></a>4.1  DOM4J</h4><p>​    dom4j是一个Java的XML API，是jdom的升级品，用来读写XML文件的。dom4j是一个十分优秀的Java API，具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom技术，同时它也是一个开放源代码的软件。如今可以看到越来越多的Java软件都在使用dom4j来读写XML，特别值得一提的是连Sun的JAXM也在用dom4j。这已经是必须使用的jar包。</p>
<h4 id="4-2-文档对象的获取"><a href="#4-2-文档对象的获取" class="headerlink" title="4.2  文档对象的获取"></a>4.2  文档对象的获取</h4><p>假设需解析的文档为student.xml，内容如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;blb_0001&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>six<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>28<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sex</span>&gt;</span>boy<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;blb_0002&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>seven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>29<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sex</span>&gt;</span>girl<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>SAX方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = Demo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;student.xml&quot;</span>);	</span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document document = reader.read(in);</span><br></pre></td></tr></table></figure></li>
<li><p>DOM方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">InputStream in = Demo3.class.getClassLoader().getResourceAsStream(<span class="string">&quot;student.xml&quot;</span>);</span><br><span class="line">org.w3c.dom.Document w3cdoc=db.parse(in);</span><br><span class="line">DOMReader domReader=<span class="keyword">new</span> DOMReader();</span><br><span class="line"><span class="comment">//将org.w3c.dom.Document转成org.dom4j.Document</span></span><br><span class="line">org.dom4j.Document document=domReader.read(w3cdoc);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-3-常用方法"><a href="#4-3-常用方法" class="headerlink" title="4.3  常用方法"></a>4.3  常用方法</h4><ul>
<li><p>根元素的获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Element root = document.getRootElement();</span><br></pre></td></tr></table></figure></li>
<li><p>获取标签下的所有子标签的相关信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Element&gt; it =  root.elementIterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Element e = it.next();</span><br><span class="line">  <span class="comment">//   e.getName 获取元素的标签名</span></span><br><span class="line">    System.out.print(e.getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    <span class="comment">// e.attributeValue(&quot;number&quot;)  获取标签指定属性的值</span></span><br><span class="line">    System.out.print(e.attributeValue(<span class="string">&quot;number&quot;</span>) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取子标签下的子标签</span></span><br><span class="line">    Element c1 = e.element(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="comment">// c1.getText() 获取标签内的文本内容。</span></span><br><span class="line">    System.out.println(c1.getText());</span><br><span class="line">    			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-4-xpath解析"><a href="#4-4-xpath解析" class="headerlink" title="4.4  xpath解析"></a>4.4  xpath解析</h4><p>​    当我们使用dom的api解析时比较麻烦，尤其是嵌套层数比较多的时候。我们可以使用xpath表达式的方式来解析。使用这个功能要求dom4j的版本在2.0以上。</p>
<ul>
<li>```java<br>// 查找number属性值为blb_0002的students标签下的student子标签<br>Node n = document.selectSingleNode(“//students/student[@number=’blb_0002’]”);<br>System.out.println(n.getName());// selectSingleNode  获取某一个节点，如果有多个返回找到的第1个<br>Node selectSingleNode = n.selectSingleNode(“name”);<br>String name = selectSingleNode.getText();<br>System.out.println(name);// 遍历，获取students标签下的所有student标签,路径中的”//“表示忽略层级，不使用则必须从根开始<br>List<Node> nodes = document.selectNodes(“//students/student”);<br>ListIterator<Node> listIterator = nodes.listIterator();<br>// 通过迭代器遍历<br>while(listIterator.hasNext()){<pre><code>Node n = listIterator.next();
// n.valueOf(&quot;@number&quot;)获取Node的number属性的值
String number =  n.valueOf(&quot;@number&quot;);
System.out.println(number);
//相对路径用 name   
Node selectSingleNode = n.selectSingleNode(&quot;name&quot;);
// 获取节点的文本内容
String name = selectSingleNode.getText();
System.out.println(name);
</code></pre>
}// 还可以通过Node的匹配的条件来过滤<br>List<Node> nodes = document.selectNodes(“//students/student”);<br>Iterator<Node> iterator = nodes.iterator();<br>while(iterator.hasNext()){<pre><code>Node n = iterator.next();
//            根据条件过滤 number属性值不为blb_0001
if(n.matches(&quot;@number!=&#39;blb_0001&#39;&quot;))&#123;
    System.out.println(n.getName());
&#125;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 5.XML生成</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">//目标：将对象写入到 XML文件当中</span><br><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">public class Test01 &#123;</span><br><span class="line">public static void main(String[] args)  throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    //创建一个对象，将对象写入到XML文件当中</span><br><span class="line">    Hero hh = new Hero(1,&quot;赵云&quot;,20);</span><br><span class="line">    //1.需要创建一些列的对象，添加到Document树当中</span><br><span class="line">    //创建Document树在内存当中。</span><br><span class="line">    Document doc = DocumentHelper.createDocument();</span><br><span class="line">    Element root = doc.addElement(&quot;lol&quot;);</span><br><span class="line">    Element hero = root.addElement(&quot;hero&quot;);</span><br><span class="line">    hero.addAttribute(&quot;id&quot;,hh.getId()+&quot;&quot;);</span><br><span class="line">    hero.addElement(&quot;name&quot;).addText(hh.getName());</span><br><span class="line">    hero.addElement(&quot;age&quot;).addText(hh.getAge()+&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    //2. 准备数据</span><br><span class="line">    String path = &quot;JavaSEDay21\\dir\\14_英雄联盟.xml&quot;;</span><br><span class="line">    FileWriter fw = new FileWriter(path);</span><br><span class="line">    OutputFormat format = new OutputFormat();</span><br><span class="line">    format.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line">    //3.直接往XML当中写入。 XMLWriter类</span><br><span class="line">    XMLWriter xw = new XMLWriter(fw,format);</span><br><span class="line">    xw.write(doc);</span><br><span class="line">    xw.flush();</span><br><span class="line">    xw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></Node></Node></Node></Node></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2021/08/10/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>​     JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p>
<p>​    这里的反理解为反转，控制反转。假如我们需要零花钱就找老婆要，这是“正”。但是现在反过来是老婆主动给我们，这是“反”。虽然最后的结果都一样，都是老婆给我们零花钱，但是方式不一样。程序中以前创建对象是通过<code>new</code>来创建对象，自上而下。但是现在我们可以使用反射技术反过来自下而上的提供访问。反射相关的类都在<code>java.lang.reflect</code>包下。</p>
<ul>
<li><p>优点 ：在程序运行时，对类和对象的信息进行解析、调用方法，极大地提高了灵活性。</p>
</li>
<li><p>缺点 ：由于需要动态解析类的信息，降低了程序性能。</p>
</li>
</ul>
<h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2.  类加载器"></a>2.  类加载器</h2><p>Java执行的过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HelloWorld.java ---javac 编译 ---&gt; HelloWorld.class ----java 运行 ---&gt; 可见的程序。</span><br><span class="line"></span><br><span class="line">编译的过程: 检查，校验，预编译的过程。</span><br><span class="line">运行的过程: 将字节码，加载到内存的过程。会通过 类加载器加载。</span><br><span class="line"></span><br><span class="line">简单一点说: 类加载器是用来加载字节码文件的。 ClassLoader</span><br></pre></td></tr></table></figure>

<p>理解类加载器（双亲委派机制）</p>
<p><img src="/2021/08/10/%E5%8F%8D%E5%B0%84/image-20210810091555926.png" alt="image-20210810091555926"></p>
<p><strong>ClassLoader的两个应用案例</strong></p>
<p>案例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类加载器的一个API需要大家掌握</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到类加载器的对象</span></span><br><span class="line">        ClassLoader loader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="comment">//可以去加载来自于 src 文件夹下面的文件信息，获取到流对象</span></span><br><span class="line">        <span class="comment">//强调: 可以将 src 文件夹下面的文件，转换成为字节输入流 InputStream</span></span><br><span class="line">        InputStream is = loader.getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用Properties去加载数据</span></span><br><span class="line">        Properties pp = <span class="keyword">new</span> Properties();</span><br><span class="line">        pp.load(is);</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到数据</span></span><br><span class="line">        String username = pp.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = pp.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;username = &quot;</span> + username);  <span class="comment">//username = zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;password = &quot;</span> + password);  <span class="comment">//password = 123456</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类加载器的一个API需要大家掌握</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到类加载器的对象，可以直接获取到流对象</span></span><br><span class="line">        <span class="comment">//强调: 可以将 src 文件夹下面的文件，转换成为字节输入流 InputStream</span></span><br><span class="line">        InputStream is = ClassLoader.getSystemResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用Properties去加载数据</span></span><br><span class="line">        Properties pp = <span class="keyword">new</span> Properties();</span><br><span class="line">        pp.load(is);</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到数据</span></span><br><span class="line">        String username = pp.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = pp.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;username = &quot;</span> + username);  <span class="comment">//username = zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;password = &quot;</span> + password);  <span class="comment">//password = 123456</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-反射原理"><a href="#3-反射原理" class="headerlink" title="3.  反射原理"></a>3.  反射原理</h2><p>原理图</p>
<p><img src="/2021/08/10/%E5%8F%8D%E5%B0%84/image-20210810095807884.png" alt="image-20210810095807884"></p>
<h2 id="4-字节码对象"><a href="#4-字节码对象" class="headerlink" title="4. 字节码对象"></a>4. 字节码对象</h2><p>面向对象的过程中，把对象的相同特征跟行为能力提取出来成为类，比如人类、桌子类、猫类、狗类……那这些类又具有什么相同的特征跟行为能力？是否可以继续往上抽取出来呢？答案是肯定的。所有的类可以继续抽象出<code>Class</code>类、所有的方法可以抽取为<code>Method</code>类、所有的字段抽取为<code>Filed</code>类等等。</p>
<p>​    通过<code>Class</code>、<code>Method</code>、 <code>Filed</code>等类的API间接创建、操作对象的方式称为反射机制。</p>
<p>​    使用反射机制首先要获取对应类的<code>Class</code>对象。获取<code>Class</code>对象有3种方式</p>
<blockquote>
<p>方式1—通过类名</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Person.class ;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>方式2—通过对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class  clazz = <span class="keyword">new</span> Person().getClass();</span><br></pre></td></tr></table></figure>



<blockquote>
<p>方式3—类路径的字符串</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class  clazz = Class.forName(<span class="string">&quot;com.blb.Person&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Reflect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//      第1种方式：</span></span><br><span class="line">        Class clazz = Person.class ;</span><br><span class="line"><span class="comment">//		第2种方式：</span></span><br><span class="line"><span class="comment">//		Class  clazz = Class.forName(&quot;com.blb.Person&quot;);</span></span><br><span class="line"><span class="comment">//		第3种方式：</span></span><br><span class="line"><span class="comment">//		Person p  = new Person();</span></span><br><span class="line"><span class="comment">//		Class clazz = p.getClass();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h4 id="5-1-无参构造"><a href="#5-1-无参构造" class="headerlink" title="5.1 无参构造"></a>5.1 无参构造</h4><blockquote>
<p> 方式1</p>
</blockquote>
<p>可以通过<code>Class</code>对象的<code>newInstance</code>方法直接通过无参的构造方法创造对象。这种方式只能针对无参的构造方法使用。</p>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person  person = (Person) clazz.newInstance();</span><br></pre></td></tr></table></figure>



<blockquote>
<p>方式2</p>
</blockquote>
<p>​    所有的构造方法也同样的映射成<code>Constructor</code>类型的对象，所以也可以使用<code>Constructor</code>对象的方式构建对象。</p>
<ul>
<li><code>getConstructor</code>：获取所有的public类型构造器</li>
<li><code>getDeclaredConstructor</code> : 获取自身定义的所有构造器，包括<code>private</code>的构造器</li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Constructor c = clazz.getConstructor();</span></span><br><span class="line">Constructor c = clazz.getDeclaredConstructor();</span><br><span class="line"><span class="comment">// 通过newInstance方法创建构造器对应的对象</span></span><br><span class="line">Person  person = (Person) c.newInstance();</span><br></pre></td></tr></table></figure>



<h4 id="5-2-有参构造"><a href="#5-2-有参构造" class="headerlink" title="5.2 有参构造"></a>5.2 有参构造</h4><p>​        带参数的构造器只能通过<code>Constructor</code>方式，由于构造器的参数个数跟类型都不是固定的，所以<code>getConstructor</code>跟<code>getDeclaredConstructor</code>方法的参数列表设计成可变参数类型。</p>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 构造方法是私有的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(String name , <span class="keyword">int</span> age )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name ;</span><br><span class="line">        <span class="keyword">this</span>.age = age ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Reflect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//      获取对应的Class对象</span></span><br><span class="line">        Class clazz = User.class ;</span><br><span class="line"><span class="comment">//      获取想要的构造器,这里的参数列表的类型要跟定义的构造方法一致</span></span><br><span class="line">        Constructor c = clazz.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">//       由于构造方式是私有的，需要设置权限</span></span><br><span class="line">        c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//        通过对应的构造器创建对应的对象，这里的参数列表的值要跟构造方法的类型一致</span></span><br><span class="line">        User user = (User) c.newInstance(<span class="string">&quot;blb&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-操作成员变量"><a href="#6-操作成员变量" class="headerlink" title="6. 操作成员变量"></a>6. 操作成员变量</h2><p>​        我们也可以通过API获取对应的属性，常用API如下：</p>
<ul>
<li><p><code>Field[] getDeclaredFields() </code>： 获取当前类声明的所有属性，包括<code>private</code>的属性。</p>
</li>
<li><p><code>Field[] getFields() </code>： 获取当前类声明的所有的公共（public）属性，包括继承过来的。</p>
</li>
<li><p><code>Field getDeclaredField(String name) </code>： 获取当前类声明的某个属性，包括<code>private</code>的属性 。</p>
</li>
<li><p><code>Field getField(String name) </code>： 获取当前类声明的某个公共（public）属性，包括继承过来的 。</p>
</li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Reflect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//      获取对应的Class对象</span></span><br><span class="line">        Class clazz = Student.class ;</span><br><span class="line"><span class="comment">//      获取对象</span></span><br><span class="line">        Student s = (Student) clazz.newInstance();</span><br><span class="line"><span class="comment">//       获取当前类定义的所有的属性</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"><span class="comment">//        遍历所有的属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field f: fields) &#123;</span><br><span class="line"><span class="comment">//          打印字段名称</span></span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      获取属性名为name的属性</span></span><br><span class="line">        Field nameField = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//      私有的属性需要打开访问权限</span></span><br><span class="line">        nameField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//      给对象s的name属性赋值为blb</span></span><br><span class="line">        nameField.set(s,<span class="string">&quot;blb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips：</p>
<ul>
<li>属性的赋值依赖于某个对象，表示给哪个对象的属性赋值。</li>
<li>操作私有的属性需要设置权限<code>setAccessible</code></li>
</ul>
<h2 id="7-成员方法"><a href="#7-成员方法" class="headerlink" title="7. 成员方法"></a>7. 成员方法</h2><p>我们也可以通过API获取对应的成员方法，常用API如下：</p>
<ul>
<li><p><code>Method[] getDeclaredMethods()  </code>： 获取当前类声明的所有方法，包括<code>private</code>的方法。</p>
</li>
<li><p><code>Method[] getMethods() </code>： 获取当前类声明的所有的公共（public）方法，包括继承过来的。</p>
</li>
<li><p><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) </code>： 获取当前类声明的某个方法，包括<code>private</code>的方法 。</p>
</li>
<li><p><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes) </code>： 获取当前类声明的某个公共（public）方法，包括继承过来的 。</p>
</li>
</ul>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;好好学习，天天向上。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">exam</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;同学，认真考试&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">90</span> ;</span><br><span class="line">        <span class="keyword">return</span> score ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Reflect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//      获取对应的Class对象</span></span><br><span class="line">        Class clazz = Student.class ;</span><br><span class="line"><span class="comment">//      获取对象</span></span><br><span class="line">        Student s = (Student) clazz.newInstance();</span><br><span class="line"><span class="comment">//       获取当前类定义的所有的属性</span></span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历所有的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method m: methods) &#123;</span><br><span class="line"><span class="comment">//          打印方法名称</span></span><br><span class="line">            System.out.println(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      获取方法名为study的方法</span></span><br><span class="line">        Method study = clazz.getDeclaredMethod(<span class="string">&quot;study&quot;</span>);</span><br><span class="line"><span class="comment">//      通过invoke方法调用这个s对象的study方法</span></span><br><span class="line">        study.invoke(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      获取方法名为exam的方法,参数类型要一致</span></span><br><span class="line">        Method exam = clazz.getDeclaredMethod(<span class="string">&quot;exam&quot;</span>,String.class);</span><br><span class="line"><span class="comment">//      私有方法，必须要设置访问权限</span></span><br><span class="line">        exam.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//      通过invoke方法调用这个s对象的exam方法，接收方法调用的结果</span></span><br><span class="line">        Integer result = (Integer) exam.invoke(s,<span class="string">&quot;blb&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;考试分数为： &quot;</span>+result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<ul>
<li>方法的调用依赖于某个对象，表示调用哪个对象方法。</li>
<li>调用私有的方法需要设置权限<code>setAccessible</code></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>错题集1</title>
    <url>/2021/09/13/%E9%94%99%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有如下一段代码，请选择其运行结果（）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE=<span class="string">&quot;taobao&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    String a =<span class="string">&quot;tao&quot;</span>+<span class="string">&quot;bao&quot;</span>;</span><br><span class="line">    String b=<span class="string">&quot;tao&quot;</span>;</span><br><span class="line">    String c=<span class="string">&quot;bao&quot;</span>;</span><br><span class="line">    System.out.println(a==MESSAGE);</span><br><span class="line">    System.out.println((b+c)==MESSAGE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A. true true</span></span><br><span class="line"><span class="comment">* B. false false</span></span><br><span class="line"><span class="comment">* C. true false</span></span><br><span class="line"><span class="comment">* D. false true</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正确答案是 C</span><br><span class="line"></span><br><span class="line">解析:</span><br><span class="line">	String类字符串，一般存在堆内存的常量池里，两个字符串相加，首先会在常量池里查找是否有相同的字符串，有的话，变量a会将地址指向改字符串的地址，如果没有，则会在常量池里面新建一个字符串，然后改变量指向改地址。</span><br><span class="line">	例如：开始常量池为空</span><br><span class="line">	执行 final String MESSAGE=&quot;taobao” ；先会现在常量池里搜索是否有&quot;taobao&quot;,发现没有，则在常量池里创建 &quot;taobao&quot; ，常量		MESSAGE 进栈 并 指向常量&quot;taobao&quot;的地址。</span><br><span class="line">    执行 String a=&quot;tao&quot;+&quot;bao&quot;;相当于 String a=&quot;taobao&quot;； 在常量池里搜索，发现有，则a进栈 ，并指向&quot;taobao&quot;的地址</span><br><span class="line">    执行 String b=&quot;tao&quot;; 先在常量池里搜索是否有&quot;tao&quot;，发现没有,则在常量池里创建 &quot;tao&quot;, b进栈,并指向&quot;tao&quot;的地址</span><br><span class="line">    执行 String c=&quot;bao&quot;; 先在常量池里搜索是否有&quot;bao&quot;，发现没有,则在常量池里创建 &quot;bao&quot;, c进栈,并指向&quot;tao&quot;的地址</span><br><span class="line">    System.out.println(a==MESSAGE); 因为 a 和 MESSAGE 所指的地址相同，所对应的字符串相同，则返回true</span><br><span class="line">    System.out.println((b+c)==MESSAGE);  （b+c) 相当于 String (b+c) =b+c； 相当于在堆内存里先创建了一个对象（b+c）；</span><br><span class="line">    这个对象所指的地址是&quot;taobao&quot;的地址，然后执行这个语句的时候，进栈操作 ，（b+c）指向的地址是对象（b+c）的地址，而MESSAGE执		行的是&quot;taobao&quot;的地址，两个地址不相等，则返回false</span><br></pre></td></tr></table></figure>

<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匿名内部类叙述正确()</span><br><span class="line">A  匿名内部类可以继承一个基类，不可以实现一个接口</span><br><span class="line">B  匿名内部类不可以定义构造器</span><br><span class="line">C  匿名内部类不能用于形参</span><br><span class="line">D  以上说法都不正确</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正确答案是 B</span><br><span class="line"></span><br><span class="line">解析:</span><br><span class="line">	匿名内部类的创建格式为： new 父类构造器（参数列表）|实现接口（）&#123;</span><br><span class="line">                                             //匿名内部类的类体实现</span><br><span class="line">                                        &#125;</span><br><span class="line">    其特点为：</span><br><span class="line">    1.使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</span><br><span class="line">    2.匿名内部类因为没有名字，所以不可以定义构造函数 ，是唯一一个没有构造器的类</span><br><span class="line">    3.匿名内部类中不能存在任何的静态成员变量和静态方法</span><br><span class="line">    4.匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法</span><br></pre></td></tr></table></figure>

<h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6;  </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>;  </span><br><span class="line">b6=b4+b5;  </span><br><span class="line">b3=(b1+b2);  </span><br><span class="line">System.out.println(b3+b6);</span><br><span class="line"><span class="comment">//关于上面代码片段叙述正确的是（）</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*A 输出结果：13</span></span><br><span class="line"><span class="comment">*B 语句：b6=b4+b5编译出错</span></span><br><span class="line"><span class="comment">*C 语句：b3=b1+b2编译出错</span></span><br><span class="line"><span class="comment">*D 运行期抛出异常</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正确答案是 C</span><br><span class="line">解析：</span><br><span class="line">	语句：b6=b4+b5 因为b4,b5被finally修饰，所以在执行运算的时候，类型不会发生强转为int ，还是byte类型，所以输出为10</span><br><span class="line">	语句：b3=(b1+b2);执行b1+b2的时候，会强转为int类型，此时b3为byte类型，所以会发生编译型异常。</span><br><span class="line">	</span><br><span class="line">	编译型异常</span><br><span class="line">	SQLException SQL异常</span><br><span class="line">	IOException IO异常 在对流操作时有可能会出现的异常</span><br><span class="line">	FileNotFoundException 找不到某个文件抛出的异常</span><br><span class="line">	ClassNotFoundException 找不到某个类抛出的异常</span><br><span class="line">	EOFException 输入过程中意外地到达文件尾或流尾，会抛出该异常，常见于对流的操作	</span><br><span class="line">	类型不匹配 int a = &quot;a&quot;; b3=(b1+b2);</span><br><span class="line">	int b1=1, b2;</span><br><span class="line">	b2+=b1; 也会发生编译型异常，b2未初始化</span><br></pre></td></tr></table></figure>

<h1 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面哪个代码片段可能会抛出NullPointerException？</span></span><br><span class="line">String s=<span class="keyword">null</span>;</span><br><span class="line"><span class="function">A <span class="title">if</span><span class="params">((s!=<span class="keyword">null</span>)</span>&amp;<span class="params">(s.length()</span>&gt;0))</span></span><br><span class="line"><span class="function">B <span class="title">if</span><span class="params">((s!=<span class="keyword">null</span>)</span>&amp;&amp;<span class="params">(s.length()</span>&gt;0))</span></span><br><span class="line"><span class="function">C <span class="title">if</span><span class="params">((s==<span class="keyword">null</span>)</span>|<span class="params">(s.length()</span></span>==<span class="number">0</span>))</span><br><span class="line"><span class="function">D <span class="title">if</span><span class="params">((s==<span class="keyword">null</span>)</span>||<span class="params">(s.length()</span></span>==<span class="number">0</span>)) </span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>数据库常用操作1</title>
    <url>/2021/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C1/</url>
    <content><![CDATA[<h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><p>表数据的查询</p>
<h2 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h2><p><strong>查询所有数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名称</span><br></pre></td></tr></table></figure>

<p><strong>查询表当中的指定列</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 列名<span class="number">1</span>，列名<span class="number">2</span>，列名<span class="number">3</span> <span class="keyword">from</span> 表名称</span><br></pre></td></tr></table></figure>

<p><strong>查询去掉重复的列(说明:只有查询完全相同的情况，才能去重)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 列名1,列名2 FROM 表名称;</span><br></pre></td></tr></table></figure>

<p><strong>进行四则运算的查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1+列名2，列名1-数值 FROM 表名称;</span><br></pre></td></tr></table></figure>

<p><strong>非空运算的查询（当列名2里面的数据，包含有NULL的情况下，按0计算）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1, IFNULL(列名2,0) FROM 表名称;</span><br></pre></td></tr></table></figure>

<p><strong>取别名的查询（取别名的过程当中，AS可以省略不写）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1 别名1,列名2 AS 别名2 FROM 表名称;</span><br></pre></td></tr></table></figure>

<p>案例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 查询表的全部记录</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 2. 查询表当中的指定列</span><br><span class="line">SELECT stu_id,stu_name,stu_major FROM student;</span><br><span class="line"></span><br><span class="line">-- 3. 查询去掉重复的列, 查询的结果当中, 如果完全相同,才认定为去重</span><br><span class="line">SELECT DISTINCT stu_major FROM student;</span><br><span class="line"></span><br><span class="line">-- 4. 进行四则运算的查询</span><br><span class="line">-- 将查询的分数统一增加10分</span><br><span class="line">SELECT cs_name,cs_credit+10 FROM course;</span><br><span class="line"></span><br><span class="line">-- 5. 非空运算的查询</span><br><span class="line">UPDATE course SET cs_credit = NULL WHERE cs_name = &#x27;C语言&#x27;;</span><br><span class="line">SELECT cs_name,IFNULL(cs_credit+10,0) FROM course;</span><br><span class="line"></span><br><span class="line">-- 6. 取别名的查询</span><br><span class="line">SELECT cs_name,IFNULL(cs_credit+10,0) AS &#x27;成绩&#x27; FROM course;</span><br><span class="line">SELECT cs_name &#x27;学科&#x27;,IFNULL(cs_credit+10,0) AS &#x27;成绩&#x27; FROM course;</span><br></pre></td></tr></table></figure>

<h2 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2. 条件查询"></a>2. 条件查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名称 WHERE 条件;</span><br></pre></td></tr></table></figure>

<p>条件</p>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">符号</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center"><code>&gt;</code></td>
<td><code>列名&gt;数值</code></td>
</tr>
<tr>
<td align="center">02</td>
<td align="center"><code>&lt;</code></td>
<td><code>列名&lt;数值</code></td>
</tr>
<tr>
<td align="center">03</td>
<td align="center"><code>&gt;=</code></td>
<td><code>列名&gt;=数值</code></td>
</tr>
<tr>
<td align="center">04</td>
<td align="center"><code>&lt;=</code></td>
<td><code>列名&lt;=数值</code></td>
</tr>
<tr>
<td align="center">05</td>
<td align="center"><code>=</code></td>
<td><code>列名=数值</code></td>
</tr>
<tr>
<td align="center">06</td>
<td align="center"><code>!=</code> 或者 <code>&lt;&gt;</code></td>
<td><code>列名!=数值</code> 或者 <code>列名&lt;&gt;数值</code></td>
</tr>
<tr>
<td align="center">07</td>
<td align="center"><code>BETWEEN...AND...</code></td>
<td><code>列名 BETWEEN 数值1 AND 数值2</code></td>
</tr>
<tr>
<td align="center">08</td>
<td align="center"><code>IN(选项1,选项2,选项3)</code></td>
<td><code>列名 IN (数值1,数值2,数值3)</code></td>
</tr>
<tr>
<td align="center">09</td>
<td align="center"><code>LIKE 占位符</code></td>
<td><code>列名 LIKE 占位符</code></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><code>IS NULL</code></td>
<td><code>列名 IS NULL</code></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><code>IS NOT NULL</code></td>
<td><code>列名 IS NOT NULL</code></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><code>AND</code> 或者 <code>&amp;&amp;</code></td>
<td><code>列名&gt;数值1 AND 列名&lt;数值2</code> 或者 <code>列名&gt;数值1 &amp;&amp; 列名&lt;数值2</code></td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><code>OR</code> 或者 `</td>
<td></td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><code>NOT</code> 或者 <code>!</code></td>
<td></td>
</tr>
</tbody></table>
<p><strong>案例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 查询分数在 3分以上的信息</span><br><span class="line">SELECT * FROM course WHERE cs_credit&gt;3;</span><br><span class="line"></span><br><span class="line">-- 2. 查询分数为 1 的信息(这里只能写一个等号)</span><br><span class="line">SELECT * FROM course WHERE cs_credit=1;</span><br><span class="line"></span><br><span class="line">-- 3. 查询分数不为2的信息</span><br><span class="line">SELECT * FROM course WHERE cs_credit&lt;&gt;2;</span><br><span class="line"></span><br><span class="line">-- 4. 查询分数在2到5之间的数据</span><br><span class="line">SELECT * FROM course WHERE cs_credit BETWEEN 2 AND 5;</span><br><span class="line"></span><br><span class="line">-- 5. 查询分数为2和5的数据</span><br><span class="line">SELECT * FROM course WHERE cs_credit IN (2,5);</span><br><span class="line"></span><br><span class="line">-- 6. 查询分数为 NULL的数据</span><br><span class="line">SELECT * FROM course WHERE cs_credit IS NULL;</span><br><span class="line"></span><br><span class="line">-- 7. 查询分数不为 NULL的数据</span><br><span class="line">SELECT * FROM course WHERE cs_credit  IS NOT NULL;  </span><br><span class="line"></span><br><span class="line">-- 8. 查询分数低于2分，高于5的数据</span><br><span class="line">SELECT * FROM course WHERE cs_credit&lt;2 OR cs_credit&gt;5; </span><br></pre></td></tr></table></figure>

<h2 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3. 模糊查询"></a>3. 模糊查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    占位符： % 和 _</span><br><span class="line">    % 表示的是0个或者多个</span><br><span class="line">    _ 表示的是1个字符</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">-- 1. 查询学科名称当中, 包含有&quot;学&quot;字的学科名称</span><br><span class="line">SELECT * FROM course WHERE cs_name LIKE &quot;%学%&quot;</span><br><span class="line"></span><br><span class="line">-- 2. 查询学科名称当中, 以&quot;习&quot;字结尾的</span><br><span class="line">SELECT * FROM course WHERE cs_name LIKE &quot;%习&quot;;</span><br><span class="line"></span><br><span class="line">-- 3. 查询学科名称，由三个字符组成的</span><br><span class="line">SELECT * FROM course WHERE cs_name LIKE &quot;___&quot;;</span><br><span class="line"></span><br><span class="line">-- 4. 查询学科名称，由&quot;数&quot;开头，包含4个字符的</span><br><span class="line">SELECT * FROM course WHERE cs_name LIKE &quot;数___&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="4-分组查询"><a href="#4-分组查询" class="headerlink" title="4. 分组查询"></a>4. 分组查询</h2><p><strong>聚合函数</strong></p>
<ol>
<li><p> 查个数    COUNT(列名)</p>
</li>
<li><p>最大值    MAX(列名)</p>
</li>
<li><p>最小值    MIN(列名)</p>
</li>
<li><p>平均值    AVG(列名)</p>
</li>
<li><p>总和     SUM(列名)</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 分组字段,聚合函数 FROM 表名称 WHERE 分组前条件 GROUP BY 分组字段 HAVING 分组后条件;</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 需求：查看学生来自于哪些学院。可以根据学院进行分组</span><br><span class="line">SELECT stu_college FROM student GROUP BY stu_college;</span><br><span class="line"></span><br><span class="line">-- 注意：在分组之后，查询的结果必须是分组字段，或者聚合函数</span><br><span class="line">-- 如果查询其他的操作是没有意义的。</span><br><span class="line">SELECT * FROM student GROUP BY stu_college;  -- 错误写法</span><br><span class="line"></span><br><span class="line">-- 需求：获取到男生当中的最大年龄和女生当中的最大年龄。</span><br><span class="line">SELECT stu_sex,MAX(stu_age) FROM student GROUP BY stu_sex;</span><br><span class="line"></span><br><span class="line">-- 需求：获取到大数据当中,男生当中的最大年龄和女生当中的最大年龄。</span><br><span class="line">SELECT stu_sex,MAX(stu_age) FROM student WHERE stu_major = &#x27;大数据&#x27; GROUP BY stu_sex;</span><br><span class="line"></span><br><span class="line">-- 需求：分别获取到计科当中,男生和女生的人数，要求每组人数不能超过2个人。</span><br><span class="line">-- WHERE  表示分组之前的条件筛选, 后面不能跟聚合函数</span><br><span class="line">-- HAVING 表示分组之后的条件筛选, 后面可以跟上聚合函数</span><br><span class="line">SELECT stu_sex,COUNT(*) FROM student WHERE stu_major = &#x27;计科&#x27;  GROUP BY stu_sex HAVING COUNT(*)&lt;=2;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>WHERE 和 HAVING 的区别？</p>
<ol>
<li>条件的区别:<br>WHERE 表示的分组前的条件<br>HAVING 表示分组后的条件</li>
<li>聚合函数区别:<br>WHERE 后面不可以跟上聚合函数<br>HAVING 后面可以跟上聚合函数</li>
</ol>
</blockquote>
<h2 id="5-排序查询"><a href="#5-排序查询" class="headerlink" title="5. 排序查询"></a>5. 排序查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 升序: 从小到大，默认排序方式，可以省略 ASC</span><br><span class="line">	ORDER BY 列名 ASC；</span><br><span class="line">	</span><br><span class="line">-- 2. 降序: 从大到小 </span><br><span class="line">ORDER BY 列名 DESC；</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 查询学生表数据，按照年龄升序排列, 默认是升序，ASC可以省略不写</span><br><span class="line">SELECT * FROM student ORDER BY stu_age ASC;</span><br><span class="line"></span><br><span class="line">-- 2. 查询学生表数据，按照年龄降序排列</span><br><span class="line">SELECT * FROM student ORDER BY stu_age DESC;</span><br><span class="line"></span><br><span class="line">-- 3. 多条件排序，如果第一条件相同，则按照第二条件排序。</span><br><span class="line">-- 说明: 按照年龄降序排列，如果年龄相同，则按照学号升序排列</span><br><span class="line">SELECT * FROM student ORDER BY stu_age DESC, stu_id ASC;</span><br></pre></td></tr></table></figure>

<h2 id="6-分页查询"><a href="#6-分页查询" class="headerlink" title="6. 分页查询"></a>6. 分页查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名称 LIMIT 跳过前面几条记录,展示几条记录;</span><br></pre></td></tr></table></figure>

<h2 id="7-格式"><a href="#7-格式" class="headerlink" title="7. 格式"></a>7. 格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	....查询的结果,我们需要什么字段，就在这里写什么.....</span><br><span class="line">FROM</span><br><span class="line">	....数据库当中，数据表的名称....</span><br><span class="line">WHERE</span><br><span class="line">	....查询的条件，分组前的筛选....</span><br><span class="line">GROUP BY</span><br><span class="line">	....表里面的字段名,根据字段分组....</span><br><span class="line">HAVING</span><br><span class="line">	....查询的条件，分组后的筛选....</span><br><span class="line">ORDER BY</span><br><span class="line">	....字段名称和排序规则....</span><br><span class="line">LIMIT</span><br><span class="line">	....分页....</span><br></pre></td></tr></table></figure>

<h2 id="8-多表联查"><a href="#8-多表联查" class="headerlink" title="8. 多表联查"></a>8. 多表联查</h2><p>你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。</p>
<p>JOIN 按照功能大致分为如下三类：</p>
<ul>
<li><strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</li>
<li><strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录。</li>
<li><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li>
</ul>
<hr>
<p><strong>在命令提示符中使用 INNER JOIN</strong></p>
<p>我们在RUNOOB数据库中有两张表 tcount_tbl 和 runoob_tbl。两张数据表数据如下：</p>
<p><strong>实例</strong></p>
<p>尝试以下实例：</p>
<p><strong>测试实例数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SELECT * FROM tcount_tbl;</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| 菜鸟教程  | 10           |</span><br><span class="line">| RUNOOB.COM    | 20           |</span><br><span class="line">| Google        | 22           |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; SELECT * from runoob_tbl;</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| runoob_id | runoob_title  | runoob_author | submission_date |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |</span><br><span class="line">| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |</span><br><span class="line">| 5         | 学习 C      | FK            | 2017-04-05      |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>INNER JOIN</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>WHERE 子句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C1/img_innerjoin.gif"></p>
<hr>
<p><strong>MySQL LEFT JOIN</strong></p>
<p>MySQL left join 与 join 有所不同。  MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</p>
<p><strong>实例</strong></p>
<p>尝试以下实例，以 <strong>runoob_tbl</strong> 为左表，<strong>tcount_tbl</strong> 为右表，理解 MySQL LEFT JOIN 的应用：</p>
<p><strong>LEFT JOIN</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| 5           | FK              | NULL           |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以上实例中使用了 LEFT JOIN，该语句会读取左边的数据表 runoob_tbl 的所有选取的字段数据，即便在右侧表 tcount_tbl中 没有对应的 runoob_author 字段值。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C1/img_leftjoin.gif"></p>
<hr>
<p><strong>MySQL RIGHT JOIN</strong></p>
<p>MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据。</p>
<p><strong>实例</strong></p>
<p>尝试以下实例，以 <strong>runoob_tbl</strong> 为左表，<strong>tcount_tbl</strong> 为右表，理解MySQL RIGHT JOIN的应用：</p>
<p><strong>RIGHT JOIN</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| NULL        | NULL            | 22             |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以上实例中使用了 RIGHT JOIN，该语句会读取右边的数据表 tcount_tbl 的所有选取的字段数据，即便在左侧表 runoob_tbl 中没有对应的runoob_author 字段值。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C1/img_rightjoin.gif"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>jdbc</title>
    <url>/2021/08/20/jdbc/</url>
    <content><![CDATA[<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><ul>
<li><pre><code>JDBC快速入门
</code></pre>
</li>
<li><pre><code>JDBC相关API
</code></pre>
</li>
<li><pre><code>SQL注入问题
</code></pre>
</li>
<li><pre><code>JDBC工具类
</code></pre>
</li>
</ul>
<h2 id="1-JDBC快速入门"><a href="#1-JDBC快速入门" class="headerlink" title="1. JDBC快速入门"></a>1. JDBC快速入门</h2><h4 id="1-1-基础理论"><a href="#1-1-基础理论" class="headerlink" title="1.1  基础理论"></a>1.1  基础理论</h4><h5 id="1-1-1-JDBC介绍"><a href="#1-1-1-JDBC介绍" class="headerlink" title="1.1.1. JDBC介绍"></a>1.1.1. JDBC介绍</h5><p><img src="/2021/08/20/jdbc/image-20210819092506895.png" alt="image-20210819092506895"></p>
<h5 id="1-1-2-JDBC步骤"><a href="#1-1-2-JDBC步骤" class="headerlink" title="1.1.2  JDBC步骤"></a>1.1.2  JDBC步骤</h5><p>操作步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 导入jar包</span><br><span class="line">2. 找到驱动 Driver</span><br><span class="line">3. 获取连接 Connection</span><br><span class="line">4. 获取操作 Statement</span><br><span class="line">5. 查询结果 ResultSet</span><br><span class="line">6. 释放资源</span><br></pre></td></tr></table></figure>









<h4 id="1-2-案例代码"><a href="#1-2-案例代码" class="headerlink" title="1.2 案例代码"></a>1.2 案例代码</h4><h5 id="1-2-1-准备数据"><a href="#1-2-1-准备数据" class="headerlink" title="1.2.1. 准备数据"></a>1.2.1. 准备数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 创建数据库</span><br><span class="line">DROP DATABASE IF EXISTS mydb08;</span><br><span class="line">CREATE DATABASE IF NOT EXISTS mydb08;</span><br><span class="line">USE mydb08;</span><br><span class="line"></span><br><span class="line">-- 2. 创建表</span><br><span class="line">DROP TABLE IF EXISTS student;</span><br><span class="line">CREATE TABLE IF NOT EXISTS student(</span><br><span class="line">	sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	sname VARCHAR(20) NOT NULL,</span><br><span class="line">	sage INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 3. 插入数据</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;定浩&#x27;,18);</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;郭龙&#x27;,19);</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;黄杰&#x27;,17);</span><br><span class="line"></span><br><span class="line">-- 4. 查询结果</span><br><span class="line">SELECT * FROM student;</span><br></pre></td></tr></table></figure>





<h5 id="1-2-1-代码实现"><a href="#1-2-1-代码实现" class="headerlink" title="1.2.1. 代码实现"></a>1.2.1. 代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDBC的快速入门</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动的顺序： C-&gt;S-&gt;R</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/mydb08&quot;</span>;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="comment">//----------------------</span></span><br><span class="line">        <span class="comment">//找到驱动的对象</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//通过驱动管理者，获取到连接 Connection</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//通过连接 conn 获取到操作的对象 Statement</span></span><br><span class="line">        Statement stat = conn.createStatement();</span><br><span class="line">        <span class="comment">//执行SQL语句，查询数据库</span></span><br><span class="line">        ResultSet resu = stat.executeQuery(sql);</span><br><span class="line">        <span class="comment">//循环遍历结果集，获取到结果集当中的数据</span></span><br><span class="line">        <span class="keyword">while</span> (resu.next()) &#123;   <span class="comment">//判断是否还存在下一行的数据，如果存在，则进入循环</span></span><br><span class="line">            <span class="comment">//获取到指定的数据, 通过列名获取到指定的数据值</span></span><br><span class="line">            <span class="keyword">int</span> id = resu.getInt(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">            String name = resu.getString(<span class="string">&quot;sname&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> age = resu.getInt(<span class="string">&quot;sage&quot;</span>);</span><br><span class="line">            System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源，关闭的顺序是相反的。R-&gt;S-&gt;C</span></span><br><span class="line">        resu.close();</span><br><span class="line">        stat.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="2-JDBC相关API"><a href="#2-JDBC相关API" class="headerlink" title="2. JDBC相关API"></a>2. JDBC相关API</h2><h4 id="2-1-DriverManager类"><a href="#2-1-DriverManager类" class="headerlink" title="2.1 DriverManager类"></a>2.1 DriverManager类</h4><p>底层代码 <code>DriverManager.getConnection(url,username,password)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,String user, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	<span class="comment">//1. 创建了 Properties的对象 info</span></span><br><span class="line">    java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line">	<span class="comment">//2. 判断用户名是否为空, 如果不为空，则存放到properties当中</span></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//3. 判断密码是否为空, 如果不为空，则存放到properties当中</span></span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//4. 调用自己的方法 getConnection(三个参数方法)</span></span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发现问题：</p>
<p>底层会将 username 和 password 进行 Properties 的封装</p>
</blockquote>
<p>底层实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法，私有化修饰了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DriverManager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//静态代码块，只要类加载的时候，都会加载静态代码块，加载静态代码块的之后，才会调用 getConnection()方法</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用下面的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        drivers = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="comment">//这里，什么时候驱动为null呢？就是上面出现异常之后为空。</span></span><br><span class="line">    println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">	<span class="comment">//底层在遍历驱动</span></span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">			<span class="comment">//核心代码：底层会加载所有的驱动，通过ClassLoader去加载驱动</span></span><br><span class="line">            Class.forName(aDriver, <span class="keyword">true</span>,ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：</p>
<p><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></p>
<p>可以省略不写的，在高版本的JDBC当中，找驱动的底层会自动完成。 </p>
<p>底层代码当中，会有扫描驱动的操作。（底层在遍历驱动）</p>
<p><code>Class.forName(aDriver, true,ClassLoader.getSystemClassLoader());</code></p>
</blockquote>
<h4 id="2-2-Connection-接口"><a href="#2-2-Connection-接口" class="headerlink" title="2.2 Connection 接口"></a>2.2 Connection 接口</h4><h5 id="2-2-1-核心方法"><a href="#2-2-1-核心方法" class="headerlink" title="2.2.1 核心方法"></a>2.2.1 核心方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">Statement <span class="title">createStatement</span><span class="params">()</span>   <span class="comment">//获取到操作数据的对象 Statement 接口对象</span></span></span><br><span class="line"><span class="function">2. PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span>   <span class="comment">//预置操作数据的对象 PreparedStatement 接口对象</span></span></span><br><span class="line"><span class="function">-------------------</span></span><br><span class="line"><span class="function">3. <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span>  <span class="comment">//是否开启自动提交事务，如果传递值是 false 表示手动开启事务，默认true</span></span></span><br><span class="line"><span class="function">4. <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span>   <span class="comment">//提交事务的操作，多组SQL语句执行，没有问题的情况下，则提交</span></span></span><br><span class="line"><span class="function">5. <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span>  <span class="comment">//回滚事务的操作，当SQL语句执行过程当中，出现异常的时候，则回滚</span></span></span><br></pre></td></tr></table></figure>



<h5 id="2-2-2-事务处理"><a href="#2-2-2-事务处理" class="headerlink" title="2.2.2 事务处理"></a>2.2.2 事务处理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标：学习JDBC当中的事务处理方式</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/mydb08&quot;</span>;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT INTO student VALUES (3,&#x27;佳佳&#x27;,18)&quot;</span>;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stat = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//----------------------</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过驱动管理者，获取到连接 Connection</span></span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">            <span class="comment">//****[1]开启事务手动提交****</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//************************</span></span><br><span class="line">            <span class="comment">//获取到操作数据的对象</span></span><br><span class="line">            stat = conn.createStatement();</span><br><span class="line">            <span class="comment">//执行SQL语句</span></span><br><span class="line">            <span class="comment">//执行增删改 采用的方法是 executeUpdate 返回的结果是影响的行数</span></span><br><span class="line">            <span class="keyword">int</span> count = stat.executeUpdate(sql);</span><br><span class="line">            <span class="comment">//****[2]执行成功，则提交事务****</span></span><br><span class="line">            conn.commit();</span><br><span class="line">            <span class="comment">//************************</span></span><br><span class="line">            System.out.println(count &gt; <span class="number">0</span> ? <span class="string">&quot;执行成功&quot;</span> : <span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//****[3]如果出现了异常，需要事务的回滚****</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback();</span><br><span class="line">                System.out.println(<span class="string">&quot;事务回滚执行了...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//************************</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//进行资源的释放</span></span><br><span class="line">            <span class="keyword">if</span> (stat!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stat.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;资源释放stat...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;资源释放conn...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="2-3-Statement-接口"><a href="#2-3-Statement-接口" class="headerlink" title="2.3 Statement 接口"></a>2.3 Statement 接口</h4><h5 id="2-3-1、核心方法"><a href="#2-3-1、核心方法" class="headerlink" title="2.3.1、核心方法"></a>2.3.1、核心方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">void</span> <span class="title">addBatch</span><span class="params">(String sql)</span>   <span class="comment">//可以用于批量执行SQL语句</span></span></span><br><span class="line"><span class="function">2. <span class="keyword">int</span>[] <span class="title">executeBatch</span><span class="params">()</span>        <span class="comment">//与上面的方法搭配使用</span></span></span><br><span class="line"><span class="function">3. <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span>   <span class="comment">//执行更新操作。增、删、改 的SQL语句，需要使用此方法，返回的是影响行数</span></span></span><br><span class="line"><span class="function">4. ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span>   <span class="comment">//执行查询的方法。返回的是结果集 ResultSet</span></span></span><br></pre></td></tr></table></figure>



<h5 id="2-3-2、方法演示"><a href="#2-3-2、方法演示" class="headerlink" title="2.3.2、方法演示"></a>2.3.2、方法演示</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标：学习Statement的常用方法</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/mydb08&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement stat = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resu = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过驱动管理者，获取到连接 Connection</span></span><br><span class="line">        conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//通过conn去获取到操作数据库的对象 stat</span></span><br><span class="line">        stat = conn.createStatement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String sql1 = <span class="string">&quot;INSERT INTO student VALUES (NULL,&#x27;佳佳1&#x27;,18)&quot;</span>;</span><br><span class="line">        String sql2 = <span class="string">&quot;INSERT INTO student VALUES (NULL,&#x27;佳佳2&#x27;,18)&quot;</span>;</span><br><span class="line">        <span class="comment">//将SQL语句批量的添加进去</span></span><br><span class="line">        stat.addBatch(sql1);</span><br><span class="line">        stat.addBatch(sql2);</span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        <span class="keyword">int</span>[] array = stat.executeBatch();</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecuteUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT INTO student VALUES (NULL,&#x27;佳佳&#x27;,18)&quot;</span>;</span><br><span class="line">        <span class="comment">//executeUpdate 执行的是增删改</span></span><br><span class="line">        <span class="keyword">int</span> count = stat.executeUpdate(sql);</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecuteQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="comment">//执行的是查询</span></span><br><span class="line">        resu = stat.executeQuery(sql);</span><br><span class="line">        <span class="comment">//循环查找</span></span><br><span class="line">        <span class="keyword">while</span> (resu.next()) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = resu.getInt(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">            String name = resu.getString(<span class="string">&quot;sname&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> age = resu.getInt(<span class="string">&quot;sage&quot;</span>);</span><br><span class="line">            System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//释放资源，关闭的顺序是相反的。R-&gt;S-&gt;C</span></span><br><span class="line">        <span class="keyword">if</span> (resu != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resu.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stat.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="2-4-ResultSet接口"><a href="#2-4-ResultSet接口" class="headerlink" title="2.4 ResultSet接口"></a>2.4 ResultSet接口</h4><h5 id="2-4-1、核心方法"><a href="#2-4-1、核心方法" class="headerlink" title="2.4.1、核心方法"></a>2.4.1、核心方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span>   <span class="comment">//判断是否还存在下一行的数据，可以作用在while循环判断和if判断语句当中</span></span></span><br><span class="line"><span class="function">2. <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> columnIndex)</span>   <span class="comment">//获取到int类型的数据，参数是查询结果集的第几个索引</span></span></span><br><span class="line"><span class="function">3. <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String columnLabel)</span>  <span class="comment">//获取到int类型的数据，参数是需要查询的列的名称</span></span></span><br><span class="line"><span class="function">4. String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> columnIndex)</span>  <span class="comment">//获取到String类型的数据，参数是查询结果集的第几个索引</span></span></span><br><span class="line"><span class="function">5. String <span class="title">getString</span><span class="params">(String columnLabel)</span>  <span class="comment">//获取到String类型的数据，参数是需要查询的列的名称</span></span></span><br></pre></td></tr></table></figure>



<h5 id="2-4-2、方法演示"><a href="#2-4-2、方法演示" class="headerlink" title="2.4.2、方法演示"></a>2.4.2、方法演示</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标：学习ResultSet的常用方法</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/mydb08&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement stat = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resu = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过驱动管理者，获取到连接 Connection</span></span><br><span class="line">        conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//通过conn去获取到操作数据库的对象 stat</span></span><br><span class="line">        stat = conn.createStatement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNext</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        ResultSet resu = stat.executeQuery(sql);</span><br><span class="line">        <span class="keyword">boolean</span> flag1 = resu.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;flag1 = &quot;</span> + flag1);</span><br><span class="line">        <span class="keyword">boolean</span> flag2 = resu.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;flag2 = &quot;</span> + flag2);</span><br><span class="line">        <span class="keyword">boolean</span> flag3 = resu.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;flag3 = &quot;</span> + flag3);</span><br><span class="line">        <span class="keyword">boolean</span> flag4 = resu.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;flag4 = &quot;</span> + flag4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetInt</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT sname,sid FROM student&quot;</span>;</span><br><span class="line">        ResultSet resu = stat.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (resu.next()) &#123;</span><br><span class="line">            <span class="keyword">int</span> id1 = resu.getInt(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">            <span class="comment">//System.out.println(id1);</span></span><br><span class="line">            <span class="keyword">int</span> id2 = resu.getInt(<span class="number">2</span>);</span><br><span class="line">            System.out.println(id1+<span class="string">&quot;,&quot;</span>+id2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetString</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT sid,sname FROM student&quot;</span>;</span><br><span class="line">        ResultSet resu = stat.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (resu.next()) &#123;</span><br><span class="line">            String name1 = resu.getString(<span class="string">&quot;sname&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;name1 = &quot;</span> + name1);</span><br><span class="line">            String name2 = resu.getString(<span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;name2 = &quot;</span> + name2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//释放资源，关闭的顺序是相反的。R-&gt;S-&gt;C</span></span><br><span class="line">        <span class="keyword">if</span> (resu != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resu.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stat.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="3-SQL注入问题"><a href="#3-SQL注入问题" class="headerlink" title="3. SQL注入问题"></a>3. SQL注入问题</h2><h4 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h4><h5 id="3-1-1、数据库准备"><a href="#3-1-1、数据库准备" class="headerlink" title="3.1.1、数据库准备"></a>3.1.1、数据库准备</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 创建新表</span><br><span class="line">DROP TABLE IF EXISTS t_user;</span><br><span class="line">CREATE TABLE IF NOT EXISTS t_user(</span><br><span class="line">	uid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	uname VARCHAR(20),</span><br><span class="line">	upass VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 2. 插入数据</span><br><span class="line">INSERT INTO t_user VALUES (NULL,&#x27;zhangsan&#x27;,&#x27;333&#x27;);</span><br><span class="line">INSERT INTO t_user VALUES (NULL,&#x27;lisi&#x27;,&#x27;444&#x27;);</span><br><span class="line"></span><br><span class="line">-- 3. 查询数据</span><br><span class="line">SELECT * FROM t_user;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  需求：做一个登录的效果，如果输入用户名和密码，只有都是正确的才能登录成功</span><br><span class="line">*/</span><br><span class="line">SELECT * FROM t_user WHERE uname = &#x27;zhangsan&#x27; AND upass = &#x27;333&#x27;;</span><br><span class="line">SELECT * FROM t_user WHERE uname = &#x27;zhangsan&#x27; OR  &#x27;1=1&#x27; AND upass = &#x27;随便写都可以的&#x27;;</span><br></pre></td></tr></table></figure>



<h5 id="3-1-2、演示问题"><a href="#3-1-2、演示问题" class="headerlink" title="3.1.2、演示问题"></a>3.1.2、演示问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标: 演示SQL注入的问题</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名:   zhangsan&#x27;  OR  &#x27;1=1  &quot;</span>);</span><br><span class="line">        String nameStr = sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">        String passStr = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/mydb08&quot;</span>;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM t_user WHERE uname = &#x27;&quot;</span> + nameStr + <span class="string">&quot;&#x27; AND upass = &quot;</span> + passStr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过驱动管理者，获取到连接 Connection</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//通过连接 conn 获取到操作的对象 Statement</span></span><br><span class="line">        Statement stat = conn.createStatement();</span><br><span class="line">        <span class="comment">//执行SQL语句，查询数据库</span></span><br><span class="line">        ResultSet resu = stat.executeQuery(sql);</span><br><span class="line">        <span class="comment">//判断是否存在数据呢？</span></span><br><span class="line">        String message = <span class="string">&quot;Sorry 登录失败,请检查账号和密码&quot;</span>;</span><br><span class="line">        <span class="comment">//只要存在下一条的记录，则表示登录成功</span></span><br><span class="line">        <span class="keyword">if</span> (resu.next()) &#123;</span><br><span class="line">            message = <span class="string">&quot;登录成功:&quot;</span> + nameStr;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;message = &quot;</span> + message);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        resu.close();</span><br><span class="line">        stat.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3-2-解决问题"><a href="#3-2-解决问题" class="headerlink" title="3.2 解决问题"></a>3.2 解决问题</h4><h5 id="3-2-1、需要使用API"><a href="#3-2-1、需要使用API" class="headerlink" title="3.2.1、需要使用API"></a>3.2.1、需要使用API</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 当我们获取到conn的对象之后，需要获取到预置语句的对象PreparedStatement </span></span><br><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">//2. 提前定义好SQL语句，采用占位符，占据位置。最后去设置占位符的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">int</span> parameterIndex, <span class="keyword">int</span> x)</span>    <span class="comment">//参数1: 第几个问号， 参数2: 需要插入的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setString</span><span class="params">(<span class="keyword">int</span> parameterIndex, String x)</span>  <span class="comment">//参数1: 第几个问号，参数2: 需要插入的值</span></span></span><br><span class="line"><span class="function"><span class="comment">//3. 执行SQL的操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span>   <span class="comment">//执行 增、删、改操作</span></span></span><br><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">()</span>   <span class="comment">//执行 查询操作</span></span></span><br></pre></td></tr></table></figure>



<h5 id="3-2-2、解决问题"><a href="#3-2-2、解决问题" class="headerlink" title="3.2.2、解决问题"></a>3.2.2、解决问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标: 解决SQL注入的问题</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名:   zhangsan&#x27;  OR  &#x27;1=1&quot;</span>);</span><br><span class="line">        String nameStr = sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">        String passStr = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/mydb08&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预置的SQL语句，里面的变量由问号(英文) 去代替</span></span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM t_user WHERE uname = ? AND upass = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过驱动管理者，获取到连接 Connection</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//*********************</span></span><br><span class="line">        <span class="comment">//通过连接 conn 获取到操作的对象 PreparedStatement</span></span><br><span class="line">        PreparedStatement stat = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置参数值</span></span><br><span class="line">        stat.setString(<span class="number">1</span>,nameStr);</span><br><span class="line">        stat.setString(<span class="number">2</span>,passStr);</span><br><span class="line">        <span class="comment">//执行SQL语句，查询数据库</span></span><br><span class="line">        ResultSet resu = stat.executeQuery();</span><br><span class="line">        <span class="comment">//*********************</span></span><br><span class="line">        <span class="comment">//判断是否存在数据呢？</span></span><br><span class="line">        String message = <span class="string">&quot;Sorry 登录失败,请检查账号和密码&quot;</span>;</span><br><span class="line">        <span class="comment">//只要存在下一条的记录，则表示登录成功</span></span><br><span class="line">        <span class="keyword">if</span> (resu.next()) &#123;</span><br><span class="line">            message = <span class="string">&quot;登录成功:&quot;</span> + nameStr;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;message = &quot;</span> + message);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        resu.close();</span><br><span class="line">        stat.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="4-JDBC工具类"><a href="#4-JDBC工具类" class="headerlink" title="4. JDBC工具类"></a>4. JDBC工具类</h2><h4 id="4-1-配置文件"><a href="#4-1-配置文件" class="headerlink" title="4.1 配置文件"></a>4.1 配置文件</h4><p>位置： <code>src/jdbc.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mydb08username=rootpassword=root</span></span><br></pre></td></tr></table></figure>



<h4 id="4-2-工具类"><a href="#4-2-工具类" class="headerlink" title="4.2 工具类"></a>4.2 工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义JDBC的工具类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PreparedStatement stat = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResultSet resu = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态代码块，只加载一次。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在反射章节讲过的类加载器，专门加载src下面的文件 properties，加载成为流对象</span></span><br><span class="line">            InputStream is = ClassLoader.getSystemResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">            Properties pp = <span class="keyword">new</span> Properties();</span><br><span class="line">            pp.load(is);</span><br><span class="line">            is.close();</span><br><span class="line">            url = pp.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            username = pp.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            password = pp.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的方法，用于获取数据库的连接对象 Connection</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的方法，用于操作 增删改数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exeUpdate</span><span class="params">(String sql, Map&lt;Integer, Object&gt; map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//INSERT INTO  表名称 VALUES (NULL,?,?,?);</span></span><br><span class="line">        <span class="comment">//map.put(1,1001);</span></span><br><span class="line">        <span class="comment">//map.put(2,&quot;张三&quot;);</span></span><br><span class="line">        <span class="comment">//map.put(3,23);</span></span><br><span class="line">        <span class="keyword">int</span> lineNumber = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PreparedStatement stat = getConnection().prepareStatement(sql);</span><br><span class="line">            <span class="comment">//询问map集合到底有多少个数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; map != <span class="keyword">null</span> &amp;&amp; i &lt; map.size(); i++) &#123;</span><br><span class="line">                <span class="comment">//得到索引值</span></span><br><span class="line">                <span class="keyword">int</span> index = i + <span class="number">1</span>;</span><br><span class="line">                stat.setObject(index, map.get(index));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行SQL语句</span></span><br><span class="line">            lineNumber = stat.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lineNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的方法，用于操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title">exeQuery</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用下面的重载方法</span></span><br><span class="line">        <span class="keyword">return</span> exeQuery(sql,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的方法，用于操作 查询数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title">exeQuery</span><span class="params">(String sql, Map&lt;Integer, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//SELECT * FROM 表名 WHERE 列名1=?  AND 列名2 = ?;</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PreparedStatement stat =  getConnection().prepareStatement(sql);</span><br><span class="line">            <span class="comment">//询问map集合到底有多少个数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; map != <span class="keyword">null</span> &amp;&amp; i &lt; map.size(); i++) &#123;</span><br><span class="line">                <span class="comment">//得到索引值</span></span><br><span class="line">                <span class="keyword">int</span> index = i + <span class="number">1</span>;</span><br><span class="line">                stat.setObject(index, map.get(index));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//具体的查询操作</span></span><br><span class="line">            resu = stat.executeQuery();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (resu != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resu.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stat.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-3-测试类"><a href="#4-3-测试类" class="headerlink" title="4.3 测试类"></a>4.3 测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//测试添加数据的操作</span></span><br><span class="line">        String sql1 = <span class="string">&quot;INSERT INTO t_user VALUES (NULL,&#x27;zhaoliu&#x27;,666)&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lineNumber = JDBCUtils.exeUpdate(sql1, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;lineNumber = &quot;</span> + lineNumber);</span><br><span class="line">        System.out.println(lineNumber &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        <span class="comment">//2.释放资源</span></span><br><span class="line">        JDBCUtils.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">		<span class="comment">//测试查询所有的操作</span></span><br><span class="line">        String sql2 = <span class="string">&quot;SELECT * FROM t_user&quot;</span>;</span><br><span class="line">        ResultSet resu1 = JDBCUtils.exeQuery(sql2);</span><br><span class="line">        <span class="keyword">while</span> (resu1.next())&#123;</span><br><span class="line">            <span class="keyword">int</span> uid = resu1.getInt(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">            String uname = resu1.getString(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">            String upass = resu1.getString(<span class="string">&quot;upass&quot;</span>);</span><br><span class="line">            System.out.println(uid+<span class="string">&quot;,&quot;</span>+uname+<span class="string">&quot;,&quot;</span>+upass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.释放资源</span></span><br><span class="line">        JDBCUtils.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="4-4-打jar包"><a href="#4-4-打jar包" class="headerlink" title="4.4 打jar包"></a>4.4 打jar包</h4><p>操作步骤1</p>
<p><img src="/jdbc/image-20210819171543915.png" alt="image-20210819171543915"></p>
<p>操作步骤2</p>
<p><img src="/jdbc/image-20210819171732866.png" alt="image-20210819171732866"></p>
<p>操作步骤3</p>
<p><img src="/jdbc/image-20210819171936158.png" alt="image-20210819171936158"></p>
<p>操作步骤4</p>
<p><img src="/jdbc/image-20210819172021946.png" alt="image-20210819172021946"></p>
]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
  </entry>
  <entry>
    <title>数据库常用命令</title>
    <url>/2021/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-数据库连接"><a href="#1-数据库连接" class="headerlink" title="1.数据库连接"></a>1.数据库连接</h1><h2 id="1-1-启动服务与终止服务"><a href="#1-1-启动服务与终止服务" class="headerlink" title="1.1 启动服务与终止服务"></a>1.1 启动服务与终止服务</h2><p><strong>启动服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net  start  mysql</span><br></pre></td></tr></table></figure>

<p><strong>终止服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>

<h2 id="1-2-连接服务器"><a href="#1-2-连接服务器" class="headerlink" title="1.2 连接服务器"></a>1.2 连接服务器</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>默认</th>
</tr>
</thead>
<tbody><tr>
<td>-u</td>
<td>帐号</td>
<td>当前系统同名帐号</td>
</tr>
<tr>
<td>-p</td>
<td>密码</td>
<td></td>
</tr>
<tr>
<td>-P</td>
<td>连接端口</td>
<td>3306</td>
</tr>
<tr>
<td>-h</td>
<td>主机地址</td>
<td>127.0.0.1</td>
</tr>
<tr>
<td>-e</td>
<td>执行sql指令</td>
<td></td>
</tr>
</tbody></table>
<p><strong>连接服务器</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p -P3306 -h 127.0.0.1</span><br></pre></td></tr></table></figure>

<p><strong>连接本地数据库 可以使用默认值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p </span><br></pre></td></tr></table></figure>

<p><strong>使用<code>-e</code> 执行SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot -e&quot;show databases;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>退出连接</strong></p>
<p>命令行下执行exit可通出当前连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>三种注释方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1.单行注释 ，--之后必须有空格</span><br><span class="line">#2.单行注释</span><br><span class="line">/*多行注释*/</span><br></pre></td></tr></table></figure>

<h1 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2.DDL"></a>2.DDL</h1><p>DDL 数据库定义语言，针对于数据库，数据表的增删改查的使用</p>
<h2 id="2-1-操作数据库"><a href="#2-1-操作数据库" class="headerlink" title="2.1 操作数据库"></a>2.1 操作数据库</h2><h3 id="2-1-1-创建数据库"><a href="#2-1-1-创建数据库" class="headerlink" title="2.1.1 创建数据库"></a>2.1.1 创建数据库</h3><p><strong>创建数据库 [可写可不写]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create databases [if not exists]  数据库名称</span><br></pre></td></tr></table></figure>

<p>如果不存在mydb02数据库，则创建一个数据库，数据库名称为mydb02</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create databases if not exists mydb02; </span><br></pre></td></tr></table></figure>

<p><strong>指定字符集</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database if not exists 数据库名 character set 字符集</span><br></pre></td></tr></table></figure>

<p>如果不存在mydb02数据库，则创建一个数据库，数据库名称为mydb02，并设置utf8格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database if not exists mydb03 character set utf8;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-删除数据库"><a href="#2-1-2-删除数据库" class="headerlink" title="2.1.2 删除数据库"></a>2.1.2 删除数据库</h3><p><strong>删除数据库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop [if exists] database 数据库名称</span><br></pre></td></tr></table></figure>

<p>删除数据库 mydb03 如果不存在，则删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS mydb03;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-修改数据库"><a href="#2-1-3-修改数据库" class="headerlink" title="2.1.3 修改数据库"></a>2.1.3 修改数据库</h3><p><strong>修改数据库的字符集</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure>

<p>案例代码: 修改数据库 mydb03 的字符集为gbk格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE mydb03 CHARACTER SET gbk;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-查询数据库"><a href="#2-1-4-查询数据库" class="headerlink" title="2.1.4 查询数据库"></a>2.1.4 查询数据库</h3><p><strong>查询数据库的字符集</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create database 数据库名称</span><br></pre></td></tr></table></figure>

<p>查看数据库 mydb03 的创建语句，查看的过程当中，可以看到字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE DATABASE mydb03;</span><br></pre></td></tr></table></figure>

<p>查看当前正在使用的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-使用数据库"><a href="#2-1-5-使用数据库" class="headerlink" title="2.1.5 使用数据库"></a>2.1.5 使用数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 数据库名称;</span><br></pre></td></tr></table></figure>

<p>使用数据库mydb03</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mydb03</span><br></pre></td></tr></table></figure>

<h2 id="2-2-操作数据表"><a href="#2-2-操作数据表" class="headerlink" title="2.2 操作数据表"></a>2.2 操作数据表</h2><h3 id="2-2-1-创建数据表"><a href="#2-2-1-创建数据表" class="headerlink" title="2.2.1 创建数据表"></a>2.2.1 创建数据表</h3><p><strong>语法格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS  表名称(</span><br><span class="line">    列名1  数据类型1  约束类型,</span><br><span class="line">    列名2  数据类型2  约束类型,</span><br><span class="line">    列名3  数据类型3  约束类型</span><br><span class="line">) ENGINE=存储引擎;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS  student_two(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(20) NOT NULL,</span><br><span class="line">	age INT NOT NULL</span><br><span class="line">) ENGINE=INNODB;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-删除数据表"><a href="#2-2-2-删除数据表" class="headerlink" title="2.2.2 删除数据表"></a><strong>2.2.2 删除数据表</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名称;</span><br></pre></td></tr></table></figure>

<p>如果存在表student_two，则删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS student_two;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-修改数据表"><a href="#2-2-3-修改数据表" class="headerlink" title="2.2.3 修改数据表"></a>2.2.3 修改数据表</h3><p><strong>修改表的字符集</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 CHARACTER SET 字符集;</span><br></pre></td></tr></table></figure>

<p>修改表 student_1 的字符集 gbk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student_1 CHARACTER SET gbk;</span><br></pre></td></tr></table></figure>

<p><strong>添加新的一列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 ADD 列名称 列的数据类型;</span><br></pre></td></tr></table></figure>

<p> 修改表，添加新的一列，添加性别 gender</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student_1 ADD gender VARCHAR(20);</span><br></pre></td></tr></table></figure>

<p><strong>修改表，修改列的数据类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 MODIFY 列名称 列的数据类型;</span><br></pre></td></tr></table></figure>

<p>修改表，修改表所在列的数据类型，性别gender 修改为INT</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student_1 MODIFY gender INT;</span><br></pre></td></tr></table></figure>

<p><strong>修改表，修改列名称和数据类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 CHANGE 旧的列名称 新的列名称 新的列数据类型;</span><br></pre></td></tr></table></figure>

<p>修改表，将旧的列性别 gender 修改成为 sex VARCHAR(20)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student_1 CHANGE gender sex VARCHAR(20);</span><br></pre></td></tr></table></figure>

<p><strong>修改表，删除表当中某一列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 DROP 列名称;</span><br></pre></td></tr></table></figure>

<p> 修改表，删除表当中的某一列，删除表 student_1 的 sex这列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student_1 DROP sex;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-查询数据表"><a href="#2-2-3-查询数据表" class="headerlink" title="2.2.3 查询数据表"></a>2.2.3 查询数据表</h3><p><strong>查看数据库当中，所有表的信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<p><strong>查询数据库当中，单独的某个表的表结构，每一列的列名、约束、数据类型、信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC 表名称;</span><br></pre></td></tr></table></figure>

<p><strong>查询数据库当中，表的存储引擎，数据容量，创建时间等</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM mydb03 LIKE &#x27;student_1&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3数据类型"><a href="#2-3数据类型" class="headerlink" title="2.3数据类型"></a>2.3数据类型</h2><p><a href="https://www.jb51.net/article/144449.html">请看</a></p>
<h3 id="2-3-1-类型"><a href="#2-3-1-类型" class="headerlink" title="2.3.1 类型"></a><strong>2.3.1 类型</strong></h3><ul>
<li><p>数值数据类型</p>
<ul>
<li><p>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT</p>
</li>
<li><p>浮点数类型：FLOAT、DOUBLE</p>
</li>
<li><p>定点小数：DECIMAL</p>
</li>
</ul>
</li>
<li><p>日期/时间类型</p>
</li>
</ul>
<p>　　YEAR、TIME、DATE、DATETIME、TIMESTAMP</p>
<ul>
<li>字符串类型</li>
</ul>
<p>　　CHAR、VARCHAR、TEXT、ENUM、SET等 　　</p>
<ul>
<li>二进制类型</li>
</ul>
<p>　　BIT、BINARY、VARBINARY、BLOB</p>
<h3 id="2-3-2-整数类型"><a href="#2-3-2-整数类型" class="headerlink" title="2.3.2 整数类型"></a>2.3.2 整数类型</h3><p><img src="/2021/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2018072515590119.png" alt="img"></p>
<p>不同整数类型的取值范围</p>
<p><img src="/2021/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2018072515590120.png" alt="img"></p>
<p>int(n)  括号中的数字表示的是该数据类型指定的显示宽度，指定能够显示的数值中数字的个数。</p>
<p>这里要注意：显示宽度和数据类型的取值范围是无关的，显示宽度只是指明MySQL最大可能显示的数字个数，</p>
<p>如果不写显示宽度，就会用系统默认的，比如，INT    的默认显示宽度是11，看上面表，最高也就能表示10位大小的数值，但是要注意，有符号的，也就是负数时，符号位也占一位。</p>
<h3 id="2-3-3-浮点数类型和定点数类型"><a href="#2-3-3-浮点数类型和定点数类型" class="headerlink" title="2.3.3 浮点数类型和定点数类型"></a><strong>2.3.3 浮点数类型和定点数类型</strong></h3><p>　<img src="/2021/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2018072515590121.png" alt="img">　</p>
<h4 id="2-3-3-1解释M-D的意思："><a href="#2-3-3-1解释M-D的意思：" class="headerlink" title="2.3.3.1解释M,D的意思："></a>2.3.3.1<strong>解释M,D的意思：</strong></h4><ul>
<li>M:<strong>数值的总位数。</strong> 通俗点讲，就是看有多少个数字，比如，5.6789，M就是5</li>
<li> D:小数点后面能保留几位。 比如上面的5.6789 ，D就是4。 这只是举一个例</li>
</ul>
<p>不单单就MECIMAL有M,D这两个参数，FLOAT 和 DOUBLE 都有</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tmp(</span><br><span class="line"> 　x FLOAT(3,1),</span><br><span class="line"> 　y DOUBLE(5,3),</span><br><span class="line"> 　z DECIMAL(5,4)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>假设x插入的值为：5.69，56.78，5.438，349.2 (注意：实验给x这个字段插入的值，可能实验了三次，不要错看成x的值为5.69，y为56.78等等了)<br> 实际上在数据库中存的值为：5.7，56.9，5.3，349.2这个报错<br> 分析：x的M为3，D为1，那么小数点上必须是占了一位数字，就算没有值，也会用0来填充，所以说，整数位上最多就只能是2位，这里要切记要先根据D的值，来算整数位能最多有多少位。</p>
<p>通过分析x，y和z也就简单了，</p>
<p>y字段上的值，整数部分最多是2位，小数点后的位数最多是3位，也就是说小数点后超过了3位，就会四舍五入。<br> z字段上的值，整数部分最多只能是一位，小数点后的位数最多是4位，如果不足4位，也会用0补充。比如插入1.56，在数据库中存的就是1.5600， 比如插入25.46，这个就会报错，因为整数部分只能是一位，小数点后的位数已经占了4位了。这里要搞清楚。</p>
<h4 id="2-3-3-2-FLOAT、DOUBLE、DECIMAL三者的区别。"><a href="#2-3-3-2-FLOAT、DOUBLE、DECIMAL三者的区别。" class="headerlink" title="2.3.3.2 FLOAT、DOUBLE、DECIMAL三者的区别。"></a><strong>2.3.3.2 FLOAT、DOUBLE、DECIMAL三者的区别</strong>。</h4><p>都是用来表示我们所说的小数的也就是浮点数，但是三种的精度不一样，也就是后面显示的位数不一样，</p>
<ul>
<li><p>区别一：</p>
<ul>
<li><p>FLOAT显示后面的小数点位大概在40多位，</p>
</li>
<li><p>DOUBLE能显示的就是300多位了，不是一个层次上的，</p>
</li>
<li><p>DECIMAL这个小数点后面能显示的位数跟DOUBLE差不多，</p>
</li>
</ul>
</li>
<li><p>区别二：</p>
</li>
</ul>
<p>　　　FLOAT和DOUBLE在不指定精度时，也就是不用(M,D)，默认会按照实际的精度，也就是你写多少就是多少，而DECIMAL如不指定精度默认为(10,0)，也就是如果不指定精度，插入数值56.89，在数据库中存储的就是57。所以一般使用DECIMAL时就会指定精度，而使用FLOAT和DOUBLE就不用。</p>
<ul>
<li>区别三:</li>
</ul>
<p>　　　浮点数相对与定点数(DECIMAL)的优点就是在长度一定的情况下，浮点数能够表示更大的数据范围，但是缺点是会引起精度问题。</p>
<h4 id="2-3-3-3-什么时候使用FLOAT、DOUBLE、DECIMAL"><a href="#2-3-3-3-什么时候使用FLOAT、DOUBLE、DECIMAL" class="headerlink" title="2.3.3.3 什么时候使用FLOAT、DOUBLE、DECIMAL"></a>2.3.3.3 什么时候使用FLOAT、DOUBLE、DECIMAL</h4><p>　　　对精度要求比较高的时候，比如货币、科学数据等，使用DECIMAL的类型比较好。其他的时候，看你要存放的数据的大小而定了，一般使用DOUBLE。并且在使用浮点数时需要注意，尽量避免做浮点数的比较，比如加、减，谁大谁小，这样的操作，会引起精度缺失。相信在一些程序语言中，遇到过float精度丢失的问题。</p>
<h3 id="2-3-4-字符集"><a href="#2-3-4-字符集" class="headerlink" title="2.3.4 字符集"></a>2.3.4 字符集</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR</td>
<td align="left">0-255字节</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left">VARCHAR</td>
<td align="left">0-65535 字节</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">TINYBLOB</td>
<td align="left">0-255字节</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left">TINYTEXT</td>
<td align="left">0-255字节</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">0-65 535字节</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left">TEXT</td>
<td align="left">0-65 535字节</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMBLOB</td>
<td align="left">0-16 777 215字节</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMTEXT</td>
<td align="left">0-16 777 215字节</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left">LONGBLOB</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left">LONGTEXT</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
<p>char类型是定长类型，比如定义了20长度的<code>char</code>类型，只存一个字符也占用20个长度，char好处是处理速度快，缺点是空间占用大，把手机号、邮箱、密码等长度相对固定的设置为char类型是不错的选择。</p>
<p>varchar类型与char相反，点用空间受内容影响，可以把文章标题、介绍等设置为 varchar类型更合适。</p>
<h3 id="2-3-5-ENUM-SET"><a href="#2-3-5-ENUM-SET" class="headerlink" title="2.3.5 ENUM/SET"></a>2.3.5 ENUM/SET</h3><p><strong>ENUM</strong></p>
<p>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。换个枚举最大可以有 65535 个成员值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu ADD sex ENUM(&#x27;男&#x27;,&#x27;女&#x27;) DEFAULT NULL;</span><br></pre></td></tr></table></figure>

<p>可以使用索引或值添加enum数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO stu (sname,class_id,sex) VALUES(&#x27;李岗&#x27;,1,&#x27;男&#x27;);</span><br><span class="line">INSERT INTO stu (sname,class_id,sex) VALUES(&#x27;李玉&#x27;,1,2);</span><br></pre></td></tr></table></figure>

<p>可以使用值与索引检索ENUM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * from stu WHERE sex=&#x27;女&#x27;;</span><br><span class="line">SELECT * from stu WHERE sex=2;</span><br></pre></td></tr></table></figure>

<p><strong>SET</strong></p>
<p>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。一个 SET 类型最多可以包含 64 项元素。</p>
<ul>
<li>插入SET字段中的值如果有重复，则会自动删除重复的值</li>
<li>插入SET字段中的值会按顺序排列，排列规则就是按照SET中的值的排列优先顺序</li>
</ul>
<p>使用SET类型添加文章属性字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE article ADD flag SET(&#x27;推荐&#x27;,&#x27;置顶&#x27;,&#x27;图文&#x27;,&#x27;热门&#x27;);</span><br></pre></td></tr></table></figure>

<p>添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO article (title,status,flag)VALUES(&#x27;后盾人&#x27;,1,&#x27;图文,推荐,置顶&#x27;);</span><br></pre></td></tr></table></figure>

<p>使用 <code>find_in_set</code> 查找数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM article WHERE find_in_set(&#x27;图文&#x27;,flag);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-5-二进制类型"><a href="#2-3-5-二进制类型" class="headerlink" title="2.3.5 二进制类型"></a><strong>2.3.5 二进制类型</strong></h3><p>用来存放二进制数，也就是01010这种。有BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUNBLOB和LONGBLOB</p>
<p><img src="/2021/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2018072515590741.png" alt="img">　　　</p>
<p>BIT类型　</p>
<p>位字段类型，M表示插入值的位数，最大为64位，默认值为1，如果插入值小于M位，值的左边用0填充，　</p>
<p>5.2、BINARY和VARBINARY类型</p>
<p>格式：字段 BINARY(M)或者VARBINARY(M)</p>
<p>这两个跟CHAR和VARCHAR类似，</p>
<p>　　BINARY:长度是固定的，指定长度后，不足最大程度的，将在它们右边填充”\0”来达到指定长度，</p>
<p>　　VARBINARY：长度是可变的，制定好长度后，其长度可以在0到最大值之间，例如，指定字段数据类型为VARBINARY(20),如果插入的值的长度只有10，则实际存储空间为10加1，即实际占用的空间为字符串的实际长度加1.</p>
<p>我们说MySQL中对大小写不敏感，但是这两个数据类型却对大小写敏感，原因是他们是用二进制来保存数据的，比如A和a，两个的二进制就不一样。所以在很多时候我们需要区分大小写的时候，就会用到该类型。</p>
<p>注意：这两个类型的长度计算的是字节长度，一个字符等于2个字节，比如BINARY(4)这个表示能够存放4个字节的长度，也就是只能存放2个汉字。可以存4个字母。不要把这个长度当成二进制位的长度了，说是二进制字符串的意思是，用二进制来进行存储，但是其长度约束是字节长度。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE` `TABLE` `tmp(``　　b ``BINARY``(10)``）;</span><br><span class="line">` `INSERT` `INTO` `tmp ``VALUES``(``&#x27;a&#x27;``);``select` `* ``from` `tmp ``WHERE` `b=``&#x27;A&#x27;``;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2018072515590744.png" alt="img"></p>
<p>解释：在tmp表中存放了一个小写a，然后通过大写A查找表中，看是否能找到a，结果找不到，就验证了我们上面的说法，具有区分大小写的功能。</p>
<p>总结：BINARY和VARBINARY的主要作用就是用来区分大小写的，其他没什么作用，但是使用时要注意限制其大小的是字节数，而不是二进制位，它存储的格式是用二进制来存储的。这两个不要搞混淆了。</p>
<p>　5.3、BLOB类型</p>
<p>是一个二进制大对象,TINYBLOB(32kb)、BLOB（64kb）、MEDIUMBLOB(16M)和LONGBLOB（4GB）。一般存储的是一些图像，音频文件。</p>
<h3 id="2-3-6-日期与时间"><a href="#2-3-6-日期与时间" class="headerlink" title="2.3.6 日期与时间"></a>2.3.6 日期与时间</h3><table>
<thead>
<tr>
<th>日期时间类型</th>
<th>占用空间</th>
<th>日期格式</th>
<th>最小值</th>
<th>最大值</th>
<th>零值表示</th>
</tr>
</thead>
<tbody><tr>
<td>DATETIME</td>
<td>8 bytes</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
<td>0000-00-00 00:00:00</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4 bytes</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1970-01-01 08:00:01</td>
<td>2038-01-19 03:14:07</td>
<td>00000000000000</td>
</tr>
<tr>
<td>DATE</td>
<td>4 bytes</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01</td>
<td>9999-12-31</td>
<td>0000-00-00</td>
</tr>
<tr>
<td>TIME</td>
<td>3 bytes</td>
<td>HH:MM:SS</td>
<td>-838:59:59</td>
<td>838:59:59</td>
<td>00:00:00</td>
</tr>
<tr>
<td>YEAR</td>
<td>1 bytes</td>
<td>YYYY</td>
<td>1901</td>
<td>2155</td>
<td>0000</td>
</tr>
</tbody></table>
<ul>
<li>Mysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准</li>
<li>向数据表储存日期与时间必须使用ISO格式</li>
<li>如果添加数据全部是 nul<ul>
<li> DATE 和  DATETIME 添加的值为 null</li>
<li>TIMESTAMP 添加的是当前的系统时间</li>
<li>DATE添加的数据的时候，只会保存 年月日的部分，时分秒即使添加，也不会保存。</li>
<li>添加数据的时候，格式必须是  yyyy-MM-dd HH:mm:ss</li>
<li>添加数据的时候，三者必须使用引号引起来，单引号双引号都可以。</li>
</ul>
</li>
</ul>
<p>区别两个时间 <code>DATETIME</code> 和 <code>TIMESTAMP</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 相同点：</span><br><span class="line">	都可以表示 日期和时间  yyyy-MM-dd HH:mm:ss</span><br><span class="line">	</span><br><span class="line">2. 不同点:</span><br><span class="line">	A. 如果添加数据为 null, DATETIME 添加的值为 null 但是 TIMESTAMP 添加的值是 当前的系统时间。</span><br><span class="line">	B. 系统底层保存数据的区别。DATETIME底层会原封不动的保存，TIMESTAMP底层会转换成为UTC格式保存（包含时区）</span><br><span class="line">	</span><br><span class="line">3. 版本问题:</span><br><span class="line">	TIMESTAMP 在不同版本当中，区别很大。</span><br><span class="line">	如果是 MySQL5.6.5 版本之前的，TIMESTAMP 在一张表当中，只能存在一列，他的数据类型为 TIMESTAMP</span><br><span class="line">	如果是 MySQL5.6.5 版本之后的，TIMESTAMP 在一张表当中，可以存在多列，他们的数据类型为 TIMESTAMP</span><br></pre></td></tr></table></figure>

<p><strong>格式化</strong></p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%a</td>
<td align="left">缩写星期名</td>
</tr>
<tr>
<td align="left">%b</td>
<td align="left">缩写月名</td>
</tr>
<tr>
<td align="left">%c</td>
<td align="left">月，数值</td>
</tr>
<tr>
<td align="left">%D</td>
<td align="left">带有英文前缀的月中的天</td>
</tr>
<tr>
<td align="left">%d</td>
<td align="left">月的天，数值(00-31)</td>
</tr>
<tr>
<td align="left">%e</td>
<td align="left">月的天，数值(0-31)</td>
</tr>
<tr>
<td align="left">%f</td>
<td align="left">微秒</td>
</tr>
<tr>
<td align="left">%H</td>
<td align="left">小时 (00-23)</td>
</tr>
<tr>
<td align="left">%h</td>
<td align="left">小时 (01-12)</td>
</tr>
<tr>
<td align="left">%I</td>
<td align="left">小时 (01-12)</td>
</tr>
<tr>
<td align="left">%i</td>
<td align="left">分钟，数值(00-59)</td>
</tr>
<tr>
<td align="left">%j</td>
<td align="left">年的天 (001-366)</td>
</tr>
<tr>
<td align="left">%k</td>
<td align="left">小时 (0-23)</td>
</tr>
<tr>
<td align="left">%l</td>
<td align="left">小时 (1-12)</td>
</tr>
<tr>
<td align="left">%M</td>
<td align="left">月名</td>
</tr>
<tr>
<td align="left">%m</td>
<td align="left">月，数值(00-12)</td>
</tr>
<tr>
<td align="left">%p</td>
<td align="left">AM 或 PM</td>
</tr>
<tr>
<td align="left">%r</td>
<td align="left">时间，12-小时（hh:mm:ss AM 或 PM）</td>
</tr>
<tr>
<td align="left">%S</td>
<td align="left">秒(00-59)</td>
</tr>
<tr>
<td align="left">%s</td>
<td align="left">秒(00-59)</td>
</tr>
<tr>
<td align="left">%T</td>
<td align="left">时间, 24-小时 (hh:mm:ss)</td>
</tr>
<tr>
<td align="left">%U</td>
<td align="left">周 (00-53) 星期日是一周的第一天</td>
</tr>
<tr>
<td align="left">%u</td>
<td align="left">周 (00-53) 星期一是一周的第一天</td>
</tr>
<tr>
<td align="left">%V</td>
<td align="left">周 (01-53) 星期日是一周的第一天，与 %X 使用</td>
</tr>
<tr>
<td align="left">%v</td>
<td align="left">周 (01-53) 星期一是一周的第一天，与 %x 使用</td>
</tr>
<tr>
<td align="left">%W</td>
<td align="left">星期名</td>
</tr>
<tr>
<td align="left">%w</td>
<td align="left">周的天 （0=星期日, 6=星期六）</td>
</tr>
<tr>
<td align="left">%X</td>
<td align="left">年，其中的星期日是周的第一天，4 位，与 %V 使用</td>
</tr>
<tr>
<td align="left">%x</td>
<td align="left">年，其中的星期一是周的第一天，4 位，与 %v 使用</td>
</tr>
<tr>
<td align="left">%Y</td>
<td align="left">年，4 位</td>
</tr>
<tr>
<td align="left">%y</td>
<td align="left">年，2 位</td>
</tr>
</tbody></table>
<p>使用<code>Date_format</code>格式化日期与时间显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sname,DATE_FORMAT(birthday,&#x27;%Y年%m月%d %H时%i分%s秒&#x27;) as birthday from stu;</span><br></pre></td></tr></table></figure>

<p>使用<code>time_format</code>格式化输出时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sname,TIME_FORMAT(birthday,&#x27;%r&#x27;) as birthday from stu;</span><br></pre></td></tr></table></figure>

<p>以时间戳格式来记录日期与时间。</p>
<p><strong>设置TIMESTAMP字段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu ADD updated_at </span><br><span class="line">TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">INSERT INTO stu SET sname = &#x27;后盾人&#x27;,updated_at = &#x27;2020-2-12 10:33:12&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>添加数据时自动更新时间</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu ADD updated_at </span><br><span class="line">TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP </span><br><span class="line">ON UPDATE CURRENT_TIMESTAMP;</span><br></pre></td></tr></table></figure>

<p>当执行添加与更新时字段将自动为当前时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into stu set sname = &#x27;小张&#x27;;</span><br><span class="line">update stu set sname = &#x27;ih&#x27; where id= 7;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行更新或添加都会改变timestamp字段</li>
</ul>
<h3 id="2-3-7、如何选择数据类型"><a href="#2-3-7、如何选择数据类型" class="headerlink" title="2.3.7、如何选择数据类型"></a><strong>2.3.7、如何选择数据类型</strong></h3><p>1、整数和浮点数</p>
<p>　　如果不需要小数部分，则使用整数来保存数据，并且根据整数的大小，来选择合适的整数类型，如果需要小数部分，则使用浮点数类型，浮点数类型中，有float和double，如果需要精度高一点，则选择double。根据自己的需求来决定选什么。</p>
<p>2、浮点数和定点数</p>
<p>　　浮点数FLOAT、DOUBLE相对应定点数DECIMAL的优势在于：在长度一定的情况下，浮点数能表示更大的数据范围，但是浮点数容易产生误差，因此在精度比较高时，建议使用DECIMAL，比如货币这一类东西，就用DECIMAL比较合理，注意浮点数在进行加减运算时也容易出现问题。如果进行数值比较，也建议用DECIMAL</p>
<p>3、日期与时间类型</p>
<p>　　可以看上面详解时的图，根据各种格式，选择自己所需要的数据类型，注意TIMESTAMP和DATETIME的区别，一个是跟时区有关，一个无关，其他没什么大的区别。</p>
<p>4、CHAR与VARCHAR之间的特点与选择</p>
<p>　　区别：</p>
<p>　　　　CHAR是固定长度字符、VARCHAR是可变长度字符。CHAR会自动删除插入数据的尾部空格，VARCHAR不会。<br> 　　　CHAR是固定长度，处理速度比VARCHAR更快，缺点很明显，浪费存储空间，所以对存储不大，但在速度上有要求的可以使用CHAR类型，反之用VARCHAR。</p>
<p>5、ENUM和SET</p>
<p>　　　ENUM只能取单值，也就是从枚举类型中选取其中一个值，但是SET可以取多值，<br> 　　ENUM最多能存放65535个成员，SET只能65个<br> 　　空字符串也能在SET中存储，</p>
<p>　　　要存储一个人的喜爱时，最好使用SET类型，其实最重要的是看具体的情况在选取最为合适的把</p>
<p>6、BLOB和TEXT</p>
<p>　　　BLOB是二进制字符串，TEXT是非二进制字符串，两者均可存放大容量的信息，BLOB主要存储图片、音频信息，而TEXT只能存储纯文本文件。分清楚两者的用途</p>
<p>7、BINARY和VARBINARY</p>
<p>　　　这两个的区别和CHAR与VARCHAR的区别差不多，BINARY是固定长度、VARBINARY是可变程度，这两个的作用就是为了区分大小写的，注意这两个是字节字符串。</p>
<h2 id="2-4-DML"><a href="#2-4-DML" class="headerlink" title="2.4 DML"></a>2.4 DML</h2><p><strong>新增表记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名称  [(列名1,列名2,列名3)]  VALUES (列1的数值, 列2的数值, 列3的数值);</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 删除表</span><br><span class="line">DROP TABLE IF EXISTS student_six;</span><br><span class="line"></span><br><span class="line">-- 2. 创建表</span><br><span class="line">CREATE TABLE IF NOT EXISTS student_six(</span><br><span class="line">	sid INT,</span><br><span class="line">	sname VARCHAR(20),</span><br><span class="line">	sage INT,</span><br><span class="line">	sgender ENUM(&#x27;男&#x27;,&#x27;女&#x27;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 3. 新增数据(完整写法)</span><br><span class="line">INSERT INTO student_six (sid,sname,sage,sgender) VALUES (1,&#x27;迪丽热巴&#x27;,21,&#x27;女&#x27;);</span><br><span class="line">INSERT INTO student_six (sid,sname,sage) VALUES (2,&#x27;古力娜扎&#x27;,23);</span><br><span class="line">INSERT INTO student_six (sage,sid,sname) VALUES (24,3,&#x27;马尔扎哈&#x27;);</span><br><span class="line">INSERT INTO student_six (sid,sname) VALUES (4,&#x27;张三&#x27;),(5,&#x27;李四&#x27;),(6,&#x27;王五&#x27;);</span><br><span class="line"></span><br><span class="line">-- 4. 查询数据</span><br><span class="line">SELECT * FROM student_six;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   注意事项：</span><br><span class="line">      1. 完整写法当中，需要写出列名称，要求就是 列名和列的值顺序要对应。</span><br><span class="line">      2. 还可以进行批量的添加数据</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><strong>修改表记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名称 SET 列名1=修改值1, 列名2=修改值2;</span><br><span class="line">UPDATE 表名称 SET 列名1=修改值1, 列名2=修改值2  WHERE 条件;</span><br></pre></td></tr></table></figure>

<p>案例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 删除表</span><br><span class="line">DROP TABLE IF EXISTS student_six;</span><br><span class="line"></span><br><span class="line">-- 2. 创建表</span><br><span class="line">CREATE TABLE IF NOT EXISTS student_six(</span><br><span class="line">	sid INT,</span><br><span class="line">	sname VARCHAR(20),</span><br><span class="line">	sage INT,</span><br><span class="line">	sgender ENUM(&#x27;男&#x27;,&#x27;女&#x27;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 3. 插入表记录</span><br><span class="line">INSERT INTO student_six VALUES (1,&#x27;张三&#x27;,23,&#x27;男&#x27;),(2,&#x27;李四&#x27;,24,&#x27;女&#x27;),(3,&#x27;王五&#x27;,25,&#x27;男&#x27;);</span><br><span class="line"></span><br><span class="line">-- 4. 查询表数据</span><br><span class="line">SELECT * FROM student_six;</span><br><span class="line"></span><br><span class="line">-- 5. 修改操作：将sid=1的数据进行修改。 sname=&quot;张三丰&quot;,sage=100</span><br><span class="line">UPDATE student_six SET sname=&#x27;张三丰&#x27;,sage=100 WHERE sid=1;</span><br><span class="line"></span><br><span class="line">-- 6. 修改操作：将sage=50</span><br><span class="line">UPDATE student_six SET sage=50;</span><br></pre></td></tr></table></figure>



<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p><code>加 WHERE</code> 和 <code>不加 WHERE</code> 有什么区别呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 如果加上了 WHERE 条件，则符合条件的几行记录，才会被修改。</span><br><span class="line">2. 如果没有加上 WHERE 条件，则所有的记录，都认定为符合条件，会全部进行修改。</span><br></pre></td></tr></table></figure>

<p><strong>删除表记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名称;</span><br><span class="line">DELETE FROM 表名称 WHERE 条件;</span><br><span class="line"></span><br><span class="line">TRUNCATE 表名称;</span><br></pre></td></tr></table></figure>

<p>案例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 删除表</span><br><span class="line">DROP TABLE IF EXISTS student_six;</span><br><span class="line"></span><br><span class="line">-- 2. 创建表</span><br><span class="line">CREATE TABLE IF NOT EXISTS student_six(</span><br><span class="line">	sid INT,</span><br><span class="line">	sname VARCHAR(20),</span><br><span class="line">	sage INT,</span><br><span class="line">	sgender ENUM(&#x27;男&#x27;,&#x27;女&#x27;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 3. 插入表记录</span><br><span class="line">INSERT INTO student_six VALUES (1,&#x27;张三&#x27;,23,&#x27;男&#x27;),(2,&#x27;李四&#x27;,24,&#x27;女&#x27;),(3,&#x27;王五&#x27;,25,&#x27;男&#x27;);</span><br><span class="line"></span><br><span class="line">-- 4. 查询表数据</span><br><span class="line">SELECT * FROM student_six;</span><br><span class="line"></span><br><span class="line">-- 5. 删除某一条记录， 删除 sid=2</span><br><span class="line">DELETE FROM student_six WHERE sid=2;</span><br><span class="line"></span><br><span class="line">-- 6. 删除记录，如果不写 WHERE 条件会逐行删除表记录</span><br><span class="line">DELETE FROM student_six;</span><br><span class="line"></span><br><span class="line">-- 7. 如果想要删除整张表的记录，直接采用 TRUNCATE，先删除表，再创建一个一模一样的空表</span><br><span class="line">TRUNCATE student_six;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 加WHERE条件 和 不加WHERE条件 有什么区别？</span><br><span class="line">	A. 不加 WHERE 条件, 他是逐行删除表记录，直到所有的记录全部删除完毕。</span><br><span class="line">	B. 加上 WHERE 条件, 他是根据条件进行删除，只删除满足条件的数据。</span><br><span class="line">	</span><br><span class="line">2. TRUNCATE 和 WHERE 的区别?</span><br><span class="line">	A. TRUNCATE 的删除方式是：直接删除整张表，然后创建一个一模一样的空表。</span><br><span class="line">	B. WHERE 的删除方式是： 逐行删除表记录，效率非常低。</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
</search>
